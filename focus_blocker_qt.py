import sys
import json
import random
import platform
import copy
import math
import logging
import threading
from pathlib import Path
from typing import Optional, Dict, List, Any, Callable
from datetime import datetime, timedelta

# Module logger
logger = logging.getLogger(__name__)

try:
    from __version__ import __version__ as APP_VERSION
except ImportError:
    APP_VERSION = "3.1.4"

# Deferred imports - these are loaded in load_heavy_modules() for faster startup
# game_state, eye_protection_tab, entitidex_tab are imported after single instance check
GameStateManager = None
init_game_state = None
get_game_state = None
reset_game_state = None
EyeProtectionTab = None
EntitidexTab = None

# Hide console window on Windows
if platform.system() == "Windows":
    import ctypes
    from ctypes import wintypes
    try:
        # ctypes.windll.user32.ShowWindow(ctypes.windll.kernel32.GetConsoleWindow(), 0)
        pass
    except Exception:
        pass

from PySide6 import QtCore, QtGui, QtWidgets

# pynput for reliable global hotkeys (works even when window hidden)
try:
    from pynput import keyboard as pynput_keyboard
    PYNPUT_AVAILABLE = True
except ImportError:
    PYNPUT_AVAILABLE = False
    pynput_keyboard = None

# Import enhanced dialogs
from item_drop_dialog import EnhancedItemDropDialog
from level_up_dialog import EnhancedLevelUpDialog
from emergency_cleanup_dialog import EmergencyCleanupDialog, show_emergency_cleanup_dialog
from styled_dialog import (
    StyledDialog, StyledMessageBox, StyledInputDialog,
    styled_info, styled_warning, styled_error, styled_question, styled_input,
    create_tab_help_button, add_help_button_to_header, add_tab_help_button
)


# ============================================================================
# Silent Message Box Helper (uses styled dialogs)
# ============================================================================

def show_message(parent, title: str, text: str, icon: QtWidgets.QMessageBox.Icon = QtWidgets.QMessageBox.Information) -> int:
    """Show a styled message box without playing the system sound."""
    if icon == QtWidgets.QMessageBox.Warning:
        styled_warning(parent, title, text)
    elif icon == QtWidgets.QMessageBox.Critical:
        styled_error(parent, title, text)
    else:
        styled_info(parent, title, text)
    return QtWidgets.QMessageBox.Ok


def show_info(parent, title: str, text: str) -> int:
    """Show an information message box using styled frameless dialog."""
    styled_info(parent, title, text)
    return QtWidgets.QMessageBox.Ok


def show_warning(parent, title: str, text: str) -> int:
    """Show a warning message box using styled frameless dialog."""
    styled_warning(parent, title, text)
    return QtWidgets.QMessageBox.Ok


def show_error(parent, title: str, text: str) -> int:
    """Show an error/critical message box using styled frameless dialog."""
    styled_error(parent, title, text)
    return QtWidgets.QMessageBox.Ok


def show_question(parent, title: str, text: str, 
                  buttons: QtWidgets.QMessageBox.StandardButtons = QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                  default_button: QtWidgets.QMessageBox.StandardButton = QtWidgets.QMessageBox.No) -> int:
    """Show a question message box with Yes/No buttons using styled frameless dialog."""
    # Convert Qt button flags to list of button names
    button_list = []
    if buttons & QtWidgets.QMessageBox.Yes:
        button_list.append("Yes")
    if buttons & QtWidgets.QMessageBox.No:
        button_list.append("No")
    if buttons & QtWidgets.QMessageBox.Ok:
        button_list.append("OK")
    if buttons & QtWidgets.QMessageBox.Cancel:
        button_list.append("Cancel")
    
    result = styled_question(parent, title, text, button_list or ["Yes", "No"])
    
    # Map result back to Qt constants
    if result == "Yes":
        return QtWidgets.QMessageBox.Yes
    elif result == "No":
        return QtWidgets.QMessageBox.No
    elif result == "OK":
        return QtWidgets.QMessageBox.Ok
    elif result == "Cancel":
        return QtWidgets.QMessageBox.Cancel
    else:
        return QtWidgets.QMessageBox.No


def request_system_permission(parent, action: str, title: str, description: str, 
                               details: str, persistence_info: str, revert_info: str,
                               blocker) -> bool:
    """
    Request user permission for system-level changes with comprehensive information.
    
    Args:
        parent: Parent widget
        action: Short action name (e.g., "modify_hosts", "startup_registry")
        title: Short title describing the action (e.g., "Modify Hosts File")
        description: User-friendly description of what will be changed
        details: Technical details about what exactly will happen
        persistence_info: Explanation of whether changes are temporary or permanent
        revert_info: How to manually revert changes if needed
        blocker: BlockerCore instance to save preferences
        
    Returns:
        True if user grants permission, False otherwise
    """
    # Check if user previously approved this action
    if blocker.system_permissions.get(action, False):
        return True
    
    # Create custom dialog with comprehensive info
    dialog = QtWidgets.QDialog(parent)
    dialog.setWindowTitle("‚ö†Ô∏è System Modification Permission")
    dialog.setModal(True)
    dialog.setMinimumWidth(550)
    dialog.setMaximumWidth(700)
    
    layout = QtWidgets.QVBoxLayout(dialog)
    layout.setSpacing(12)
    layout.setContentsMargins(20, 20, 20, 20)
    
    # Icon and title
    title_layout = QtWidgets.QHBoxLayout()
    icon_label = QtWidgets.QLabel("‚ö†Ô∏è")
    icon_label.setStyleSheet("font-size: 40px;")
    title_label = QtWidgets.QLabel(f"<b>{title}</b>")
    title_label.setStyleSheet("font-size: 16px; font-weight: bold; color: #e17055;")
    title_layout.addWidget(icon_label)
    title_layout.addWidget(title_label)
    title_layout.addStretch()
    layout.addLayout(title_layout)
    
    # Description
    desc_label = QtWidgets.QLabel(description)
    desc_label.setWordWrap(True)
    desc_label.setStyleSheet("font-size: 13px; color: #dfe6e9; padding: 8px 0;")
    layout.addWidget(desc_label)
    
    # Technical details section (collapsible-style info box)
    details_frame = QtWidgets.QFrame()
    details_frame.setStyleSheet("""
        QFrame {
            background: rgba(45, 52, 54, 0.8);
            border: 1px solid #636e72;
            border-radius: 6px;
            padding: 10px;
        }
    """)
    details_layout = QtWidgets.QVBoxLayout(details_frame)
    details_layout.setSpacing(8)
    
    # What will happen
    what_header = QtWidgets.QLabel("üìã <b>What will happen:</b>")
    what_header.setStyleSheet("font-size: 12px; color: #74b9ff;")
    details_layout.addWidget(what_header)
    
    what_text = QtWidgets.QLabel(details)
    what_text.setWordWrap(True)
    what_text.setStyleSheet("font-size: 11px; color: #b2bec3; margin-left: 16px;")
    details_layout.addWidget(what_text)
    
    # Persistence info
    persist_header = QtWidgets.QLabel("‚è±Ô∏è <b>Duration of changes:</b>")
    persist_header.setStyleSheet("font-size: 12px; color: #fdcb6e;")
    details_layout.addWidget(persist_header)
    
    persist_text = QtWidgets.QLabel(persistence_info)
    persist_text.setWordWrap(True)
    persist_text.setStyleSheet("font-size: 11px; color: #b2bec3; margin-left: 16px;")
    details_layout.addWidget(persist_text)
    
    # Revert info
    revert_header = QtWidgets.QLabel("üîÑ <b>How to revert manually:</b>")
    revert_header.setStyleSheet("font-size: 12px; color: #55efc4;")
    details_layout.addWidget(revert_header)
    
    revert_text = QtWidgets.QLabel(revert_info)
    revert_text.setWordWrap(True)
    revert_text.setStyleSheet("font-size: 11px; color: #b2bec3; margin-left: 16px;")
    details_layout.addWidget(revert_text)
    
    layout.addWidget(details_frame)
    
    # "Don't show again" checkbox
    dont_ask_checkbox = QtWidgets.QCheckBox("Trust this action ‚Äî don't ask again")
    dont_ask_checkbox.setStyleSheet("""
        QCheckBox {
            color: #74b9ff;
            font-size: 12px;
            spacing: 8px;
            padding: 8px 0;
        }
    """)
    layout.addWidget(dont_ask_checkbox)
    
    # Buttons
    button_layout = QtWidgets.QHBoxLayout()
    button_layout.addStretch()
    
    deny_btn = QtWidgets.QPushButton("üö´ Deny")
    deny_btn.setStyleSheet("""
        QPushButton {
            background: #636e72;
            color: white;
            font-size: 13px;
            font-weight: bold;
            border-radius: 6px;
            padding: 10px 24px;
            min-width: 100px;
        }
        QPushButton:hover {
            background: #2d3436;
        }
    """)
    deny_btn.clicked.connect(dialog.reject)
    
    allow_btn = QtWidgets.QPushButton("‚úÖ Allow")
    allow_btn.setStyleSheet("""
        QPushButton {
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 #00b894, stop:1 #00a884);
            color: white;
            font-size: 13px;
            font-weight: bold;
            border-radius: 6px;
            padding: 10px 24px;
            min-width: 100px;
        }
        QPushButton:hover {
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 #55efc4, stop:1 #00b894);
        }
    """)
    allow_btn.clicked.connect(dialog.accept)
    allow_btn.setDefault(True)
    
    button_layout.addWidget(deny_btn)
    button_layout.addWidget(allow_btn)
    layout.addLayout(button_layout)
    
    # Show dialog
    result = dialog.exec()
    
    # Save preference if "don't ask again" is checked AND user allowed
    if dont_ask_checkbox.isChecked() and result == QtWidgets.QDialog.Accepted:
        blocker.system_permissions[action] = True
        blocker.save_config()
    
    return result == QtWidgets.QDialog.Accepted


# ============================================================================
# Entity Perk Toast Notification - Non-blocking feedback when perks activate
# ============================================================================

class PerkToast(QtWidgets.QWidget):
    """
    A non-blocking toast notification for entity perk activation.
    
    Shows a brief message that fades in and out automatically.
    Used to provide visual feedback when entity perks affect gameplay.
    """
    
    _active_toasts = []  # Track active toasts for stacking
    
    def __init__(self, message: str, icon: str = "‚ú®", duration_ms: int = 2500,
                 parent: Optional[QtWidgets.QWidget] = None):
        super().__init__(parent)
        self.setWindowFlags(
            QtCore.Qt.WindowType.FramelessWindowHint |
            QtCore.Qt.WindowType.WindowStaysOnTopHint |
            QtCore.Qt.WindowType.BypassWindowManagerHint
        )
        self.setAttribute(QtCore.Qt.WidgetAttribute.WA_TranslucentBackground)
        self.setAttribute(QtCore.Qt.WidgetAttribute.WA_ShowWithoutActivating)
        self.setAttribute(QtCore.Qt.WidgetAttribute.WA_DeleteOnClose)
        
        # Create layout
        layout = QtWidgets.QHBoxLayout(self)
        layout.setContentsMargins(12, 8, 12, 8)
        
        # Icon
        icon_label = QtWidgets.QLabel(icon)
        icon_label.setStyleSheet("font-size: 18px;")
        layout.addWidget(icon_label)
        
        # Message
        msg_label = QtWidgets.QLabel(message)
        msg_label.setStyleSheet("""
            color: #fff;
            font-size: 13px;
            font-weight: bold;
        """)
        layout.addWidget(msg_label)
        
        # Container styling
        self.setStyleSheet("""
            PerkToast {
                background-color: rgba(139, 92, 246, 0.95);
                border-radius: 8px;
                border: 1px solid rgba(255, 255, 255, 0.3);
            }
        """)
        
        # Animation setup
        self.opacity = QtWidgets.QGraphicsOpacityEffect(self)
        self.setGraphicsEffect(self.opacity)
        
        self.fade_in = QtCore.QPropertyAnimation(self.opacity, b"opacity")
        self.fade_in.setDuration(200)
        self.fade_in.setStartValue(0.0)
        self.fade_in.setEndValue(1.0)
        
        self.fade_out = QtCore.QPropertyAnimation(self.opacity, b"opacity")
        self.fade_out.setDuration(400)
        self.fade_out.setStartValue(1.0)
        self.fade_out.setEndValue(0.0)
        self.fade_out.finished.connect(self._on_finished)
        
        # Timer for auto-dismiss
        self.dismiss_timer = QtCore.QTimer()
        self.dismiss_timer.setSingleShot(True)
        self.dismiss_timer.timeout.connect(self._start_fade_out)
        self.dismiss_timer.setInterval(duration_ms)
        
    def show_at_bottom_right(self, parent: Optional[QtWidgets.QWidget] = None):
        """Show the toast at bottom-right of parent or screen."""
        self.adjustSize()
        
        # Calculate position
        if parent:
            parent_rect = parent.geometry()
            screen_pos = parent.mapToGlobal(QtCore.QPoint(0, 0))
            x = screen_pos.x() + parent_rect.width() - self.width() - 20
            y = screen_pos.y() + parent_rect.height() - self.height() - 20
        else:
            screen = QtWidgets.QApplication.primaryScreen().availableGeometry()
            x = screen.right() - self.width() - 20
            y = screen.bottom() - self.height() - 20
        
        # Stack below other active toasts
        offset = len(PerkToast._active_toasts) * 50
        y -= offset
        
        self.move(x, y)
        PerkToast._active_toasts.append(self)
        
        self.show()
        self.raise_()  # Ensure toast is on top
        self.fade_in.start()
        self.dismiss_timer.start()
        
    def _start_fade_out(self):
        self.fade_out.start()
        
    def _on_finished(self):
        if self in PerkToast._active_toasts:
            PerkToast._active_toasts.remove(self)
        self.close()
        self.deleteLater()


def show_perk_toast(message: str, icon: str = "‚ú®", parent: QtWidgets.QWidget = None):
    """
    Show a non-blocking toast notification for perk activation.
    
    Args:
        message: The perk effect message (e.g., "Saved 1 coin!")
        icon: Emoji icon to display
        parent: Parent widget for positioning
    """
    toast = PerkToast(message, icon, parent=parent)
    toast.show_at_bottom_right(parent)


# ============================================================================
# No-Scroll Widgets - Prevents accidental changes via scroll wheel
# ============================================================================

class NoScrollComboBox(QtWidgets.QComboBox):
    """
    A QComboBox that ignores scroll wheel events.
    
    This prevents users from accidentally changing dropdown values
    while scrolling through the application.
    """
    
    def wheelEvent(self, event: QtGui.QWheelEvent) -> None:
        """Ignore scroll wheel events to prevent accidental changes."""
        event.ignore()


class NoScrollSpinBox(QtWidgets.QSpinBox):
    """
    A QSpinBox that ignores scroll wheel events.
    
    This prevents users from accidentally changing values
    while scrolling through the application.
    """
    
    def wheelEvent(self, event: QtGui.QWheelEvent) -> None:
        """Ignore scroll wheel events to prevent accidental changes."""
        event.ignore()


class NoScrollDoubleSpinBox(QtWidgets.QDoubleSpinBox):
    """
    A QDoubleSpinBox that ignores scroll wheel events.
    
    This prevents users from accidentally changing values
    while scrolling through the application.
    """
    
    def wheelEvent(self, event: QtGui.QWheelEvent) -> None:
        """Ignore scroll wheel events to prevent accidental changes."""
        event.ignore()


# Module-level variables for deferred imports (initialized in load_heavy_modules)
BlockerCore = None
BlockMode = None
EnforcementMode = None
SITE_CATEGORIES = None
AI_AVAILABLE = False
GOALS_PATH = None
STATS_PATH = None
BYPASS_LOGGER_AVAILABLE = False
ProductivityAnalyzer = None
GamificationEngine = None
FocusGoals = None
GAMIFICATION_AVAILABLE = False
RARITY_POWER = {"Common": 10, "Uncommon": 25, "Rare": 50, "Epic": 100, "Legendary": 250}
ITEM_THEMES = None
get_item_themes = None
get_diary_power_tier = None
calculate_character_power = None
get_power_breakdown = None
calculate_rarity_bonuses = None
calculate_merge_success_rate = None
get_merge_result_rarity = None
perform_lucky_merge = None
is_merge_worthwhile = None
generate_diary_entry = None
calculate_set_bonuses = None
generate_item = None
generate_daily_reward_item = None
get_current_tier = None
get_boosted_rarity = None

def _fallback_get_work_day_date(dt=None):
    """Fallback work day date function - day starts at 5 AM."""
    if dt is None:
        dt = datetime.now()
    if dt.hour < 5:
        dt = dt - timedelta(days=1)
    return dt.strftime("%Y-%m-%d")

get_work_day_date = _fallback_get_work_day_date
AVAILABLE_STORIES = {}
STORY_MODE_ACTIVE = "story"
STORY_MODE_HERO_ONLY = "hero_only"
STORY_MODE_DISABLED = "disabled"
set_story_mode = None
get_story_mode = None
switch_story = None
ensure_hero_structure = None
sync_hero_data = None
is_gamification_enabled = lambda adhd_buster: False
# Story gear theme helpers
GEAR_SLOTS = ["Helmet", "Chestplate", "Gauntlets", "Boots", "Shield", "Weapon", "Cloak", "Amulet"]
STORY_GEAR_THEMES = {}
get_story_gear_theme = None
get_slot_display_name = None
get_selected_story = None  # Get current story ID for themed slot names
# Gear optimization
optimize_equipped_gear = None
find_potential_set_bonuses = None
# Lucky options system
calculate_total_lucky_bonuses = None
format_lucky_options = None
# Entity power perks for hero display
get_entity_power_perks = None
# XP and leveling system
calculate_session_xp = None
award_xp = None
get_level_from_xp = None
get_level_title = None
get_celebration_message = None
# Weight tracking functions
check_weight_entry_rewards = None
get_weight_stats = None
format_weight_change = None
check_all_weight_rewards = None
calculate_bmi = None
get_bmi_classification = None
get_ideal_weight_range = None
predict_goal_date = None
get_historical_comparisons = None
get_weekly_insights = None
WEIGHT_ENTRY_TAGS = []
format_entry_note = None
# Activity tracking functions
ACTIVITY_TYPES = []
INTENSITY_LEVELS = []
ACTIVITY_MIN_DURATION = 10
check_all_activity_rewards = None
get_activity_stats = None
format_activity_duration = None
check_activity_streak = None
# Sleep tracking functions
SLEEP_CHRONOTYPES = []
SLEEP_QUALITY_FACTORS = []
SLEEP_DISRUPTION_TAGS = []
check_all_sleep_rewards = None
get_sleep_stats = None
format_sleep_duration = None
check_sleep_streak = None
get_sleep_recommendation = None
get_screen_off_bonus_rarity = None
# Hydration tracking functions
get_water_reward_rarity = None
can_log_water = None
get_hydration_streak_bonus_rarity = None
check_water_entry_reward = None
get_hydration_stats = None
HYDRATION_MIN_INTERVAL_HOURS = 2
HYDRATION_MAX_DAILY_GLASSES = 5

# City Building System (optional feature)
CITY_AVAILABLE = False
CityTab = None


def load_heavy_modules():
    """Load heavy modules at startup."""
    global BlockerCore, BlockMode, EnforcementMode, SITE_CATEGORIES, AI_AVAILABLE
    global GOALS_PATH, STATS_PATH, BYPASS_LOGGER_AVAILABLE
    global ProductivityAnalyzer, GamificationEngine, FocusGoals
    global GAMIFICATION_AVAILABLE, RARITY_POWER, ITEM_THEMES, get_item_themes
    global CITY_AVAILABLE, CityTab
    global get_diary_power_tier, calculate_character_power, get_power_breakdown
    global calculate_rarity_bonuses, calculate_merge_success_rate, get_merge_result_rarity
    global perform_lucky_merge, is_merge_worthwhile, generate_diary_entry
    global calculate_set_bonuses, generate_item, generate_daily_reward_item
    global get_current_tier, get_boosted_rarity, AVAILABLE_STORIES
    global STORY_MODE_ACTIVE, STORY_MODE_HERO_ONLY, STORY_MODE_DISABLED
    global set_story_mode, get_story_mode, switch_story, ensure_hero_structure
    global sync_hero_data, is_gamification_enabled
    global GEAR_SLOTS, STORY_GEAR_THEMES, get_story_gear_theme, get_slot_display_name
    global optimize_equipped_gear, find_potential_set_bonuses
    global calculate_total_lucky_bonuses, format_lucky_options, get_entity_power_perks
    global calculate_session_xp, award_xp, get_level_from_xp, get_level_title, get_celebration_message
    # Weight tracking
    global check_weight_entry_rewards, get_weight_stats, format_weight_change, check_all_weight_rewards
    global calculate_bmi, get_bmi_classification, get_ideal_weight_range
    global predict_goal_date, get_historical_comparisons, get_weekly_insights
    global WEIGHT_ENTRY_TAGS, format_entry_note
    # Activity tracking
    global ACTIVITY_TYPES, INTENSITY_LEVELS, ACTIVITY_MIN_DURATION
    global check_all_activity_rewards, get_activity_stats, format_activity_duration, check_activity_streak
    # Sleep tracking
    global SLEEP_CHRONOTYPES, SLEEP_QUALITY_FACTORS, SLEEP_DISRUPTION_TAGS
    global check_all_sleep_rewards, get_sleep_stats, format_sleep_duration
    global check_sleep_streak, get_sleep_recommendation, get_screen_off_bonus_rarity
    # Hydration tracking
    global get_water_reward_rarity, can_log_water
    global get_hydration_streak_bonus_rarity, check_water_entry_reward, get_hydration_stats
    global HYDRATION_MIN_INTERVAL_HOURS, HYDRATION_MAX_DAILY_GLASSES
    # Deferred UI component imports
    global GameStateManager, init_game_state, get_game_state, reset_game_state
    global EyeProtectionTab, EntitidexTab
    
    # Import deferred UI components first
    from game_state import (
        GameStateManager as _GameStateManager,
        init_game_state as _init_game_state,
        get_game_state as _get_game_state,
        reset_game_state as _reset_game_state,
    )
    GameStateManager = _GameStateManager
    init_game_state = _init_game_state
    get_game_state = _get_game_state
    reset_game_state = _reset_game_state
    
    from eye_protection_tab import EyeProtectionTab as _EyeProtectionTab
    EyeProtectionTab = _EyeProtectionTab
    
    from entitidex_tab import EntitidexTab as _EntitidexTab
    EntitidexTab = _EntitidexTab
    
    # City Building System (optional feature)
    try:
        from city_tab import CityTab as _CityTab, CITY_AVAILABLE as _CITY_AVAILABLE
        CityTab = _CityTab
        CITY_AVAILABLE = _CITY_AVAILABLE
    except ImportError:
        CityTab = None
        CITY_AVAILABLE = False
    
    from core_logic import (
        BlockerCore as _BlockerCore,
        BlockMode as _BlockMode,
        EnforcementMode as _EnforcementMode,
        SITE_CATEGORIES as _SITE_CATEGORIES,
        AI_AVAILABLE as _AI_AVAILABLE,
        GOALS_PATH as _GOALS_PATH,
        STATS_PATH as _STATS_PATH,
        BYPASS_LOGGER_AVAILABLE as _BYPASS_LOGGER_AVAILABLE,
        APP_DIR as _APP_DIR,
    )
    BlockerCore = _BlockerCore
    BlockMode = _BlockMode
    EnforcementMode = _EnforcementMode
    SITE_CATEGORIES = _SITE_CATEGORIES
    AI_AVAILABLE = _AI_AVAILABLE
    GOALS_PATH = _GOALS_PATH
    STATS_PATH = _STATS_PATH
    BYPASS_LOGGER_AVAILABLE = _BYPASS_LOGGER_AVAILABLE
    APP_DIR = _APP_DIR
    
    # AI helpers (guarded for optional dependency)
    if AI_AVAILABLE:
        try:
            from productivity_ai import (
                ProductivityAnalyzer as _ProductivityAnalyzer,
                GamificationEngine as _GamificationEngine,
                FocusGoals as _FocusGoals
            )
            ProductivityAnalyzer = _ProductivityAnalyzer
            GamificationEngine = _GamificationEngine
            FocusGoals = _FocusGoals
        except Exception:
            pass
    
    # Gamification imports
    try:
        from gamification import (
            RARITY_POWER as _RARITY_POWER,
            ITEM_THEMES as _ITEM_THEMES,
            get_item_themes as _get_item_themes,
            get_diary_power_tier as _get_diary_power_tier,
            calculate_character_power as _calculate_character_power,
            # XP and leveling system
            calculate_session_xp as _calculate_session_xp,
            award_xp as _award_xp,
            get_level_from_xp as _get_level_from_xp,
            get_level_title as _get_level_title,
            get_celebration_message as _get_celebration_message,
            get_power_breakdown as _get_power_breakdown,
            calculate_rarity_bonuses as _calculate_rarity_bonuses,
            calculate_merge_success_rate as _calculate_merge_success_rate,
            get_merge_result_rarity as _get_merge_result_rarity,
            perform_lucky_merge as _perform_lucky_merge,
            is_merge_worthwhile as _is_merge_worthwhile,
            generate_diary_entry as _generate_diary_entry,
            calculate_set_bonuses as _calculate_set_bonuses,
            generate_item as _generate_item,
            generate_daily_reward_item as _generate_daily_reward_item,
            get_current_tier as _get_current_tier,
            get_boosted_rarity as _get_boosted_rarity,
            get_work_day_date as _get_work_day_date,
            AVAILABLE_STORIES as _AVAILABLE_STORIES,
            STORY_MODE_ACTIVE as _STORY_MODE_ACTIVE,
            STORY_MODE_HERO_ONLY as _STORY_MODE_HERO_ONLY,
            STORY_MODE_DISABLED as _STORY_MODE_DISABLED,
            set_story_mode as _set_story_mode,
            get_story_mode as _get_story_mode,
            switch_story as _switch_story,
            ensure_hero_structure as _ensure_hero_structure,
            sync_hero_data as _sync_hero_data,
            is_gamification_enabled as _is_gamification_enabled,
            # Story gear theme helpers
            GEAR_SLOTS as _GEAR_SLOTS,
            STORY_GEAR_THEMES as _STORY_GEAR_THEMES,
            get_story_gear_theme as _get_story_gear_theme,
            get_slot_display_name as _get_slot_display_name,
            get_selected_story as _get_selected_story,
            # Gear optimization
            optimize_equipped_gear as _optimize_equipped_gear,
            find_potential_set_bonuses as _find_potential_set_bonuses,
            # Lucky options system
            calculate_total_lucky_bonuses as _calculate_total_lucky_bonuses,
            format_lucky_options as _format_lucky_options,
            # Entity power perks for hero display
            get_entity_power_perks as _get_entity_power_perks,
        )
        GAMIFICATION_AVAILABLE = True
        RARITY_POWER = _RARITY_POWER
        ITEM_THEMES = _ITEM_THEMES
        get_item_themes = _get_item_themes
        get_diary_power_tier = _get_diary_power_tier
        calculate_character_power = _calculate_character_power
        # XP and leveling system
        calculate_session_xp = _calculate_session_xp
        award_xp = _award_xp
        get_level_from_xp = _get_level_from_xp
        get_level_title = _get_level_title
        get_celebration_message = _get_celebration_message
        get_power_breakdown = _get_power_breakdown
        calculate_rarity_bonuses = _calculate_rarity_bonuses
        calculate_merge_success_rate = _calculate_merge_success_rate
        get_merge_result_rarity = _get_merge_result_rarity
        perform_lucky_merge = _perform_lucky_merge
        is_merge_worthwhile = _is_merge_worthwhile
        generate_diary_entry = _generate_diary_entry
        calculate_set_bonuses = _calculate_set_bonuses
        generate_item = _generate_item
        generate_daily_reward_item = _generate_daily_reward_item
        get_current_tier = _get_current_tier
        get_boosted_rarity = _get_boosted_rarity
        get_work_day_date = _get_work_day_date
        AVAILABLE_STORIES = _AVAILABLE_STORIES
        STORY_MODE_ACTIVE = _STORY_MODE_ACTIVE
        STORY_MODE_HERO_ONLY = _STORY_MODE_HERO_ONLY
        STORY_MODE_DISABLED = _STORY_MODE_DISABLED
        set_story_mode = _set_story_mode
        get_story_mode = _get_story_mode
        switch_story = _switch_story
        ensure_hero_structure = _ensure_hero_structure
        sync_hero_data = _sync_hero_data
        is_gamification_enabled = _is_gamification_enabled
        # Story gear theme helpers
        GEAR_SLOTS = _GEAR_SLOTS
        STORY_GEAR_THEMES = _STORY_GEAR_THEMES
        get_story_gear_theme = _get_story_gear_theme
        get_slot_display_name = _get_slot_display_name
        get_selected_story = _get_selected_story
        # Gear optimization
        optimize_equipped_gear = _optimize_equipped_gear
        find_potential_set_bonuses = _find_potential_set_bonuses
        # Lucky options system
        calculate_total_lucky_bonuses = _calculate_total_lucky_bonuses
        format_lucky_options = _format_lucky_options
        # Entity power perks for hero display
        get_entity_power_perks = _get_entity_power_perks
    except ImportError:
        GAMIFICATION_AVAILABLE = False
    
    # Weight tracking functions (separate try for backward compat)
    try:
        from gamification import (
            check_weight_entry_rewards as _check_weight_entry_rewards,
            get_weight_stats as _get_weight_stats,
            format_weight_change as _format_weight_change,
            check_all_weight_rewards as _check_all_weight_rewards,
            calculate_bmi as _calculate_bmi,
            get_bmi_classification as _get_bmi_classification,
            get_ideal_weight_range as _get_ideal_weight_range,
            predict_goal_date as _predict_goal_date,
            get_historical_comparisons as _get_historical_comparisons,
            get_weekly_insights as _get_weekly_insights,
            WEIGHT_ENTRY_TAGS as _WEIGHT_ENTRY_TAGS,
            format_entry_note as _format_entry_note,
        )
        check_weight_entry_rewards = _check_weight_entry_rewards
        get_weight_stats = _get_weight_stats
        format_weight_change = _format_weight_change
        check_all_weight_rewards = _check_all_weight_rewards
        calculate_bmi = _calculate_bmi
        get_bmi_classification = _get_bmi_classification
        get_ideal_weight_range = _get_ideal_weight_range
        predict_goal_date = _predict_goal_date
        get_historical_comparisons = _get_historical_comparisons
        get_weekly_insights = _get_weekly_insights
        WEIGHT_ENTRY_TAGS = _WEIGHT_ENTRY_TAGS
        format_entry_note = _format_entry_note
    except ImportError:
        pass
    
    # Activity tracking functions
    try:
        from gamification import (
            ACTIVITY_TYPES as _ACTIVITY_TYPES,
            INTENSITY_LEVELS as _INTENSITY_LEVELS,
            ACTIVITY_MIN_DURATION as _ACTIVITY_MIN_DURATION,
            check_all_activity_rewards as _check_all_activity_rewards,
            get_activity_stats as _get_activity_stats,
            format_activity_duration as _format_activity_duration,
            check_activity_streak as _check_activity_streak,
        )
        ACTIVITY_TYPES = _ACTIVITY_TYPES
        INTENSITY_LEVELS = _INTENSITY_LEVELS
        ACTIVITY_MIN_DURATION = _ACTIVITY_MIN_DURATION
        check_all_activity_rewards = _check_all_activity_rewards
        get_activity_stats = _get_activity_stats
        format_activity_duration = _format_activity_duration
        check_activity_streak = _check_activity_streak
    except ImportError:
        pass
    
    # Sleep tracking functions
    try:
        from gamification import (
            SLEEP_CHRONOTYPES as _SLEEP_CHRONOTYPES,
            SLEEP_QUALITY_FACTORS as _SLEEP_QUALITY_FACTORS,
            SLEEP_DISRUPTION_TAGS as _SLEEP_DISRUPTION_TAGS,
            check_all_sleep_rewards as _check_all_sleep_rewards,
            get_sleep_stats as _get_sleep_stats,
            format_sleep_duration as _format_sleep_duration,
            check_sleep_streak as _check_sleep_streak,
            get_sleep_recommendation as _get_sleep_recommendation,
            get_screen_off_bonus_rarity as _get_screen_off_bonus_rarity,
        )
        SLEEP_CHRONOTYPES = _SLEEP_CHRONOTYPES
        SLEEP_QUALITY_FACTORS = _SLEEP_QUALITY_FACTORS
        SLEEP_DISRUPTION_TAGS = _SLEEP_DISRUPTION_TAGS
        check_all_sleep_rewards = _check_all_sleep_rewards
        get_sleep_stats = _get_sleep_stats
        format_sleep_duration = _format_sleep_duration
        check_sleep_streak = _check_sleep_streak
        get_sleep_recommendation = _get_sleep_recommendation
        get_screen_off_bonus_rarity = _get_screen_off_bonus_rarity
    except ImportError:
        pass
    
    # Hydration tracking functions
    try:
        from gamification import (
            get_water_reward_rarity as _get_water_reward_rarity,
            can_log_water as _can_log_water,
            get_hydration_streak_bonus_rarity as _get_hydration_streak_bonus_rarity,
            check_water_entry_reward as _check_water_entry_reward,
            get_hydration_stats as _get_hydration_stats,
            HYDRATION_MIN_INTERVAL_HOURS as _HYDRATION_MIN_INTERVAL_HOURS,
            HYDRATION_MAX_DAILY_GLASSES as _HYDRATION_MAX_DAILY_GLASSES,
        )
        get_water_reward_rarity = _get_water_reward_rarity
        can_log_water = _can_log_water
        get_hydration_streak_bonus_rarity = _get_hydration_streak_bonus_rarity
        check_water_entry_reward = _check_water_entry_reward
        get_hydration_stats = _get_hydration_stats
        HYDRATION_MIN_INTERVAL_HOURS = _HYDRATION_MIN_INTERVAL_HOURS
        HYDRATION_MAX_DAILY_GLASSES = _HYDRATION_MAX_DAILY_GLASSES
    except ImportError:
        pass


# Single instance mutex name
MUTEX_NAME = "PersonalLiberty_SingleInstance_Mutex"

# Lock file path for additional single-instance protection
def _get_lock_file_path() -> Path:
    """Get the path to the lock file for single-instance checking."""
    # Use temp directory for lock file (accessible across sessions)
    import tempfile
    return Path(tempfile.gettempdir()) / "PersonalLiberty.lock"


class HardcoreChallengeDialog(StyledDialog):
    """
    Math challenge dialog for Hardcore mode.
    Requires solving two long number arithmetic problems to stop the session.
    Numbers are rendered as non-selectable images to prevent copy-paste.
    """

    def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
        # Generate two different math problems
        self.problems = self._generate_problems()
        self.current_problem = 0
        self.solved_count = 0
        self._ready_to_finish = False
        
        super().__init__(
            parent=parent,
            title="HARDCORE MODE ACTIVE",
            header_icon="üí™",
            min_width=550,
            max_width=650,
            closable=False,
        )
    
    def _generate_problems(self) -> list:
        """Generate two challenging math problems with large numbers."""
        problems = []
        operations = ['+', '-', '√ó']
        
        for _ in range(2):
            op = random.choice(operations)
            
            if op == '+':
                # Addition: two 5-digit numbers
                a = random.randint(10000, 99999)
                b = random.randint(10000, 99999)
                answer = a + b
            elif op == '-':
                # Subtraction: ensure positive result
                a = random.randint(50000, 99999)
                b = random.randint(10000, a - 1)
                answer = a - b
            else:  # √ó
                # Multiplication: 4-digit √ó 2-digit
                a = random.randint(1000, 9999)
                b = random.randint(10, 99)
                answer = a * b
            
            problems.append({
                'a': a,
                'b': b,
                'op': op,
                'answer': answer
            })
        
        return problems
    
    def _build_content(self, layout: QtWidgets.QVBoxLayout) -> None:
        # Instructions
        instructions = QtWidgets.QLabel(
            "To stop this session, you must solve 2 math problems.\n"
            "Type your answers manually - no shortcuts allowed!"
        )
        instructions.setStyleSheet("font-size: 12px; color: #888888;")
        instructions.setAlignment(QtCore.Qt.AlignCenter)
        layout.addWidget(instructions)
        
        # Progress indicator
        self.progress_label = QtWidgets.QLabel()
        self.progress_label.setStyleSheet("font-size: 14px; font-weight: bold; color: #FFD700;")
        self.progress_label.setAlignment(QtCore.Qt.AlignCenter)
        layout.addWidget(self.progress_label)
        
        # Problem display area
        self.problem_frame = QtWidgets.QFrame()
        self.problem_frame.setStyleSheet("""
            QFrame {
                background-color: #0D0D1A;
                border: 2px solid #444466;
                border-radius: 10px;
                padding: 20px;
            }
        """)
        problem_layout = QtWidgets.QVBoxLayout(self.problem_frame)
        
        # The math expression - rendered as an image
        self.problem_display = QtWidgets.QLabel()
        self.problem_display.setAlignment(QtCore.Qt.AlignCenter)
        self.problem_display.setMinimumHeight(80)
        problem_layout.addWidget(self.problem_display)
        
        layout.addWidget(self.problem_frame)
        
        # Answer input
        input_layout = QtWidgets.QHBoxLayout()
        input_label = QtWidgets.QLabel("Your Answer:")
        input_label.setStyleSheet("color: #E0E0E0;")
        input_layout.addWidget(input_label)
        self.answer_input = QtWidgets.QLineEdit()
        self.answer_input.setPlaceholderText("Type the result here...")
        # Only allow numbers and minus sign
        self.answer_input.setValidator(QtGui.QIntValidator())
        self.answer_input.returnPressed.connect(self._check_answer)
        input_layout.addWidget(self.answer_input)
        layout.addLayout(input_layout)
        
        # Feedback label
        self.feedback_label = QtWidgets.QLabel("")
        self.feedback_label.setAlignment(QtCore.Qt.AlignCenter)
        self.feedback_label.setStyleSheet("font-size: 14px; min-height: 30px; color: #E0E0E0;")
        layout.addWidget(self.feedback_label)
        
        # Buttons
        btn_layout = QtWidgets.QHBoxLayout()
        
        self.cancel_btn = QtWidgets.QPushButton("Keep Focusing")
        self.cancel_btn.clicked.connect(self.reject)
        
        self.submit_btn = QtWidgets.QPushButton("Submit Answer")
        self.submit_btn.setObjectName("primaryButton")
        self.submit_btn.clicked.connect(self._check_answer)
        
        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addStretch()
        btn_layout.addWidget(self.submit_btn)
        layout.addLayout(btn_layout)
        
        # Show first problem
        self._show_current_problem()
    
    def _render_problem_as_image(self, a: int, b: int, op: str) -> QtGui.QPixmap:
        """Render the math problem as a pixmap to prevent text selection/copying."""
        # Format the expression first to calculate required width
        expression = f"{a:,}  {op}  {b:,}  =  ?"
        
        # Use a monospace font for clear number display
        font = QtGui.QFont("Consolas", 24, QtGui.QFont.Bold)
        
        # Calculate text width using font metrics
        metrics = QtGui.QFontMetrics(font)
        text_width = metrics.horizontalAdvance(expression)
        text_height = metrics.height()
        
        # Add padding for comfortable display
        width = text_width + 60
        height = text_height + 30
        
        # Ensure minimum dimensions
        width = max(width, 480)
        height = max(height, 60)
        
        pixmap = QtGui.QPixmap(width, height)
        pixmap.fill(QtCore.Qt.transparent)
        
        painter = QtGui.QPainter(pixmap)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        painter.setFont(font)
        painter.setPen(QtGui.QColor("#00ff88"))
        
        # Draw centered
        rect = QtCore.QRect(0, 0, width, height)
        painter.drawText(rect, QtCore.Qt.AlignCenter, expression)
        
        painter.end()
        return pixmap
    
    def _show_current_problem(self) -> None:
        """Display the current math problem."""
        problem = self.problems[self.current_problem]
        
        # Update progress
        self.progress_label.setText(f"Problem {self.current_problem + 1} of 2")
        
        # Render the problem as an image
        pixmap = self._render_problem_as_image(
            problem['a'], problem['b'], problem['op']
        )
        self.problem_display.setPixmap(pixmap)
        
        # Clear previous input and feedback
        self.answer_input.clear()
        self.feedback_label.setText("")
        self.answer_input.setFocus()
    
    def _check_answer(self) -> None:
        """Verify the user's answer."""
        try:
            user_answer = int(self.answer_input.text().strip())
        except ValueError:
            self.feedback_label.setText("‚ùå Please enter a valid number!")
            self.feedback_label.setStyleSheet("font-size: 14px; color: #FF6B6B; min-height: 30px;")
            return
        
        correct_answer = self.problems[self.current_problem]['answer']
        
        if user_answer == correct_answer:
            self.solved_count += 1
            self.current_problem += 1
            
            if self.solved_count >= 2:
                # All problems solved! Require explicit confirmation to close.
                self.feedback_label.setText("‚úÖ Correct! Click 'End Session' to finish.")
                self.feedback_label.setStyleSheet("font-size: 14px; color: #4CAF50; min-height: 30px;")
                self.answer_input.setEnabled(False)
                self.submit_btn.setText("End Session")
                if not self._ready_to_finish:
                    try:
                        self.submit_btn.clicked.disconnect(self._check_answer)
                    except TypeError:
                        pass
                    self.submit_btn.clicked.connect(self.accept)
                    self._ready_to_finish = True
            else:
                # Show next problem
                self.feedback_label.setText("‚úÖ Correct! One more to go...")
                self.feedback_label.setStyleSheet("font-size: 14px; color: #4CAF50; min-height: 30px;")
                QtCore.QTimer.singleShot(800, self._show_current_problem)
        else:
            # Wrong answer - generate new problems and restart
            self.feedback_label.setText("‚ùå Wrong! Starting over with new problems...")
            self.feedback_label.setStyleSheet("font-size: 14px; color: #FF6B6B; min-height: 30px;")
            
            # Reset with new problems after a delay
            QtCore.QTimer.singleShot(1500, self._reset_challenge)
    
    def _reset_challenge(self) -> None:
        """Reset the challenge with new problems."""
        self.problems = self._generate_problems()
        self.current_problem = 0
        self.solved_count = 0
        self._show_current_problem()
    
    def keyPressEvent(self, event: QtGui.QKeyEvent) -> None:
        """Prevent Escape from closing the dialog easily."""
        if event.key() == QtCore.Qt.Key_Escape:
            # Ignore escape - user must click "Keep Focusing" or solve problems
            return
        super().keyPressEvent(event)


# ============================================================================
# Enforcement Mode Selection Dialog - Shown on first run or from Settings
# ============================================================================

class EnforcementModeDialog(StyledDialog):
    """
    Dialog for selecting enforcement mode (Full vs Light).
    
    Shown on first run if not set by installer, or when user wants to change mode.
    Provides clear explanations of each mode's tradeoffs.
    """

    def __init__(self, blocker: 'BlockerCore', parent: Optional[QtWidgets.QWidget] = None,
                 is_first_run: bool = False) -> None:
        self.blocker = blocker
        self.is_first_run = is_first_run
        self._selected_mode = blocker.enforcement_mode if hasattr(blocker, 'enforcement_mode') else EnforcementMode.FULL
        
        title = "Choose Blocking Mode" if is_first_run else "Change Blocking Mode"
        
        super().__init__(
            parent=parent,
            title=title,
            header_icon="üõ°Ô∏è",
            min_width=480,
            max_width=550,
        )

    def _build_content(self, layout: QtWidgets.QVBoxLayout) -> None:
        # Introduction
        if self.is_first_run:
            intro_text = (
                "Welcome to Personal Liberty! üéâ\n\n"
                "Choose how you want the app to block distracting websites. "
                "This affects how effectively sites are blocked during focus sessions.\n\n"
                "You can change this anytime in Settings ‚Üí Enforcement Mode."
            )
        else:
            intro_text = (
                "Choose how the app should enforce focus sessions.\n"
                "Changes take effect immediately for new sessions."
            )
        
        intro = QtWidgets.QLabel(intro_text)
        intro.setWordWrap(True)
        intro.setStyleSheet("color: #E0E0E0; line-height: 1.4; margin-bottom: 10px;")
        layout.addWidget(intro)
        
        # Mode selection group
        mode_group = QtWidgets.QGroupBox()
        mode_group.setStyleSheet("""
            QGroupBox {
                border: none;
                padding: 0;
                margin: 0;
            }
        """)
        mode_layout = QtWidgets.QVBoxLayout(mode_group)
        mode_layout.setContentsMargins(0, 0, 0, 0)
        mode_layout.setSpacing(15)
        
        # Full Mode option
        self.full_radio = QtWidgets.QRadioButton("üîí Full Mode (Recommended)")
        self.full_radio.setStyleSheet("font-weight: bold; font-size: 13px;")
        mode_layout.addWidget(self.full_radio)
        
        full_desc = QtWidgets.QLabel(
            "‚Ä¢ Blocks sites at the system level ‚Äî <b>impossible to bypass</b>\n"
            "‚Ä¢ Requires running as Administrator\n"
            "‚Ä¢ Best for serious focus sessions and building discipline\n"
            "‚Ä¢ Modifies Windows hosts file (automatically cleaned on uninstall)"
        )
        full_desc.setWordWrap(True)
        full_desc.setStyleSheet("color: #9ca3af; margin-left: 24px; line-height: 1.3;")
        full_desc.setTextFormat(QtCore.Qt.RichText)
        mode_layout.addWidget(full_desc)
        
        # Separator
        mode_layout.addSpacing(5)
        
        # Light Mode option
        self.light_radio = QtWidgets.QRadioButton("üîî Light Mode (No Admin Required)")
        self.light_radio.setStyleSheet("font-weight: bold; font-size: 13px;")
        mode_layout.addWidget(self.light_radio)
        
        light_desc = QtWidgets.QLabel(
            "‚Ä¢ Shows reminder notifications when visiting blocked sites\n"
            "‚Ä¢ <b>No administrator privileges needed</b>\n"
            "‚Ä¢ Good for building awareness and habits\n"
            "‚Ä¢ Does NOT modify any system files ‚Äî completely portable"
        )
        light_desc.setWordWrap(True)
        light_desc.setStyleSheet("color: #9ca3af; margin-left: 24px; line-height: 1.3;")
        light_desc.setTextFormat(QtCore.Qt.RichText)
        mode_layout.addWidget(light_desc)
        
        layout.addWidget(mode_group)
        
        # Admin status indicator
        layout.addSpacing(10)
        
        is_admin = self._check_admin_status()
        if is_admin:
            admin_label = QtWidgets.QLabel("‚úÖ Currently running as Administrator")
            admin_label.setStyleSheet("color: #10B981; font-size: 11px;")
        else:
            admin_label = QtWidgets.QLabel(
                "‚ö†Ô∏è Not running as Administrator ‚Äî Full Mode requires admin privileges.\n"
                "    Restart with 'Run as administrator' or use Light Mode."
            )
            admin_label.setStyleSheet("color: #F59E0B; font-size: 11px;")
        admin_label.setWordWrap(True)
        layout.addWidget(admin_label)
        
        # Set initial selection
        current_mode = getattr(self.blocker, 'enforcement_mode', EnforcementMode.FULL)
        if current_mode == EnforcementMode.LIGHT:
            self.light_radio.setChecked(True)
        else:
            self.full_radio.setChecked(True)
        
        layout.addSpacing(15)
        
        # Buttons
        btn_text = "Continue" if self.is_first_run else "Save"
        self.add_button_row(layout, [
            ("Cancel", "default", self.reject),
            (btn_text, "primary", self._save_and_accept),
        ])

    def _check_admin_status(self) -> bool:
        """Check if running with admin privileges."""
        try:
            import ctypes
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        except Exception:
            return False

    def _save_and_accept(self) -> None:
        """Save the selected mode and accept the dialog."""
        if self.light_radio.isChecked():
            self._selected_mode = EnforcementMode.LIGHT
        else:
            self._selected_mode = EnforcementMode.FULL
        
        self.blocker.enforcement_mode = self._selected_mode
        self.blocker.save_config()
        self.accept()

    def get_selected_mode(self) -> str:
        """Return the selected enforcement mode."""
        return self._selected_mode


class UserProfileDialog(StyledDialog):
    """
    Dialog for collecting user profile (birth date and gender).
    
    Shown on first run to collect age and sex for personalized health norms:
    - BMI: Age/sex-specific thresholds (CDC percentiles for 7-19, WHO for adults)
    - Sleep: Age-specific duration targets (AASM/NSF guidelines)
    """

    def __init__(self, blocker: 'BlockerCore', parent: Optional[QtWidgets.QWidget] = None,
                 is_first_run: bool = False) -> None:
        self.blocker = blocker
        self.is_first_run = is_first_run
        
        title = "Your Profile" if not is_first_run else "About You"
        
        super().__init__(
            parent=parent,
            title=title,
            header_icon="üë§",
            min_width=420,
            max_width=500,
        )

    def _build_content(self, layout: QtWidgets.QVBoxLayout) -> None:
        # Introduction
        if self.is_first_run:
            intro_text = (
                "To personalize your health targets, please share a few details.\n\n"
                "This helps us use age and sex-specific guidelines for:\n"
                "‚Ä¢ BMI classification (CDC charts for youth, WHO for adults)\n"
                "‚Ä¢ Sleep duration targets (AASM/NSF recommendations)\n\n"
                "Your data stays on your device and is never shared."
            )
        else:
            intro_text = (
                "Update your profile for personalized health targets.\n"
                "This affects BMI classification and sleep duration goals."
            )
        
        intro = QtWidgets.QLabel(intro_text)
        intro.setWordWrap(True)
        intro.setStyleSheet("color: #E0E0E0; line-height: 1.4; margin-bottom: 10px;")
        layout.addWidget(intro)
        
        # Profile form
        form_group = QtWidgets.QGroupBox("üìã Profile Information")
        form_layout = QtWidgets.QFormLayout(form_group)
        form_layout.setSpacing(12)
        
        # Birth Year
        self.birth_year_input = NoScrollSpinBox()
        self.birth_year_input.setRange(1920, QtCore.QDate.currentDate().year())
        self.birth_year_input.setValue(self.blocker.user_birth_year or 1990)
        self.birth_year_input.setFixedWidth(100)
        self.birth_year_input.valueChanged.connect(self._update_age_display)
        form_layout.addRow("Birth Year:", self.birth_year_input)
        
        # Birth Month
        self.birth_month_combo = NoScrollComboBox()
        months = ["January", "February", "March", "April", "May", "June",
                  "July", "August", "September", "October", "November", "December"]
        for i, m in enumerate(months, 1):
            self.birth_month_combo.addItem(m, i)
        if self.blocker.user_birth_month:
            idx = self.birth_month_combo.findData(self.blocker.user_birth_month)
            if idx >= 0:
                self.birth_month_combo.setCurrentIndex(idx)
        self.birth_month_combo.currentIndexChanged.connect(self._update_age_display)
        form_layout.addRow("Birth Month:", self.birth_month_combo)
        
        # Calculated Age display
        self.age_display = QtWidgets.QLabel("")
        self.age_display.setStyleSheet("color: #4caf50; font-weight: bold;")
        form_layout.addRow("Your Age:", self.age_display)
        
        # Gender
        self.gender_combo = NoScrollComboBox()
        self.gender_combo.addItem("Male", "M")
        self.gender_combo.addItem("Female", "F")
        if self.blocker.user_gender:
            idx = self.gender_combo.findData(self.blocker.user_gender)
            if idx >= 0:
                self.gender_combo.setCurrentIndex(idx)
        form_layout.addRow("Gender:", self.gender_combo)
        
        layout.addWidget(form_group)
        
        # Update age display
        self._update_age_display()
        
        # Info about what this affects
        layout.addSpacing(10)
        info_label = QtWidgets.QLabel(
            "‚ÑπÔ∏è <b>Why this matters:</b><br>"
            "‚Ä¢ Children/teens (7-19): BMI uses CDC growth percentiles<br>"
            "‚Ä¢ Adults (20+): BMI uses WHO standard thresholds<br>"
            "‚Ä¢ Sleep targets vary by age (e.g., teens need 8-10h, adults 7-9h)"
        )
        info_label.setTextFormat(QtCore.Qt.RichText)
        info_label.setWordWrap(True)
        info_label.setStyleSheet("color: #888888; font-size: 11px;")
        layout.addWidget(info_label)
        
        layout.addSpacing(15)
        
        # Buttons
        btn_text = "Continue" if self.is_first_run else "Save"
        self.add_button_row(layout, [
            ("Skip" if self.is_first_run else "Cancel", "default", self.reject),
            (btn_text, "primary", self._save_and_accept),
        ])

    def _update_age_display(self) -> None:
        """Update the calculated age label."""
        try:
            from gamification import calculate_age_from_birth
            age = calculate_age_from_birth(
                self.birth_year_input.value(),
                self.birth_month_combo.currentData()
            )
            if age is not None:
                self.age_display.setText(f"{age} years old")
            else:
                self.age_display.setText("--")
        except (ImportError, Exception):
            self.age_display.setText("--")

    def _save_and_accept(self) -> None:
        """Save the profile and accept the dialog."""
        self.blocker.user_birth_year = self.birth_year_input.value()
        self.blocker.user_birth_month = self.birth_month_combo.currentData()
        self.blocker.user_gender = self.gender_combo.currentData()
        self.blocker.save_config()
        self.accept()


class OnboardingModeDialog(StyledDialog):
    """Prompt the user to pick how they want to play on startup."""

    def __init__(self, blocker: BlockerCore, parent: Optional[QtWidgets.QWidget] = None) -> None:
        self.blocker = blocker
        ensure_hero_structure(self.blocker.adhd_buster)
        self._dont_ask = False
        
        super().__init__(
            parent=parent,
            title="Choose Gamification Mode",
            header_icon="üéÆ",
            min_width=420,
            max_width=520,
        )
        
        # Set initial selection after UI is built
        current_mode = get_story_mode(self.blocker.adhd_buster)
        active_story = self.blocker.adhd_buster.get("active_story", "warrior")
        
        if current_mode == STORY_MODE_HERO_ONLY:
            self.hero_only_radio.setChecked(True)
        elif current_mode == STORY_MODE_DISABLED:
            self.disabled_radio.setChecked(True)
        else:
            self.story_radio.setChecked(True)

        idx = self.story_combo.findData(active_story)
        if idx >= 0:
            self.story_combo.setCurrentIndex(idx)
        
        self._on_mode_changed()

    def _build_content(self, layout: QtWidgets.QVBoxLayout) -> None:
        info = QtWidgets.QLabel(
            "How would you like to play today?\n\n"
            "‚Ä¢ Story: each story has its own hero, gear, and decisions.\n"
            "‚Ä¢ Hero only: level up a free hero, no story.\n"
            "‚Ä¢ Disabled: no gamification for this session."
        )
        info.setWordWrap(True)
        info.setStyleSheet("color: #E0E0E0; line-height: 1.4;")
        layout.addWidget(info)

        self.story_radio = QtWidgets.QRadioButton("üìñ Story mode")
        self.hero_only_radio = QtWidgets.QRadioButton("‚öîÔ∏è Hero only (no story)")
        self.disabled_radio = QtWidgets.QRadioButton("‚ùå Disabled")

        mode_group = QtWidgets.QButtonGroup(self)
        for btn in (self.story_radio, self.hero_only_radio, self.disabled_radio):
            mode_group.addButton(btn)
            layout.addWidget(btn)

        self.story_combo = NoScrollComboBox()
        if AVAILABLE_STORIES:
            for story_id, info_data in AVAILABLE_STORIES.items():
                self.story_combo.addItem(info_data.get("title", story_id), story_id)
        else:
            self.story_combo.addItem("The Focus Warrior", "warrior")
        layout.addWidget(self.story_combo)

        self.story_radio.toggled.connect(self._on_mode_changed)
        self.hero_only_radio.toggled.connect(self._on_mode_changed)
        self.disabled_radio.toggled.connect(self._on_mode_changed)

        # Don't ask again checkbox
        self.dont_ask_checkbox = QtWidgets.QCheckBox("Don't ask again on startup")
        self.dont_ask_checkbox.setToolTip(
            "You can always change your mode from the ADHD Buster dialog (Story Settings)"
        )
        self.dont_ask_checkbox.setStyleSheet("color: #888888; font-size: 11px; margin-top: 10px;")
        layout.addWidget(self.dont_ask_checkbox)

        layout.addSpacing(10)
        
        # Buttons
        self.add_button_row(layout, [
            ("Cancel", "default", self.reject),
            ("Start", "primary", self.accept),
        ])

        current_mode = get_story_mode(self.blocker.adhd_buster)
    def _on_mode_changed(self) -> None:
        self.story_combo.setEnabled(self.story_radio.isChecked())

    def get_selection(self) -> tuple:
        if self.disabled_radio.isChecked():
            return STORY_MODE_DISABLED, None
        if self.hero_only_radio.isChecked():
            return STORY_MODE_HERO_ONLY, None
        story_id = self.story_combo.currentData()
        return STORY_MODE_ACTIVE, story_id

    def should_skip_next_time(self) -> bool:
        """Return True if user checked 'Don't ask again'."""
        return self.dont_ask_checkbox.isChecked()


class LogPastSessionDialog(StyledDialog):
    """Dialog to log a focus session retroactively.
    
    Allows users to record focus time they forgot to track with the timer.
    Awards the same rewards as a normal timed session.
    """
    
    def __init__(self, blocker: 'BlockerCore', parent: Optional[QtWidgets.QWidget] = None):
        # Set blocker before super().__init__ because StyledDialog calls _build_content()
        self.blocker = blocker
        self.session_minutes = 0
        super().__init__(parent, title="üìù Log Past Session", min_width=420, max_width=500)
    
    def _build_content(self, layout: QtWidgets.QVBoxLayout) -> None:
        """Build the dialog content inside the styled frame."""
        # Info label
        info_label = QtWidgets.QLabel(
            "üïê <b>Forgot to start the timer?</b><br><br>"
            "Log your focus session here to record your productivity "
            "and earn rewards retroactively."
        )
        info_label.setTextFormat(QtCore.Qt.RichText)
        info_label.setWordWrap(True)
        layout.addWidget(info_label)
        
        # Duration input section
        duration_group = QtWidgets.QGroupBox("‚è±Ô∏è Session Duration")
        duration_layout = QtWidgets.QVBoxLayout(duration_group)
        
        # Time input row
        time_row = QtWidgets.QHBoxLayout()
        
        # Hours spinner
        self.hours_spin = QtWidgets.QSpinBox()
        self.hours_spin.setRange(0, 8)
        self.hours_spin.setSuffix(" hr")
        self.hours_spin.valueChanged.connect(self._update_preview)
        time_row.addWidget(self.hours_spin)
        
        # Minutes spinner
        self.minutes_spin = QtWidgets.QSpinBox()
        self.minutes_spin.setRange(0, 59)
        self.minutes_spin.setSuffix(" min")
        self.minutes_spin.setValue(25)  # Default 25 min
        self.minutes_spin.valueChanged.connect(self._update_preview)
        time_row.addWidget(self.minutes_spin)
        
        duration_layout.addLayout(time_row)
        
        # Quick preset buttons
        preset_row = QtWidgets.QHBoxLayout()
        presets = [("25m", 25), ("45m", 45), ("1h", 60), ("2h", 120)]
        for label, mins in presets:
            btn = QtWidgets.QPushButton(label)
            btn.clicked.connect(lambda checked, m=mins: self._set_duration(m))
            preset_row.addWidget(btn)
        duration_layout.addLayout(preset_row)
        
        layout.addWidget(duration_group)
        
        # Preview of rewards
        self.preview_label = QtWidgets.QLabel()
        self.preview_label.setTextFormat(QtCore.Qt.RichText)
        self.preview_label.setWordWrap(True)
        self.preview_label.setStyleSheet("""
            background: rgba(0, 184, 148, 0.15);
            border: 1px solid #00b894;
            border-radius: 8px;
            padding: 12px;
        """)
        layout.addWidget(self.preview_label)
        
        # Honesty note
        honesty_label = QtWidgets.QLabel(
            "üíö <i>Be honest with yourself - logging fake sessions defeats the purpose!</i>"
        )
        honesty_label.setTextFormat(QtCore.Qt.RichText)
        honesty_label.setStyleSheet("color: #888888; font-size: 11px;")
        honesty_label.setAlignment(QtCore.Qt.AlignCenter)
        layout.addWidget(honesty_label)
        
        # Buttons using the base class helper
        self.add_button_row(
            layout,
            [
                ("Cancel", "default", self.reject),
                ("‚úÖ Log Session", "primary", self._on_log),
            ]
        )
        
        # Store reference to log button for enabling/disabling
        # Find the primary button we just created
        for child in self.findChildren(QtWidgets.QPushButton):
            if child.text() == "‚úÖ Log Session":
                self.log_btn = child
                break
        
        # Initial preview update
        self._update_preview()
    
    def _set_duration(self, minutes: int) -> None:
        """Set duration from preset button."""
        hours = minutes // 60
        mins = minutes % 60
        self.hours_spin.setValue(hours)
        self.minutes_spin.setValue(mins)
    
    def _update_preview(self) -> None:
        """Update the rewards preview based on current duration."""
        total_minutes = self.hours_spin.value() * 60 + self.minutes_spin.value()
        
        if total_minutes == 0:
            self.preview_label.setText("‚ö†Ô∏è Enter a duration to see rewards preview")
            self.log_btn.setEnabled(False)
            return
        
        self.log_btn.setEnabled(True)
        
        # Calculate approximate rewards
        streak = self.blocker.stats.get("streak_days", 0)
        
        # XP calculation (simplified)
        base_xp = 25
        time_xp = total_minutes * 2
        streak_xp = streak * 5
        total_xp = base_xp + time_xp + streak_xp
        
        # Coins calculation (simplified)
        session_hours = total_minutes / 60.0
        coins = int(session_hours * 10)
        if streak >= 30:
            coins += 100
        elif streak >= 14:
            coins += 50
        elif streak >= 7:
            coins += 25
        elif streak >= 3:
            coins += 10
        
        # Rarity tier based on duration
        if total_minutes >= 240:
            rarity = "Legendary"
            rarity_color = "#ff9800"
        elif total_minutes >= 180:
            rarity = "Epic"
            rarity_color = "#9c27b0"
        elif total_minutes >= 120:
            rarity = "Rare"
            rarity_color = "#2196f3"
        elif total_minutes >= 60:
            rarity = "Uncommon"
            rarity_color = "#4caf50"
        else:
            rarity = "Common"
            rarity_color = "#78909c"
        
        # Check for city building contribution
        city_line = ""
        try:
            if CITY_AVAILABLE:
                from city import get_active_construction_info
                active = get_active_construction_info(self.blocker.adhd_buster)
                if active:
                    focus_earned = total_minutes // 30
                    building_name = active.get("building_name", "Building")
                    if focus_earned > 0:
                        city_line = f"<br>‚Ä¢ <b style='color:#9b59b6;'>üèóÔ∏è City:</b> +{focus_earned} Focus ‚Üí {building_name}"
                    else:
                        # Show how many more minutes needed
                        mins_needed = 30 - (total_minutes % 30)
                        city_line = f"<br>‚Ä¢ <b style='color:#888;'>üèóÔ∏è City:</b> {mins_needed} more min for +1 Focus ‚Üí {building_name}"
                elif total_minutes >= 30:
                    # No construction but would earn Focus
                    city_line = f"<br>‚Ä¢ <b style='color:#888;'>üèóÔ∏è City:</b> No construction active (start a build in City tab!)"
        except Exception:
            pass
        
        self.preview_label.setText(
            f"<b style='color:#00b894;'>üìä Rewards Preview:</b><br>"
            f"‚Ä¢ <b style='color:#ffd700;'>XP:</b> ~{total_xp}<br>"
            f"‚Ä¢ <b style='color:#f1c40f;'>Coins:</b> ~{coins}<br>"
            f"‚Ä¢ <b style='color:{rarity_color};'>Item:</b> 1x {rarity} gear (guaranteed)"
            f"{city_line}"
        )
    
    def _on_log(self) -> None:
        """Handle log button click."""
        total_minutes = self.hours_spin.value() * 60 + self.minutes_spin.value()
        if total_minutes > 0:
            self.session_minutes = total_minutes
            self.accept()
    
    def get_session_minutes(self) -> int:
        """Return the logged session duration in minutes."""
        return self.session_minutes


class TimerTab(QtWidgets.QWidget):
    """Qt implementation of the timer tab (start/stop, modes, presets, countdown)."""

    timer_tick = QtCore.Signal(int)  # remaining seconds
    session_complete = QtCore.Signal(int)  # elapsed seconds
    session_started = QtCore.Signal()  # emitted when a session starts

    def __init__(self, blocker: BlockerCore, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.blocker = blocker
        self.timer_running = False
        self.remaining_seconds = 0
        self.session_start: Optional[float] = None
        self._giving_rewards = False  # Re-entrancy guard for deferred rewards
        
        # Pomodoro state
        self.pomodoro_is_break = False
        self.pomodoro_session_count = 0
        self.pomodoro_total_work_time = 0
        
        # Priority check-in tracking
        self.last_checkin_time: Optional[float] = None
        
        # Track if session is on a strategic priority for 2.5x coin multiplier
        self.session_is_strategic: bool = False
        self.session_priority_title: Optional[str] = None
        self._is_starting_with_priority: bool = False  # Flag to skip priority dialog when already set
        self.session_total_seconds: int = 0  # Total session duration for progress calculation
        self.preset_buttons: List[QtWidgets.QPushButton] = []  # Store preset buttons for disabling

        self._build_ui()
        self._connect_signals()
        self._load_last_session_settings()

        # QTimer for ticking each second
        self.qt_timer = QtCore.QTimer(self)
        self.qt_timer.setInterval(1000)
        self.qt_timer.timeout.connect(self._on_tick)

    def _build_ui(self) -> None:
        # Main layout for this widget - just holds the scroll area
        outer_layout = QtWidgets.QVBoxLayout(self)
        outer_layout.setContentsMargins(0, 0, 0, 0)
        outer_layout.setSpacing(0)
        
        # Scroll area for the content
        scroll = QtWidgets.QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)
        scroll.setStyleSheet("QScrollArea { border: none; background: transparent; }")
        scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        
        # Content widget - expands horizontally but NOT vertically
        content = QtWidgets.QWidget()
        content.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Maximum)
        
        layout = QtWidgets.QVBoxLayout(content)
        layout.setSpacing(12)
        layout.setContentsMargins(16, 12, 16, 12)
        layout.setAlignment(QtCore.Qt.AlignTop)

        # === HERO SECTION: Timer Display + Action Button ===
        hero_card = QtWidgets.QFrame()
        hero_card.setStyleSheet("""
            QFrame {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 #2a2a3d, stop:1 #1a1a2e);
                border: 1px solid #5f27cd;
                border-radius: 12px;
            }
        """)
        hero_layout = QtWidgets.QVBoxLayout(hero_card)
        hero_layout.setContentsMargins(20, 16, 20, 16)
        hero_layout.setSpacing(12)
        
        # Timer display - large and prominent
        self.timer_label = QtWidgets.QLabel("00:00:00")
        self.timer_label.setAlignment(QtCore.Qt.AlignCenter)
        self.timer_label.setStyleSheet("""
            font: 700 52px 'Consolas', 'Courier New', monospace;
            color: #a29bfe;
            background: transparent;
            letter-spacing: 6px;
            padding: 8px 0;
        """)
        hero_layout.addWidget(self.timer_label)
        
        # Motivational message (changes contextually)
        self.motivation_label = QtWidgets.QLabel("Ready to focus? Set your duration and press Start!")
        self.motivation_label.setAlignment(QtCore.Qt.AlignCenter)
        self.motivation_label.setWordWrap(True)
        self.motivation_label.setStyleSheet("""
            color: #888;
            font-size: 11px;
            font-style: italic;
            padding: 0 20px;
        """)
        hero_layout.addWidget(self.motivation_label)
        
        # Session progress bar (hidden when not running)
        self.session_progress = QtWidgets.QProgressBar()
        self.session_progress.setMaximum(100)
        self.session_progress.setValue(0)
        self.session_progress.setTextVisible(False)
        self.session_progress.setFixedHeight(6)
        self.session_progress.setStyleSheet("""
            QProgressBar {
                border: none;
                border-radius: 3px;
                background: #333;
            }
            QProgressBar::chunk {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #6c5ce7, stop:0.5 #a29bfe, stop:1 #6c5ce7);
                border-radius: 3px;
            }
        """)
        self.session_progress.setVisible(False)
        hero_layout.addWidget(self.session_progress)
        
        # Session status label (shows during session)
        self.session_status = QtWidgets.QLabel("")
        self.session_status.setAlignment(QtCore.Qt.AlignCenter)
        self.session_status.setStyleSheet("color: #888; font-size: 11px;")
        self.session_status.setVisible(False)
        hero_layout.addWidget(self.session_status)
        
        # Action button row
        action_row = QtWidgets.QHBoxLayout()
        action_row.setSpacing(12)
        
        # Dynamic Start/Stop button
        self.action_btn = QtWidgets.QPushButton("‚ñ∂  Start Focus Session")
        self.action_btn.setMinimumHeight(52)
        self.action_btn.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self._set_action_btn_start_style()
        action_row.addWidget(self.action_btn)
        
        hero_layout.addLayout(action_row)
        hero_card.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Maximum)
        layout.addWidget(hero_card)

        # === QUICK STATS ROW ===
        stats_row = QtWidgets.QHBoxLayout()
        stats_row.setSpacing(10)
        
        def create_mini_stat(icon: str, label: str, value: str, color: str, bg_color: str = "#2a2a2a") -> tuple:
            """Create a compact stat widget (non-interactive)."""
            frame = QtWidgets.QFrame()
            frame.setAttribute(QtCore.Qt.WA_TransparentForMouseEvents, False)  # Keep mouse events but no visual feedback
            frame.setFocusPolicy(QtCore.Qt.NoFocus)
            frame.setStyleSheet(f"""
                QFrame {{
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                        stop:0 #333, stop:1 {bg_color});
                    border: 1px solid #3d3d3d;
                    border-radius: 10px;
                }}
            """)
            stat_layout = QtWidgets.QVBoxLayout(frame)
            stat_layout.setContentsMargins(12, 10, 12, 10)
            stat_layout.setSpacing(4)
            
            header = QtWidgets.QLabel(f"{icon} {label}")
            header.setStyleSheet("color: #999; font-size: 11px; font-weight: 500;")
            header.setAlignment(QtCore.Qt.AlignCenter)
            stat_layout.addWidget(header)
            
            value_lbl = QtWidgets.QLabel(value)
            value_lbl.setStyleSheet(f"color: {color}; font-size: 18px; font-weight: bold;")
            value_lbl.setAlignment(QtCore.Qt.AlignCenter)
            stat_layout.addWidget(value_lbl)
            
            return frame, value_lbl
        
        stat1, self.today_focus_lbl = create_mini_stat("üìä", "Today", "0m", "#74b9ff", "#1a2a3a")
        stat2, self.streak_display_lbl = create_mini_stat("üî•", "Streak", "0 days", "#ff9800", "#2a2010")
        stat3, self.sessions_today_lbl = create_mini_stat("‚úÖ", "Sessions", "0", "#4caf50", "#1a2a1a")
        
        # Prevent stat cards from expanding vertically
        for stat_frame in [stat1, stat2, stat3]:
            stat_frame.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Maximum)
        
        stats_row.addWidget(stat1)
        stats_row.addWidget(stat2)
        stats_row.addWidget(stat3)
        layout.addLayout(stats_row)

        # === SETTINGS CARD ===
        settings_card = QtWidgets.QFrame()
        settings_card.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Maximum)
        settings_card.setStyleSheet("""
            QFrame {
                background: #2a2a2a;
                border: 1px solid #3d3d3d;
                border-radius: 10px;
            }
        """)
        settings_layout = QtWidgets.QVBoxLayout(settings_card)
        settings_layout.setContentsMargins(14, 12, 14, 12)
        settings_layout.setSpacing(10)

        # Duration row with slider
        duration_section = QtWidgets.QHBoxLayout()
        duration_section.setSpacing(12)
        
        duration_label = QtWidgets.QLabel("‚è± Duration")
        duration_label.setStyleSheet("font-weight: 600; color: #74b9ff; font-size: 12px;")
        duration_section.addWidget(duration_label)
        
        self.duration_display = QtWidgets.QLabel("25 min")
        self.duration_display.setStyleSheet("""
            font-weight: bold; 
            color: #fff; 
            background: #5f27cd;
            border-radius: 4px;
            padding: 4px 10px;
            font-size: 12px;
        """)
        self.duration_display.setAlignment(QtCore.Qt.AlignCenter)
        self.duration_display.setMinimumWidth(70)
        duration_section.addWidget(self.duration_display)
        
        self.duration_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.duration_slider.setMinimum(5)
        self.duration_slider.setMaximum(240)
        self.duration_slider.setSingleStep(5)
        self.duration_slider.setPageStep(15)
        self.duration_slider.setValue(25)
        self.duration_slider.setMinimumHeight(28)
        self.duration_slider.valueChanged.connect(self._on_duration_changed)
        self.duration_slider.setStyleSheet("""
            QSlider::groove:horizontal {
                border: none;
                height: 10px;
                background: #3a3a3a;
                border-radius: 5px;
            }
            QSlider::handle:horizontal {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 #a29bfe, stop:1 #6c5ce7);
                border: 2px solid #5f27cd;
                width: 22px;
                margin: -7px 0;
                border-radius: 11px;
            }
            QSlider::handle:horizontal:hover {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 #c8c4ff, stop:1 #a29bfe);
                border: 2px solid #a29bfe;
            }
            QSlider::sub-page:horizontal {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #5f27cd, stop:1 #6c5ce7);
                border-radius: 5px;
            }
        """)
        duration_section.addWidget(self.duration_slider, 1)
        settings_layout.addLayout(duration_section)

        # Quick preset buttons
        preset_row = QtWidgets.QHBoxLayout()
        preset_row.setSpacing(4)
        
        preset_label = QtWidgets.QLabel("‚ö°")
        preset_label.setStyleSheet("color: #888; font-size: 12px;")
        preset_row.addWidget(preset_label)
        
        # Tier-colored presets matching reward rarity
        presets = [
            ("10m", 10, "#4caf50", "#388e3c"),    # Common green
            ("30m", 30, "#4caf50", "#388e3c"),    # Common green  
            ("1h", 60, "#2196f3", "#1976d2"),     # Uncommon blue
            ("1.5h", 90, "#9c27b0", "#7b1fa2"),   # Rare purple
            ("2h", 120, "#ff9800", "#f57c00"),    # Epic orange
            ("3h", 180, "#ff5722", "#e64a19"),    # Epic+ deep orange
            ("4h", 240, "#ffd700", "#ffc107"),    # Legendary gold
        ]
        for label, minutes, color, hover_color in presets:
            btn = QtWidgets.QPushButton(label)
            btn.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
            btn.setToolTip(f"{label} session - higher tier rewards!" if minutes >= 60 else f"{label} quick focus")
            btn.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
            btn.setStyleSheet(f"""
                QPushButton {{
                    background: #3a3a3a;
                    color: {color};
                    font-size: 11px;
                    font-weight: 700;
                    border-radius: 6px;
                    border: 2px solid #4a4a4a;
                    padding: 6px 4px;
                }}
                QPushButton:hover {{
                    background: {color};
                    border-color: {color};
                    color: white;
                }}
                QPushButton:pressed {{
                    background: {hover_color};
                }}
            """)
            btn.clicked.connect(lambda _=False, m=minutes: self._set_preset(m))
            preset_row.addWidget(btn)
            self.preset_buttons.append(btn)  # Store for disabling during session
        settings_layout.addLayout(preset_row)

        # Divider
        divider = QtWidgets.QFrame()
        divider.setFixedHeight(1)
        divider.setStyleSheet("background: #3d3d3d;")
        settings_layout.addWidget(divider)

        # Mode & Alert dropdowns row (side by side)
        dropdowns_row = QtWidgets.QHBoxLayout()
        dropdowns_row.setSpacing(16)
        
        dropdown_style = """
            QComboBox {
                background: #2a2a2a;
                color: #fff;
                border: 1px solid #444;
                border-radius: 6px;
                padding: 6px 12px;
                font-size: 12px;
                min-width: 130px;
            }
            QComboBox:hover {
                border: 1px solid #6c5ce7;
            }
            QComboBox::drop-down {
                border: none;
                width: 20px;
            }
            QComboBox::down-arrow {
                image: none;
                border-left: 4px solid transparent;
                border-right: 4px solid transparent;
                border-top: 6px solid #888;
                margin-right: 8px;
            }
            QComboBox QAbstractItemView {
                background: #2a2a2a;
                color: #fff;
                selection-background-color: #6c5ce7;
                border: 1px solid #444;
                border-radius: 4px;
            }
        """
        
        # Mode dropdown
        mode_label = QtWidgets.QLabel("üéÆ Mode")
        mode_label.setStyleSheet("font-weight: 600; color: #74b9ff; font-size: 12px;")
        dropdowns_row.addWidget(mode_label)
        
        self.mode_combo = QtWidgets.QComboBox()
        self.mode_combo.setStyleSheet(dropdown_style)
        self.mode_combo.setFocusPolicy(QtCore.Qt.StrongFocus)  # Require click to focus
        self.mode_combo.wheelEvent = lambda e: e.ignore()  # Disable scroll wheel
        self._mode_values = []  # Store mode values for lookup
        modes = [
            ("Normal", BlockMode.NORMAL, "Can stop session anytime"),
            ("Strict üîê", BlockMode.STRICT, "Requires password to stop"),
            ("Hardcore üíÄ", BlockMode.HARDCORE, "Solve math problems to stop"),
            ("Pomodoro üçÖ", BlockMode.POMODORO, "25 min work / 5 min break"),
        ]
        for text, value, tooltip in modes:
            self.mode_combo.addItem(text)
            self._mode_values.append(value)
        self.mode_combo.setToolTip("Select focus session mode")
        dropdowns_row.addWidget(self.mode_combo)
        
        dropdowns_row.addSpacing(12)
        
        # Alert dropdown
        notify_label = QtWidgets.QLabel("üîî Alert")
        notify_label.setStyleSheet("font-weight: 600; color: #00b894; font-size: 12px;")
        dropdowns_row.addWidget(notify_label)
        
        self.notify_combo = QtWidgets.QComboBox()
        self.notify_combo.setStyleSheet(dropdown_style.replace("#6c5ce7", "#00b894"))
        self.notify_combo.setFocusPolicy(QtCore.Qt.StrongFocus)  # Require click to focus
        self.notify_combo.wheelEvent = lambda e: e.ignore()  # Disable scroll wheel
        self._notify_values = []  # Store notify keys for lookup
        notify_options = [
            ("none", "None", "No notification when session ends"),
            ("dialog", "Dialog", "Show a completion dialog"),
            ("sound", "Sound", "Play a notification chime"),
            ("both", "Both", "Show dialog and play sound"),
        ]
        for key, text, tooltip in notify_options:
            self.notify_combo.addItem(text)
            self._notify_values.append(key)
        self.notify_combo.setToolTip("Select notification type when session ends")
        self.notify_combo.setCurrentIndex(3)  # Default to "Both"
        dropdowns_row.addWidget(self.notify_combo)
        
        dropdowns_row.addStretch()
        settings_layout.addLayout(dropdowns_row)
        layout.addWidget(settings_card)

        # Hidden status label (used by code but not shown to user)
        self.status_label = QtWidgets.QLabel()
        self.status_label.setVisible(False)

        # === REWARDS INFO (Collapsible) ===
        rewards_card = QtWidgets.QFrame()
        rewards_card.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Maximum)
        rewards_card.setStyleSheet("""
            QFrame {
                background: #252525;
                border: 1px solid #3d3d3d;
                border-radius: 8px;
            }
        """)
        rewards_layout = QtWidgets.QVBoxLayout(rewards_card)
        rewards_layout.setContentsMargins(12, 8, 12, 8)
        rewards_layout.setSpacing(6)
        
        # Rewards header with toggle
        rewards_header = QtWidgets.QHBoxLayout()
        rewards_title = QtWidgets.QLabel("üéÅ Rewards Guide")
        rewards_title.setStyleSheet("color: #ffeaa7; font-weight: 600; font-size: 11px;")
        rewards_header.addWidget(rewards_title)
        rewards_header.addStretch()
        
        self.rewards_toggle_btn = QtWidgets.QPushButton("‚ñº")
        self.rewards_toggle_btn.setFixedSize(24, 24)
        self.rewards_toggle_btn.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self.rewards_toggle_btn.setStyleSheet("""
            QPushButton {
                background: transparent;
                color: #888;
                border: none;
                font-size: 10px;
            }
            QPushButton:hover {
                color: #ffeaa7;
            }
        """)
        self.rewards_toggle_btn.clicked.connect(self._toggle_rewards_info)
        rewards_header.addWidget(self.rewards_toggle_btn)
        rewards_layout.addLayout(rewards_header)
        
        # Collapsible content
        self.rewards_content = QtWidgets.QWidget()
        rewards_content_layout = QtWidgets.QVBoxLayout(self.rewards_content)
        rewards_content_layout.setContentsMargins(0, 4, 0, 0)
        rewards_content_layout.setSpacing(4)
        
        rewards_info = QtWidgets.QLabel(
            "<span style='color:#b2bec3; font-size:10px;'>Complete focus sessions to earn gear. Longer = better rarity!</span>"
        )
        rewards_content_layout.addWidget(rewards_info)
        
        rewards_table = QtWidgets.QLabel(
            "<table style='font-size:10px; color:#777;'>"
            "<tr style='color:#ffeaa7;'><th style='padding:2px 6px;'>Duration</th><th>Common</th><th>Uncommon</th><th>Rare</th><th>Epic</th><th>Legendary</th></tr>"
            "<tr><td>&lt;30m</td><td>50%</td><td>30%</td><td>15%</td><td>4%</td><td>1%</td></tr>"
            "<tr><td>30m</td><td style='color:#4caf50;'>80%</td><td>15%</td><td>5%</td><td>-</td><td>-</td></tr>"
            "<tr><td>1h</td><td>20%</td><td style='color:#4caf50;'>60%</td><td>15%</td><td>5%</td><td>-</td></tr>"
            "<tr><td>2h</td><td>5%</td><td>15%</td><td style='color:#2196f3;'>60%</td><td>15%</td><td>5%</td></tr>"
            "<tr><td>3h</td><td>-</td><td>5%</td><td>15%</td><td style='color:#9c27b0;'>60%</td><td>20%</td></tr>"
            "<tr><td>4h+</td><td>-</td><td>-</td><td>5%</td><td>15%</td><td style='color:#ff9800;'>80%</td></tr>"
            "</table>"
        )
        rewards_table.setStyleSheet("background: transparent;")
        rewards_content_layout.addWidget(rewards_table)
        
        rewards_bonus = QtWidgets.QLabel("<span style='color:#74b9ff;'>Streak:</span> +1 tier/7d | <span style='color:#fdcb6e;'>XP:</span> 25 + 2/min")
        rewards_bonus.setStyleSheet("font-size: 10px; color: #666; background: transparent;")
        rewards_content_layout.addWidget(rewards_bonus)
        
        self.rewards_content.setVisible(False)  # Collapsed by default
        rewards_layout.addWidget(self.rewards_content)
        layout.addWidget(rewards_card)

        # === BOTTOM ROW: Log Past Session + Help ===
        bottom_row = QtWidgets.QHBoxLayout()
        bottom_row.setSpacing(10)
        
        self.log_past_btn = QtWidgets.QPushButton("üìù Log Past Session")
        self.log_past_btn.setToolTip("Forgot to start the timer? Log a focus session you already completed.")
        self.log_past_btn.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self.log_past_btn.setStyleSheet("""
            QPushButton {
                background: #333;
                color: #aaa;
                font-size: 11px;
                font-weight: 500;
                border-radius: 6px;
                border: 1px solid #444;
                padding: 8px 16px;
            }
            QPushButton:hover {
                background: #3d3d3d;
                color: #fff;
                border-color: #555;
            }
        """)
        self.log_past_btn.clicked.connect(self._show_log_past_session_dialog)
        bottom_row.addWidget(self.log_past_btn)
        
        bottom_row.addStretch()
        
        # Help button
        add_tab_help_button(bottom_row, "timer", self)
        
        layout.addLayout(bottom_row)
        
        # Add stretch at bottom to absorb extra space
        layout.addStretch(1)
        
        # Set content widget into scroll area
        scroll.setWidget(content)
        outer_layout.addWidget(scroll)
        
        # Initialize quick stats
        self._refresh_quick_stats()
    
    def _toggle_rewards_info(self) -> None:
        """Toggle rewards info visibility."""
        is_visible = self.rewards_content.isVisible()
        self.rewards_content.setVisible(not is_visible)
        self.rewards_toggle_btn.setText("‚ñ≤" if not is_visible else "‚ñº")
    
    def _update_motivation_message(self) -> None:
        """Update the motivational message based on current context."""
        if not hasattr(self, 'motivation_label'):
            return
        
        import random
        from datetime import datetime
        
        # Safety check - slider might not exist yet during __init__
        if not hasattr(self, 'duration_slider'):
            return
            
        duration = self.duration_slider.value()
        hour = datetime.now().hour
        streak = self.blocker.stats.get("current_streak", 0)
        
        # Context-aware messages
        if self.timer_running:
            messages = [
                "You're doing great! Stay focused! üí™",
                "Deep work in progress... üß†",
                "Every minute counts. Keep going! ‚è∞",
                "You've got this! üî•",
            ]
        elif hour < 9:
            messages = [
                "Early bird gets the worm! Great time to focus. üåÖ",
                "Morning focus sessions are the most productive! ‚òÄÔ∏è",
                "Start your day with a win! üèÜ",
            ]
        elif hour >= 22:
            messages = [
                "Late night focus? Remember to rest well! üåô",
                "A quick session before bed? You're dedicated! ‚≠ê",
            ]
        elif streak >= 7:
            messages = [
                f"üî• {streak} day streak! You're on fire!",
                f"Amazing! {streak} days strong! Keep it going! üí™",
            ]
        elif duration >= 120:
            messages = [
                f"Deep work mode: {duration//60}h session for epic rewards! üéØ",
                f"Going for the long haul? Legendary rewards await! ‚ú®",
            ]
        elif duration >= 60:
            messages = [
                f"1 hour of focus = rare gear and major XP! üíé",
                f"Great choice! Hour-long sessions boost productivity! üìà",
            ]
        else:
            messages = [
                "Ready to focus? Set your duration and press Start!",
                "Short bursts can be powerful. Let's go! ‚ö°",
                "Every focus session makes you stronger! üí™",
                "Longer sessions = better rewards! Try 1h+ for rare gear! üéÅ",
            ]
        
        self.motivation_label.setText(random.choice(messages))
    
    def _refresh_quick_stats(self) -> None:
        """Refresh the quick stats display."""
        try:
            from app_utils import get_activity_date
            from datetime import datetime
            
            today = get_activity_date(datetime.now())
            
            # Today's focus time
            today_minutes = 0
            sessions_today = 0
            for session in self.blocker.stats.get("sessions", []):
                if session.get("date") == today:
                    today_minutes += session.get("minutes", 0)
                    sessions_today += 1
            
            hours = today_minutes // 60
            mins = today_minutes % 60
            if hours > 0:
                self.today_focus_lbl.setText(f"{hours}h {mins}m")
            else:
                self.today_focus_lbl.setText(f"{mins}m")
            
            self.sessions_today_lbl.setText(str(sessions_today))
            
            # Current streak
            streak = self.blocker.stats.get("current_streak", 0)
            self.streak_display_lbl.setText(f"{streak} day{'s' if streak != 1 else ''}")
            
        except Exception:
            self.today_focus_lbl.setText("0m")
            self.sessions_today_lbl.setText("0")
            self.streak_display_lbl.setText("0 days")
    
    def showEvent(self, event: QtGui.QShowEvent) -> None:
        """Refresh quick stats when the tab becomes visible."""
        super().showEvent(event)
        self._refresh_quick_stats()
        self._update_motivation_message()

    def _connect_signals(self) -> None:
        self.action_btn.clicked.connect(self._toggle_session)
        # Save settings when they change
        self.mode_combo.currentIndexChanged.connect(self._save_timer_settings)
        self.duration_slider.valueChanged.connect(self._save_timer_settings)
        self.duration_slider.valueChanged.connect(self._update_motivation_message)
        self.notify_combo.currentIndexChanged.connect(self._save_timer_settings)

    def _load_last_session_settings(self) -> None:
        """Load the last session settings from config."""
        # Load mode
        saved_mode = getattr(self.blocker, 'last_session_mode', BlockMode.NORMAL)
        if saved_mode in self._mode_values:
            self.mode_combo.setCurrentIndex(self._mode_values.index(saved_mode))
        
        # Load duration (default 25 minutes)
        saved_duration = getattr(self.blocker, 'last_session_duration', 25)
        self.duration_slider.setValue(saved_duration)
        
        # Load notify mode (default "both")
        saved_notify = getattr(self.blocker, 'last_notify_mode', 'both')
        if saved_notify in self._notify_values:
            self.notify_combo.setCurrentIndex(self._notify_values.index(saved_notify))

    def _save_timer_settings(self) -> None:
        """Save current timer settings to config."""
        # Save mode
        self.blocker.last_session_mode = self._current_mode()
        
        # Save duration
        self.blocker.last_session_duration = self.duration_slider.value()
        
        # Save notify mode
        self.blocker.last_notify_mode = self._get_notify_mode()
        
        # Persist to disk
        self.blocker.save_config()

    def _set_action_btn_start_style(self) -> None:
        """Set the action button to Start style (green, modern)."""
        self.action_btn.setText("‚ñ∂  Start Focus Session")
        self.action_btn.setToolTip("Click to start your focus session. Sites will be blocked until complete.")
        self.action_btn.setStyleSheet("""
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 #00d2a0, stop:1 #00b894);
                color: white;
                font-size: 16px;
                font-weight: bold;
                border-radius: 12px;
                border: none;
                padding: 14px 28px;
            }
            QPushButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 #55efc4, stop:1 #00d2a0);
            }
            QPushButton:pressed {
                background: #00a884;
            }
        """)
        # Hide progress elements when not running
        if hasattr(self, 'session_progress'):
            self.session_progress.setVisible(False)
        if hasattr(self, 'session_status'):
            self.session_status.setVisible(False)
        # Enable session controls when not running
        self._set_session_controls_enabled(True)
        # Update motivation message
        if hasattr(self, 'motivation_label'):
            self._update_motivation_message()

    def _set_action_btn_stop_style(self) -> None:
        """Set the action button to Stop style (red, modern)."""
        self.action_btn.setText("‚èπ  Stop Session")
        self.action_btn.setToolTip("Click to stop the current session early.")
        self.action_btn.setStyleSheet("""
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 #ff6b6b, stop:1 #d63031);
                color: white;
                font-size: 16px;
                font-weight: bold;
                border-radius: 12px;
                border: none;
                padding: 14px 28px;
            }
            QPushButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 #ff8787, stop:1 #ff6b6b);
            }
            QPushButton:pressed {
                background: #c0392b;
            }
        """)
        # Show progress elements when running
        if hasattr(self, 'session_progress'):
            self.session_progress.setVisible(True)
        if hasattr(self, 'session_status'):
            self.session_status.setVisible(True)
        # Disable session controls when running (prevent changing duration/mode)
        self._set_session_controls_enabled(False)
        # Update motivation message for running state
        if hasattr(self, 'motivation_label'):
            self._update_motivation_message()

    def _set_session_controls_enabled(self, enabled: bool) -> None:
        """Enable or disable session configuration controls.
        
        When a session is running, duration, mode, and preset controls should
        be disabled to prevent confusion with progress calculation.
        """
        # Duration slider
        if hasattr(self, 'duration_slider'):
            self.duration_slider.setEnabled(enabled)
        
        # Duration display label
        if hasattr(self, 'duration_display'):
            self.duration_display.setStyleSheet(
                "background: #3d3d5c; color: #a29bfe; font-weight: bold; "
                "border-radius: 6px; padding: 4px 12px;" if enabled else
                "background: #2d2d3c; color: #666; font-weight: bold; "
                "border-radius: 6px; padding: 4px 12px;"
            )
        
        # Mode combo
        if hasattr(self, 'mode_combo'):
            self.mode_combo.setEnabled(enabled)
        
        # Alert/Notify combo
        if hasattr(self, 'notify_combo'):
            self.notify_combo.setEnabled(enabled)
        
        # Preset buttons
        for btn in getattr(self, 'preset_buttons', []):
            btn.setEnabled(enabled)

    def _toggle_session(self) -> None:
        """Toggle between starting and stopping a session."""
        if self.timer_running:
            self._stop_session()
        else:
            self._start_session()

    # === UI helpers ===
    def _on_duration_changed(self, value: int) -> None:
        """Update the duration display when slider changes."""
        # Snap to nearest 5 minutes
        snapped = round(value / 5) * 5
        if snapped != value:
            self.duration_slider.blockSignals(True)
            self.duration_slider.setValue(snapped)
            self.duration_slider.blockSignals(False)
            value = snapped
        
        if value >= 60:
            hours = value // 60
            mins = value % 60
            if mins == 0:
                self.duration_display.setText(f"{hours}h")
            else:
                self.duration_display.setText(f"{hours}h {mins}m")
        else:
            self.duration_display.setText(f"{value} min")

    def _set_preset(self, minutes: int) -> None:
        """Set the duration slider to a preset value."""
        self.duration_slider.setValue(minutes)

    def _current_mode(self) -> str:
        idx = self.mode_combo.currentIndex()
        if 0 <= idx < len(self._mode_values):
            return self._mode_values[idx]
        return BlockMode.NORMAL

    def _format_time(self, seconds: int) -> str:
        h = seconds // 3600
        m = (seconds % 3600) // 60
        s = seconds % 60
        return f"{h:02d}:{m:02d}:{s:02d}"

    def _update_timer_display(self) -> None:
        """Update timer label and button states."""
        self.timer_label.setText(self._format_time(self.remaining_seconds))
        if self.timer_running:
            self._set_action_btn_stop_style()
            self.status_label.setText("üîí BLOCKING")
        else:
            self._set_action_btn_start_style()
            self.status_label.setText("Ready to focus")

    # === Timer control ===
    def _start_session(self) -> None:
        # Guard against starting while already running
        if self.timer_running:
            return
        
        # Check if we should ask about priorities first (only if not already set by priority dialog)
        if not hasattr(self, '_preserve_strategic_flag'):
            # Check if user wants to be asked about priorities
            if (self.blocker.ask_priority_on_session_start and 
                self.blocker.priorities and
                not self._is_starting_with_priority):
                # Check if there are priorities for today
                today = datetime.now().strftime("%A")
                has_today_priorities = any(
                    p.get("title", "").strip() and (not p.get("days") or today in p.get("days", []))
                    for p in self.blocker.priorities
                )
                if has_today_priorities:
                    dialog = PrioritySessionStartDialog(self.blocker, self)
                    result = dialog.exec()
                    if result != QtWidgets.QDialog.Accepted:
                        return  # User cancelled
                    
                    # If user selected a priority, set it up
                    if dialog.selected_priority:
                        self.session_priority_title = dialog.selected_priority
                        self.session_is_strategic = dialog.is_strategic
                        self._preserve_strategic_flag = True
        
        # Reset the flag for next time
        self._is_starting_with_priority = False
        
        # Set immediately to prevent race condition from double-clicks
        self.timer_running = True
        
        total_minutes = self.duration_slider.value()
        if total_minutes <= 0:
            self.timer_running = False  # Reset on validation failure
            show_warning(self, "Invalid Duration", "Please set a time greater than 0 minutes.")
            return

        mode = self._current_mode()
        self.blocker.mode = mode

        # Reset Pomodoro state
        self.pomodoro_is_break = False
        self.pomodoro_session_count = 0
        self.pomodoro_total_work_time = 0
        self.last_checkin_time = None
        self._checkin_count = 0  # Reset priority check-in counter
        
        # Reset strategic priority tracking (will be set by priority dialog if applicable)
        # Only reset if not already set by _start_priority_session
        if not hasattr(self, '_preserve_strategic_flag'):
            self.session_is_strategic = False
            self.session_priority_title = None
        else:
            delattr(self, '_preserve_strategic_flag')

        # Pomodoro uses its own durations
        if mode == BlockMode.POMODORO:
            total_seconds = self.blocker.pomodoro_work * 60
            self.status_label.setText(f"üçÖ WORK #{self.pomodoro_session_count + 1}")
        else:
            total_seconds = total_minutes * 60

        # Request permission for system changes (only in FULL enforcement mode)
        if self.blocker.enforcement_mode == EnforcementMode.FULL:
            permission_granted = request_system_permission(
                parent=self,
                action="modify_hosts",
                title="Modify System Hosts File",
                description=(
                    "To block distracting websites, this app needs to modify your Windows hosts file. "
                    "This is a standard technique used by parental control and productivity software."
                ),
                details=(
                    "‚Ä¢ File location: C:\\Windows\\System32\\drivers\\etc\\hosts\n"
                    "‚Ä¢ Action: Add entries that redirect blocked sites to 127.0.0.1\n"
                    "‚Ä¢ Blocked sites will show 'connection refused' in your browser\n"
                    "‚Ä¢ Requires administrator privileges (already granted)"
                ),
                persistence_info=(
                    "TEMPORARY ‚Äî Changes are automatically removed when:\n"
                    "‚Ä¢ Your focus session ends normally\n"
                    "‚Ä¢ You click Stop to end the session early\n"
                    "‚Ä¢ The app is closed or crashes (cleanup on next startup)"
                ),
                revert_info=(
                    "If changes persist after app issues:\n"
                    "1. Open Notepad as Administrator\n"
                    "2. Open: C:\\Windows\\System32\\drivers\\etc\\hosts\n"
                    "3. Delete lines between '# === Personal Liberty BLOCK START ===' "
                    "and '# === Personal Liberty BLOCK END ==='\n"
                    "4. Save the file\n"
                    "Or run the included 'cleanup_hosts.ps1' script as Administrator."
                ),
                blocker=self.blocker
            )
            if not permission_granted:
                self.timer_running = False  # Reset if permission denied
                return

        success, message = self.blocker.block_sites(duration_seconds=total_seconds)
        if not success:
            self.timer_running = False  # Reset on blocking failure
            show_error(self, "Cannot Start Session", message)
            return

        self.remaining_seconds = total_seconds
        self.session_total_seconds = total_seconds  # Store for accurate progress calculation
        self.session_start = QtCore.QDateTime.currentDateTime().toSecsSinceEpoch()
        self.timer_label.setText(self._format_time(self.remaining_seconds))
        self._set_action_btn_stop_style()
        if mode != BlockMode.POMODORO:
            # Different status for Full vs Light mode
            if self.blocker.enforcement_mode == EnforcementMode.LIGHT:
                self.status_label.setText("üîî MONITORING")
            else:
                self.status_label.setText("üîí BLOCKING")
        self.qt_timer.start()

        # Emit session started signal
        self.session_started.emit()

        # Update tray icon to blocking state
        main_window = self.window()
        if hasattr(main_window, '_update_tray_icon'):
            main_window._update_tray_icon(blocking=True)

    def _stop_session(self) -> None:
        # Check password for Strict Mode
        if self.blocker.mode == BlockMode.STRICT and self.blocker.password_hash:
            pwd, ok = QtWidgets.QInputDialog.getText(
                self, "Password Required", "Enter password to stop Strict Mode:",
                QtWidgets.QLineEdit.Password
            )
            if not ok or not self.blocker.verify_password(pwd or ""):
                show_warning(self, "Incorrect Password", "The password you entered is incorrect.\nSession continues.")
                return
        
        # Check for Hardcore Mode - must solve math challenges
        if self.blocker.mode == BlockMode.HARDCORE:
            dialog = HardcoreChallengeDialog(self)
            if dialog.exec() != QtWidgets.QDialog.Accepted:
                # User cancelled or failed - session continues
                return

        elapsed = 0
        if self.session_start:
            elapsed = int(QtCore.QDateTime.currentDateTime().toSecsSinceEpoch() - self.session_start)

        self.timer_running = False
        self.qt_timer.stop()
        self.remaining_seconds = 0
        self.timer_label.setText("00:00:00")
        self._set_action_btn_start_style()
        self.status_label.setText("Ready to focus")
        self.pomodoro_is_break = False
        self.pomodoro_session_count = 0
        self.pomodoro_total_work_time = 0

        # Update tray icon to ready state
        main_window = self.window()
        if hasattr(main_window, '_update_tray_icon'):
            main_window._update_tray_icon(blocking=False)

        # Unblock sites
        self.blocker.unblock_sites()

        # Only record stats if ran > 60s
        if elapsed > 60:
            self.blocker.update_stats(elapsed, completed=False)
            self.session_complete.emit(elapsed)
            
            # Check for entity encounter with reduced chance (bypass penalty)
            # Users who need to stop early (fatigue, emergencies) still have
            # a small chance at encounters to avoid feeling punished
            session_minutes = elapsed // 60
            if session_minutes >= 10:  # Minimum 10 minutes for bypass encounter
                self._check_entitidex_encounter_bypass(session_minutes)
        
        # Refresh quick stats
        self._refresh_quick_stats()

    def _on_tick(self) -> None:
        if not self.timer_running:
            return
        self.remaining_seconds -= 1
        self.timer_label.setText(self._format_time(max(self.remaining_seconds, 0)))
        self.timer_tick.emit(max(self.remaining_seconds, 0))
        
        # Update session progress bar and status
        self._update_session_progress()

        # Priority check-in during sessions
        self._check_priority_checkin()

        if self.remaining_seconds <= 0:
            self._handle_session_complete()
    
    def _update_session_progress(self) -> None:
        """Update the session progress bar and status text."""
        if not self.session_start or not hasattr(self, 'session_progress'):
            return
        
        try:
            # Use the stored session total, not the slider value
            total_seconds = self.session_total_seconds if self.session_total_seconds > 0 else self.remaining_seconds
            elapsed = total_seconds - self.remaining_seconds
            
            if total_seconds > 0:
                progress_pct = min(100, int((elapsed / total_seconds) * 100))
                self.session_progress.setValue(progress_pct)
                
                # Update status text
                elapsed_mins = elapsed // 60
                total_mins = total_seconds // 60
                
                # Mode-specific status
                mode = self._current_mode()
                mode_emoji = {
                    BlockMode.NORMAL: "üéØ",
                    BlockMode.STRICT: "üîê",
                    BlockMode.HARDCORE: "üíÄ",
                    BlockMode.POMODORO: "üçÖ",
                }.get(mode, "üéØ")
                
                if hasattr(self, 'session_status'):
                    if mode == BlockMode.POMODORO and self.pomodoro_is_break:
                        self.session_status.setText(f"‚òï Break Time ‚Ä¢ {elapsed_mins}m / {total_mins}m")
                    else:
                        self.session_status.setText(f"{mode_emoji} Focusing ‚Ä¢ {elapsed_mins}m / {total_mins}m ‚Ä¢ {progress_pct}%")
        except Exception:
            pass

    def _check_priority_checkin(self) -> None:
        """Check if it's time to show a priority check-in dialog."""
        if not self.blocker.priority_checkin_enabled:
            return
        if self.blocker.mode == BlockMode.POMODORO and self.pomodoro_is_break:
            return  # Don't check-in during breaks
        if not self.session_start:
            return

        elapsed = int(QtCore.QDateTime.currentDateTime().toSecsSinceEpoch() - self.session_start)
        interval_seconds = self.blocker.priority_checkin_interval * 60
        
        if interval_seconds <= 0:
            return

        # Count intervals that should have triggered a check-in
        intervals_passed = elapsed // interval_seconds
        
        # Track how many check-ins we've completed
        if not hasattr(self, '_checkin_count'):
            self._checkin_count = 0
        
        # If we've completed more intervals than check-ins, show one
        if intervals_passed > 0 and intervals_passed > self._checkin_count:
            self._checkin_count = intervals_passed
            self.last_checkin_time = elapsed
            self._show_priority_checkin()

    def _show_priority_checkin(self) -> None:
        """Show the priority check-in dialog."""
        today = datetime.now().strftime("%A")
        today_priorities = [
            p for p in self.blocker.priorities
            if p.get("title", "").strip() and (not p.get("days") or today in p.get("days", []))
        ]
        if not today_priorities:
            return

        elapsed = int(QtCore.QDateTime.currentDateTime().toSecsSinceEpoch() - self.session_start) if self.session_start else 0
        session_minutes = elapsed // 60

        dialog = PriorityCheckinDialog(self.blocker, today_priorities, session_minutes, self.window())
        dialog.exec()
        dialog_result = dialog.result  # Capture result before cleanup
        dialog.hide()  # Explicitly hide before deletion
        dialog.deleteLater()  # Ensure dialog is cleaned up

        # Handle on-task confirmation with rewards
        if dialog_result and GAMIFICATION_AVAILABLE:
            self._give_session_rewards(session_minutes)

    def _is_perfect_session(self) -> bool:
        """
        Check if the current session was perfect (no distraction attempts).
        
        A perfect session means the user didn't try to access any blocked sites.
        Returns True if bypass logger shows 0 attempts, or if bypass logger is unavailable.
        """
        if not BYPASS_LOGGER_AVAILABLE:
            return False  # Conservative: if we can't track, assume not perfect
        
        try:
            from bypass_logger import get_bypass_logger
            bypass_logger = get_bypass_logger()
            stats = bypass_logger.get_statistics()
            return stats.get("current_session", 0) == 0
        except Exception:
            return False  # Error getting stats, assume not perfect

    def _give_session_rewards(self, session_minutes: int) -> None:
        """Give item drop, XP, and diary entry rewards with lottery animation."""
        if not GAMIFICATION_AVAILABLE:
            return
        # Skip if gamification mode is disabled
        if not is_gamification_enabled(self.blocker.adhd_buster):
            return

        streak = self.blocker.stats.get("streak_days", 0)
        
        # Get active story for themed item generation
        active_story = self.blocker.adhd_buster.get("active_story", "warrior")
        
        # Calculate coin earnings
        session_hours = session_minutes / 60.0
        base_coins_per_hour = 10
        coins_earned = int(session_hours * base_coins_per_hour)
        
        # Apply strategic priority bonus (+150% = 2.5x multiplier)
        if self.session_is_strategic:
            coins_earned = int(coins_earned * 2.5)
        
        # Apply lucky options coin bonus from equipped gear - REMOVED (now used for merge discount)
        equipped = self.blocker.adhd_buster.get("equipped", {})
        lucky_bonuses = {"coin_discount": 0, "xp_bonus": 0, "merge_luck": 0}
        if calculate_total_lucky_bonuses:
            lucky_bonuses = calculate_total_lucky_bonuses(equipped)
        
        # Add streak bonus coins (logarithmic scaling)
        streak_bonus = 0
        if streak >= 30:
            streak_bonus = 100
        elif streak >= 14:
            streak_bonus = 50
        elif streak >= 7:
            streak_bonus = 25
        elif streak >= 3:
            streak_bonus = 10
        
        coins_earned += streak_bonus
        
        # ‚ú® ENTITY PERK BONUS: Apply coin perks from collected entities
        entity_coin_bonus = 0
        coin_perk_breakdown = []
        try:
            from gamification import get_entity_coin_perks
            coin_perks = get_entity_coin_perks(self.blocker.adhd_buster, source="session")
            
            # Add flat coin bonus
            if coin_perks["coin_flat"] > 0:
                entity_coin_bonus += coin_perks["coin_flat"]
                coin_perk_breakdown.append(f"+{coin_perks['coin_flat']} coins")
            
            # Apply percent bonus
            if coin_perks["coin_percent"] > 0:
                pct_bonus = int(coins_earned * (coin_perks["coin_percent"] / 100.0))
                entity_coin_bonus += pct_bonus
                coin_perk_breakdown.append(f"+{coin_perks['coin_percent']}% coins")
            
            coins_earned += entity_coin_bonus
        except Exception as e:
            print(f"[Entity Perks] Error applying coin perks: {e}")
        
        # ‚ú® PERFECT SESSION BONUS: Apply bonus if no distraction attempts
        is_perfect = self._is_perfect_session()
        perfect_session_bonus_pct = 0
        if is_perfect:
            try:
                from gamification import get_entity_qol_perks
                qol_perks = get_entity_qol_perks(self.blocker.adhd_buster)
                perfect_session_bonus_pct = qol_perks.get("perfect_session_bonus", 0)
                if perfect_session_bonus_pct > 0:
                    perfect_coin_bonus = int(coins_earned * (perfect_session_bonus_pct / 100.0))
                    coins_earned += perfect_coin_bonus
                    coin_perk_breakdown.append(f"+{perfect_session_bonus_pct}% perfect session")
            except Exception as e:
                print(f"[Perfect Session] Error applying bonus: {e}")
        
        # Award XP for the focus session (with lucky XP bonus from gear AND entity perks)
        xp_bonus_pct = lucky_bonuses.get("xp_bonus", 0)
        # Add perfect session bonus to XP if applicable
        if is_perfect and perfect_session_bonus_pct > 0:
            xp_bonus_pct += perfect_session_bonus_pct
        # Cap at 200% to prevent overflow
        xp_bonus_pct = min(xp_bonus_pct, 200)
        xp_info = calculate_session_xp(
            session_minutes, streak, lucky_xp_bonus=xp_bonus_pct,
            adhd_buster=self.blocker.adhd_buster
        )

        # Generate item (100% guaranteed drop) with entity rarity perks
        item = generate_item(session_minutes=session_minutes, streak_days=streak,
                              story_id=active_story, adhd_buster=self.blocker.adhd_buster)

        # Get currently equipped item BEFORE awarding the new one (for comparison dialog)
        equipped_item_before = None
        if GAMIFICATION_AVAILABLE:
            try:
                from gamification import get_equipped_item
                equipped_item_before = get_equipped_item(self.blocker.adhd_buster, item.get("slot", "Unknown"))
            except ImportError:
                pass

        # Show lottery animation for tier reveal (item is always awarded)
        from lottery_animation import FocusTimerLotteryDialog
        lottery_dialog = FocusTimerLotteryDialog(
            session_minutes=session_minutes,
            streak_days=streak,
            item=item,
            parent=self.window()
        )
        lottery_dialog.exec()
        lottery_dialog.hide()  # Explicitly hide before deletion to prevent ghost boxes
        lottery_dialog.deleteLater()  # Ensure dialog is cleaned up

        # Ensure item has all required fields
        if "obtained_at" not in item:
            item["obtained_at"] = datetime.now().isoformat()
        
        # === Use GameState Manager for Atomic Updates ===
        # This ensures all UI components are notified of changes automatically
        main_window = self.window()
        game_state = getattr(main_window, 'game_state', None)
        if not game_state:
            logger.error("GameStateManager not available - cannot award session rewards")
            return
        
        # Use award_items_batch for atomic rewards (handles add + auto-equip)
        # This properly deep-copies items and uses the state manager throughout
        game_state.begin_batch()
        try:
            # Award item with auto-equip to empty slots
            game_state.award_items_batch([item], coins=coins_earned, auto_equip=True, source="session_completion")
            
            # Award XP via state manager
            xp_result_tuple = game_state.add_xp(xp_info["total_xp"])
            xp_result = {
                "new_xp": xp_result_tuple[0],
                "new_level": xp_result_tuple[1],
                "leveled_up": xp_result_tuple[2],
            }
            leveled_up = xp_result["leveled_up"]
            
        finally:
            game_state.end_batch()

        # Generate diary entry (once per day)
        today = datetime.now().strftime("%Y-%m-%d")
        diary = self.blocker.adhd_buster.get("diary", [])
        today_entries = [e for e in diary if e.get("date") == today]

        diary_entry = None
        if not today_entries:
            power = calculate_character_power(self.blocker.adhd_buster)
            equipped = self.blocker.adhd_buster.get("equipped", {})
            diary_entry = generate_diary_entry(power, session_minutes, equipped,
                                               story_id=active_story)
            if "diary" not in self.blocker.adhd_buster:
                self.blocker.adhd_buster["diary"] = []
            self.blocker.adhd_buster["diary"].append(diary_entry)
            if len(self.blocker.adhd_buster["diary"]) > 100:
                self.blocker.adhd_buster["diary"] = self.blocker.adhd_buster["diary"][-100:]

        # Save diary entry (batch already saved game state, this saves the diary addition)
        game_state.force_save()

        # Show level-up celebration first (most exciting!)
        if leveled_up:
            old_level = xp_result.get("old_level", 1)
            new_level = xp_result.get("new_level", 1)
            
            # Check for building slot unlocks
            unlocks = []
            try:
                from city import get_slot_unlock_at_level, CITY_AVAILABLE
                if CITY_AVAILABLE:
                    slot_info = get_slot_unlock_at_level(new_level, old_level)
                    if slot_info.get("unlocked"):
                        if slot_info.get("is_first_slot"):
                            # First slot - give detailed explanation
                            unlocks.append("üèóÔ∏è CITY BUILDING UNLOCKED!")
                            unlocks.append("Build structures in the City tab to earn passive coins & bonuses!")
                            unlocks.append("Complete focus sessions & exercise to power construction.")
                        elif slot_info.get("all_slots_unlocked"):
                            unlocks.append("üèôÔ∏è ALL 10 BUILDING SLOTS UNLOCKED!")
                            unlocks.append("Your city is now at maximum capacity!")
                        else:
                            slot_num = slot_info.get("slot_number", 0)
                            if slot_info.get("slots_unlocked_count", 1) > 1:
                                unlocks.append(f"üèóÔ∏è {slot_info['slots_unlocked_count']} NEW BUILDING SLOTS!")
                                unlocks.append(f"You now have {slot_num} city plots available!")
                            else:
                                unlocks.append(f"üèóÔ∏è BUILDING SLOT #{slot_num} UNLOCKED!")
                            unlocks.append("Visit the City tab to expand your empire!")
            except Exception as e:
                logger.debug(f"Could not check city slot unlocks: {e}")
            
            stats = {
                "total_power": self.blocker.adhd_buster.get("total_power", 0),
                "total_xp": self.blocker.adhd_buster.get("total_xp", 0),
                "total_coins": self.blocker.adhd_buster.get("coins", 0),
                "productivity_score": self.blocker.adhd_buster.get("productivity_score", 0),
                "total_focus_minutes": self.blocker.adhd_buster.get("total_focus_time", 0) // 60,
                "items_collected": len(self.blocker.adhd_buster.get("inventory", [])),
                "unlocks": unlocks,
                "rewards": None  # Could add level-up rewards
            }
            # Use fullscreen mode for multi-level gains
            fullscreen = (new_level - old_level) > 1
            levelup_dialog = EnhancedLevelUpDialog(old_level, new_level, stats, fullscreen, self.window())
            levelup_dialog.view_stats.connect(self._show_stats_dialog)
            levelup_dialog.exec()
            levelup_dialog.hide()  # Explicitly hide before deletion to prevent ghost boxes
            levelup_dialog.deleteLater()  # Ensure dialog is cleaned up

        # Show unified item reward dialog with comparison
        # Use equipped_item_before which was captured before the item was auto-equipped
        from styled_dialog import ItemRewardDialog
        
        # Build equipped dict for comparison
        equipped_before = {}
        if equipped_item_before:
            equipped_before[item.get("slot", "Unknown")] = equipped_item_before
        
        # Get entity perk contributors for luck/rarity bonuses
        entity_perk_contributors = []
        try:
            from gamification import get_entity_luck_perk_contributors
            luck_perks = get_entity_luck_perk_contributors(self.blocker.adhd_buster)
            entity_perk_contributors = luck_perks.get("contributors", [])
        except Exception as e:
            logger.debug(f"Could not get entity luck perk contributors: {e}")
        
        # üèôÔ∏è Add city bonus contributors for rarity (Artisan Guild)
        try:
            from city import get_city_bonuses
            city_bonuses = get_city_bonuses(self.blocker.adhd_buster)
            rarity_bonus = city_bonuses.get("rarity_bias_bonus", 0)
            if rarity_bonus > 0:
                entity_perk_contributors.append({
                    "entity_id": "city_artisan_guild",
                    "name": "Artisan Guild",
                    "perk_type": "rarity_bias",
                    "value": int(rarity_bonus),
                    "icon": "üèõÔ∏è",
                    "is_exceptional": False,
                    "description": f"+{int(rarity_bonus)}% Rarity (City Building)",
                    "is_city": True,  # Mark as city building for different display
                })
        except Exception as e:
            logger.debug(f"Could not get city rarity bonus: {e}")
        
        # Build extra messages for display
        extra_msgs = []
        
        # Add city construction progress feedback from the stored contribution info
        main_window = self.window()
        last_contribution = getattr(main_window, '_last_city_contribution', None)
        building_completed_info = None  # Track if building completed for celebration dialog
        if last_contribution:
            building_name = last_contribution.get("building_name")
            amount = last_contribution.get("amount", 0)
            resource = last_contribution.get("resource", "focus")
            progress = last_contribution.get("progress_percent", 0)
            completed = last_contribution.get("completed", False)
            wasted = last_contribution.get("wasted", False)
            short_session = last_contribution.get("short_session", False)
            mins_needed = last_contribution.get("mins_needed", 0)
            
            resource_emoji = "üéØ" if resource == "focus" else "üí™"
            
            if wasted:
                extra_msgs.append(f"‚ö†Ô∏è +{amount} {resource.title()} earned but no building under construction")
            elif completed:
                extra_msgs.append(f"üéâ +{amount} {resource.title()} ‚Üí {building_name} COMPLETE!")
                # Save info for celebration dialog
                building_completed_info = {
                    "building_id": last_contribution.get("building_id", ""),
                    "level": last_contribution.get("level", 1),
                }
            elif short_session and mins_needed > 0:
                extra_msgs.append(f"üèóÔ∏è {mins_needed} more min ‚Üí +1 Focus for {building_name}")
            elif building_name and amount > 0:
                extra_msgs.append(f"üèóÔ∏è +{amount} {resource.title()} ‚Üí {building_name} ({progress:.0f}%)")
            
            # Clear the contribution info after showing
            main_window._last_city_contribution = None
        
        reward_dialog = ItemRewardDialog(
            parent=self.window(),
            source_label=f"Focus Session: {session_minutes} min" + (f" ‚Ä¢ {streak} day streak üî•" if streak > 0 else ""),
            items_earned=[item],
            equipped=equipped_before,
            coins_earned=coins_earned,
            game_state=get_game_state(),
            session_minutes=session_minutes,
            streak_days=streak,
            entity_perk_contributors=entity_perk_contributors,
            extra_messages=extra_msgs,
        )
        reward_dialog.exec()
        reward_dialog.hide()  # Explicitly hide before deletion to prevent ghost boxes
        reward_dialog.deleteLater()  # Ensure dialog is cleaned up
        
        # üéâ Show building complete celebration if construction just finished
        if building_completed_info:
            try:
                from city_tab import show_building_complete_dialog
                building_id = building_completed_info.get("building_id", "")
                level = building_completed_info.get("level", 1)
                # If level > 1, this was an upgrade, not initial construction
                is_upgrade = level > 1
                show_building_complete_dialog(building_id, level, is_upgrade, parent=self.window())
                # Refresh city tab to show completed building (remove construction overlay)
                main_window = self.window()
                if hasattr(main_window, 'city_tab') and hasattr(main_window.city_tab, '_refresh_city'):
                    main_window.city_tab._refresh_city()
            except Exception as e:
                logger.debug(f"Could not show building complete dialog: {e}")
        
        # Refresh city tab if construction progress was tracked
        last_contribution = getattr(self.window(), '_last_city_contribution', None)
        if last_contribution is None:  # Was set and consumed, city might have changed
            main_window = self.window()
            if hasattr(main_window, 'city_tab') and hasattr(main_window.city_tab, '_refresh_city'):
                main_window.city_tab._refresh_city()

        # Note: UI updates are now handled automatically via GameState signals
        # The game_state.end_batch() above triggers power_changed, coins_changed,
        # and inventory_changed signals which update the UI reactively.

        # === Auto-backup on significant session ===
        # Create periodic backup after every 5+ minute session (captures item/XP gains)
        if session_minutes >= 5:
            try:
                self.blocker.save_config(create_backup=True)
            except Exception as e:
                logger.debug(f"Auto-backup after session failed: {e}")

        # === Entitidex Encounter Check ===
        # After item rewards, check for entity encounter based on session
        self._check_entitidex_encounter(session_minutes)

        # Show diary entry reveal
        if diary_entry:
            diary_dialog = DiaryEntryRevealDialog(self.blocker, diary_entry, session_minutes, self.window())
            diary_dialog.exec()
            diary_dialog.hide()  # Explicitly hide before deletion to prevent ghost boxes
            diary_dialog.deleteLater()  # Ensure dialog is cleaned up

    def _get_notify_mode(self) -> str:
        """Get the current notification mode from dropdown."""
        idx = self.notify_combo.currentIndex()
        if 0 <= idx < len(self._notify_values):
            return self._notify_values[idx]
        return "both"  # Default

    def _play_notification_sound(self) -> None:
        """Play a random notification chime on completion using startup_sounds."""
        try:
            from startup_sounds import play_startup_sound, is_sound_available
            if is_sound_available():
                play_startup_sound()
            else:
                # Fallback to lottery win sound
                from lottery_sounds import play_win_sound
                play_win_sound()
        except Exception:
            # Silent fallback
            pass

    def _quick_equip_item(self, item: dict) -> None:
        """Quick equip an item (works for empty slots and upgrades)."""
        if not GAMIFICATION_AVAILABLE:
            return
        
        try:
            slot = item.get("slot", "Unknown")
            
            # Get themed slot name for display (safely handle None functions)
            story_id = None
            display_slot = slot
            try:
                if get_selected_story is not None:
                    story_id = get_selected_story(self.blocker.adhd_buster)
                if get_slot_display_name is not None:
                    display_slot = get_slot_display_name(slot, story_id)
            except Exception:
                pass
            
            # Get game state manager
            game_state = get_game_state()
            if not game_state:
                show_warning(
                    self.window(),
                    "Error",
                    "Game state manager not available."
                )
                return
            
            # Create deep copy to preserve lucky_options
            new_item = item.copy()
            if "lucky_options" in item and isinstance(item["lucky_options"], dict):
                new_item["lucky_options"] = item["lucky_options"].copy()
            
            # Equip the item using GameState (handles both empty slots and upgrades)
            game_state.swap_equipped_item(slot, new_item)
            
            # Sync changes to active hero
            try:
                from gamification import sync_hero_data as _sync
                _sync(self.blocker.adhd_buster)
            except Exception:
                pass
            
            show_info(
                self.window(),
                "Item Equipped!",
                f"‚úì {item.get('name', 'Item')} equipped to {display_slot} slot!"
            )
            
            # Refresh UI
            main_window = self.window()
            if hasattr(main_window, 'refresh_adhd_tab'):
                main_window.refresh_adhd_tab()
                
        except Exception as e:
            show_warning(
                self.window(),
                "Equip Failed",
                f"Could not equip item: {str(e)}"
            )

    def _check_entitidex_encounter(self, session_minutes: int) -> None:
        """
        Check for and handle entitidex entity encounter after session completion.
        
        Args:
            session_minutes: Duration of the completed session in minutes
        """
        if not GAMIFICATION_AVAILABLE:
            return
        
        # Skip if gamification mode is disabled
        if not is_gamification_enabled(self.blocker.adhd_buster):
            return
        
        try:
            from gamification import check_entitidex_encounter, attempt_entitidex_bond
            # from entity_encounter_dialog import EntityEncounterDialog, BondResultDialog (DEPRECATED)
            
            # Check if this was a perfect session (no distraction attempts)
            is_perfect = self._is_perfect_session()
            
            # Get streak for encounter bonus (+2% per consecutive day)
            streak_days = self.blocker.stats.get("streak_days", 0)
            
            # Check for encounter
            encounter = check_entitidex_encounter(
                self.blocker.adhd_buster,
                session_minutes,
                perfect_session=is_perfect,
                streak_days=streak_days
            )
            
            if not encounter["triggered"] or not encounter["entity"]:
                return
            
            # Show perk toast if entity perks or city buildings helped with encounter
            if encounter.get("perk_bonus_applied"):
                perk_parts = []
                if encounter.get("encounter_perk_bonus", 0) > 0:
                    perk_parts.append(f"+{int(encounter['encounter_perk_bonus'])}% encounter (Perks)")
                if encounter.get("city_encounter_bonus", 0) > 0:
                    perk_parts.append(f"+{int(encounter['city_encounter_bonus'])}% encounter (üî≠ Observatory)")
                if encounter.get("capture_perk_bonus", 0) > 0:
                    perk_parts.append(f"+{int(encounter['capture_perk_bonus'])}% capture (Perks)")
                if encounter.get("city_catch_bonus", 0) > 0:
                    perk_parts.append(f"+{int(encounter['city_catch_bonus'])}% capture (üéì University)")
                if perk_parts:
                    show_perk_toast(f"Bonuses: {', '.join(perk_parts)}", "üåü", self)
            
            # Show encounter dialog using new merge-style flow
            entity = encounter["entity"]
            # Capture is_exceptional from encounter result for bond attempt
            encounter_is_exceptional = encounter.get("is_exceptional", False)
            
            try:
                from entity_drop_dialog import show_entity_encounter
                from gamification import save_encounter_for_later
            
                # wrapper callback for the bonding logic
                def bond_callback_wrapper(entity_id: str):
                    # Attempt the bond - pass is_exceptional from encounter
                    result = attempt_entitidex_bond(
                        self.blocker.adhd_buster, entity_id, 
                        is_exceptional=encounter_is_exceptional
                    )
                    
                    # Save the updated data immediately
                    from gamification import sync_hero_data
                    sync_hero_data(self.blocker.adhd_buster)
                    
                    # Get game state and emit XP signal if XP was awarded
                    from game_state import get_game_state
                    game_state = get_game_state()
                    if game_state:
                        # Emit XP signal so UI updates (XP was already added to adhd_buster)
                        xp_awarded = result.get('xp_awarded', 0)
                        if xp_awarded > 0:
                            # Get current XP and level for signal emission
                            total_xp = self.blocker.adhd_buster.get('total_xp', 0)
                            level = self.blocker.adhd_buster.get('hero', {}).get('level', 1)
                            game_state.xp_changed.emit(total_xp, level)
                        game_state.force_save()
                    
                    # Refresh entitidex tab after bond attempt
                    main_win = self.window()
                    if hasattr(main_win, 'entitidex_tab'):
                        main_win.entitidex_tab.refresh()
                        
                    return result

                # wrapper callback for saving encounter for later
                def save_callback_wrapper(entity_id: str, coin_cost: int = 0):
                    result = save_encounter_for_later(
                        adhd_buster=self.blocker.adhd_buster,
                        entity_id=entity_id,
                        is_exceptional=encounter_is_exceptional,
                        catch_probability=encounter["join_probability"],
                        encounter_perk_bonus=encounter.get("encounter_perk_bonus", 0.0),
                        capture_perk_bonus=encounter.get("capture_perk_bonus", 0.0),
                        session_minutes=session_minutes,
                        was_perfect_session=is_perfect,
                        coin_cost=coin_cost,
                    )
                    
                    # Save updated data
                    from gamification import sync_hero_data
                    sync_hero_data(self.blocker.adhd_buster)
                    
                    from game_state import get_game_state
                    game_state = get_game_state()
                    if game_state:
                        game_state.force_save()
                    
                    # Refresh entitidex tab to show updated saved encounters button
                    main_win = self.window()
                    if hasattr(main_win, 'entitidex_tab'):
                        main_win.entitidex_tab._update_saved_button_count()
                    
                    return result

                # Check if user has Chad AGI bonded for special interactions on skip
                CHAD_ENTITY_ID = "underdog_008"
                chad_interaction_data = None
                try:
                    from entitidex import EntitidexManager
                    manager = EntitidexManager()
                    manager.load(self.blocker.adhd_buster.get("entitidex", {}))
                    
                    has_chad_normal = CHAD_ENTITY_ID in manager.progress.collected_entity_ids
                    has_chad_exceptional = manager.progress.is_exceptional(CHAD_ENTITY_ID)
                    
                    if has_chad_normal or has_chad_exceptional:
                        from game_state import get_game_state
                        gs = get_game_state()
                        
                        # Callback to add coins (for exceptional Chad's "banking hack")
                        def add_coins_callback(amount: int):
                            if gs:
                                gs.add_coins(amount)
                        
                        # Callback to give entity as if bonded (for exceptional Chad's gift)
                        def give_entity_callback():
                            # Call the bond logic with guaranteed success (Chad's gift)
                            result = attempt_entitidex_bond(
                                self.blocker.adhd_buster, entity.id,
                                is_exceptional=encounter_is_exceptional,
                                force_success=True  # Chad guarantees the bond!
                            )
                            from gamification import sync_hero_data
                            sync_hero_data(self.blocker.adhd_buster)
                            if gs:
                                xp_awarded = result.get('xp_awarded', 0)
                                if xp_awarded > 0:
                                    total_xp = self.blocker.adhd_buster.get('total_xp', 0)
                                    level = self.blocker.adhd_buster.get('hero', {}).get('level', 1)
                                    gs.xp_changed.emit(total_xp, level)
                                gs.force_save()
                            
                            # Refresh entitidex tab after Chad's gift
                            main_win = self.window()
                            if hasattr(main_win, 'entitidex_tab'):
                                main_win.entitidex_tab.refresh()
                        
                        chad_interaction_data = {
                            "has_chad_normal": has_chad_normal and not has_chad_exceptional,
                            "has_chad_exceptional": has_chad_exceptional,
                            "add_coins_callback": add_coins_callback,
                            "give_entity_callback": give_entity_callback,
                        }
                except Exception as e:
                    logger.debug(f"Could not check for Chad entity: {e}")

                # Build bookmark data for save slot limits
                bookmark_data = None
                try:
                    from gamification import get_bookmark_entity_status, get_save_slot_cost
                    bookmark_status = get_bookmark_entity_status(self.blocker.adhd_buster)
                    slot_info = get_save_slot_cost(self.blocker.adhd_buster, bookmark_status["current_saved"])
                    bookmark_data = {
                        "has_normal": bookmark_status["has_normal"],
                        "has_exceptional": bookmark_status["has_exceptional"],
                        "max_free_slots": bookmark_status["max_free_slots"],
                        "current_saved": bookmark_status["current_saved"],
                        "slot_cost": slot_info["cost"],
                        "can_save": slot_info["can_save"],
                        "slot_reason": slot_info.get("reason", ""),
                    }
                except Exception as e:
                    logger.debug(f"Could not get bookmark data: {e}")

                show_entity_encounter(
                    entity=entity,
                    join_probability=encounter["join_probability"],
                    bond_logic_callback=bond_callback_wrapper,
                    parent=self.window(),
                    is_exceptional=encounter_is_exceptional,
                    save_callback=save_callback_wrapper,
                    chad_interaction_data=chad_interaction_data,
                    coin_data=self._get_coin_data(),
                    bookmark_data=bookmark_data,
                )
            except ImportError:
                 logger.error("Could not import entity_drop_dialog logic")
            
        except ImportError as e:
            # Entitidex not available - silently skip
            logger.debug(f"Entitidex not available: {e}")
        except Exception as e:
            logger.warning(f"Error checking entitidex encounter: {e}")

    def _check_entitidex_encounter_bypass(self, session_minutes: int) -> None:
        """
        Check for entity encounter after a bypassed session (early stop).
        
        Users who need to stop early (fatigue, emergencies) still have a reduced
        chance at encounters. This avoids the "hard gate" problem where bypass
        feels punitive, potentially causing users to avoid using bypass when
        they genuinely need it.
        
        The bypass_penalty_multiplier in ENCOUNTER_CONFIG controls the reduction
        (default: 25% of normal chance).
        
        Args:
            session_minutes: Duration of the bypassed session in minutes
        """
        if not GAMIFICATION_AVAILABLE:
            return
        
        # Skip if gamification mode is disabled
        if not is_gamification_enabled(self.blocker.adhd_buster):
            return
        
        try:
            from gamification import check_entitidex_encounter, attempt_entitidex_bond
            
            # Bypass sessions are never "perfect" 
            is_perfect = False
            
            # Get streak for encounter bonus (+2% per consecutive day)
            streak_days = self.blocker.stats.get("streak_days", 0)
            
            # Check for encounter with bypass penalty applied
            encounter = check_entitidex_encounter(
                self.blocker.adhd_buster,
                session_minutes,
                perfect_session=is_perfect,
                was_bypass_used=True,  # Apply bypass penalty
                streak_days=streak_days,
            )
            
            if not encounter["triggered"] or not encounter["entity"]:
                return
            
            # Show a special toast noting the lucky bypass encounter
            show_perk_toast("Lucky! Encounter despite early stop üéÅ", "‚ú®", self)
            
            # Show encounter dialog using the same flow as normal sessions
            entity = encounter["entity"]
            encounter_is_exceptional = encounter.get("is_exceptional", False)
            
            try:
                from entity_drop_dialog import show_entity_encounter
                from gamification import save_encounter_for_later
            
                # wrapper callback for the bonding logic
                def bond_callback_wrapper() -> dict:
                    result = attempt_entitidex_bond(
                        self.blocker.adhd_buster,
                        entity.id,
                        is_exceptional=encounter_is_exceptional
                    )
                    # Refresh entitidex tab after bond attempt
                    main_win = self.window()
                    if hasattr(main_win, 'entitidex_tab'):
                        main_win.entitidex_tab.refresh()
                    return result
                
                # wrapper callback for saving encounter
                def save_callback_wrapper(entity_id: str, coin_cost: int = 0) -> dict:
                    try:
                        result = save_encounter_for_later(
                            self.blocker.adhd_buster, 
                            entity.id,
                            is_exceptional=encounter_is_exceptional,
                            catch_probability=encounter["join_probability"],
                            encounter_perk_bonus=encounter.get("encounter_perk_bonus", 0.0),
                            capture_perk_bonus=encounter.get("capture_perk_bonus", 0.0),
                            session_minutes=session_minutes,
                            was_perfect_session=is_perfect,
                            coin_cost=coin_cost,
                        )
                        # Refresh entitidex tab after saving encounter
                        main_win = self.window()
                        if hasattr(main_win, 'entitidex_tab'):
                            main_win.entitidex_tab._update_saved_button_count()
                        return result
                    except Exception as e:
                        logger.error(f"Failed to save encounter: {e}")
                        return {"success": False, "message": str(e)}
                
                # Get chad interaction data if available
                chad_interaction_data = None
                try:
                    from gamification import get_chad_interaction_data
                    chad_interaction_data = get_chad_interaction_data(self.blocker.adhd_buster)
                except ImportError:
                    pass
                
                # Build bookmark data for save slot limits
                bookmark_data = None
                try:
                    from gamification import get_bookmark_entity_status, get_save_slot_cost
                    bookmark_status = get_bookmark_entity_status(self.blocker.adhd_buster)
                    slot_info = get_save_slot_cost(self.blocker.adhd_buster, bookmark_status["current_saved"])
                    bookmark_data = {
                        "has_normal": bookmark_status["has_normal"],
                        "has_exceptional": bookmark_status["has_exceptional"],
                        "max_free_slots": bookmark_status["max_free_slots"],
                        "current_saved": bookmark_status["current_saved"],
                        "slot_cost": slot_info["cost"],
                        "can_save": slot_info["can_save"],
                        "slot_reason": slot_info.get("reason", ""),
                    }
                except Exception as e:
                    logger.debug(f"Could not get bookmark data: {e}")

                show_entity_encounter(
                    entity=entity,
                    join_probability=encounter["join_probability"],
                    bond_logic_callback=bond_callback_wrapper,
                    parent=self.window(),
                    is_exceptional=encounter_is_exceptional,
                    save_callback=save_callback_wrapper,
                    chad_interaction_data=chad_interaction_data,
                    coin_data=self._get_coin_data(),
                    bookmark_data=bookmark_data,
                )
            except ImportError:
                 logger.error("Could not import entity_drop_dialog logic")
            
        except ImportError as e:
            logger.debug(f"Entitidex not available: {e}")
        except Exception as e:
            logger.warning(f"Error checking bypass entitidex encounter: {e}")

    def _get_coin_data(self) -> Optional[Dict[str, Any]]:
        """
        Get coin operation callbacks for special entity bonding rewards.
        
        Returns:
            Dict with get_coins_callback and add_coins_callback, or None if unavailable.
        """
        try:
            from game_state import get_game_state
            gs = get_game_state()
            if gs:
                def get_coins_callback() -> int:
                    return gs.coins
                
                def add_coins_callback(amount: int) -> None:
                    gs.add_coins(amount)
                
                return {
                    "get_coins_callback": get_coins_callback,
                    "add_coins_callback": add_coins_callback,
                }
        except Exception as e:
            logger.debug(f"Could not get coin data: {e}")
        return None

    def _show_inventory_dialog(self) -> None:
        """Show inventory management dialog."""
        main_window = self.window()
        if hasattr(main_window, 'adhd_tab'):
            # Switch to ADHD Buster tab
            if hasattr(main_window, 'tabs'):
                tab_index = main_window.tabs.indexOf(main_window.adhd_tab)
                if tab_index >= 0:
                    main_window.tabs.setCurrentIndex(tab_index)
            
            # Open inventory section if available
            if hasattr(main_window.adhd_tab, 'inventory_section'):
                main_window.adhd_tab.inventory_section.show()
                
    def _show_stats_dialog(self) -> None:
        """Show stats/character dialog."""
        main_window = self.window()
        if hasattr(main_window, 'adhd_tab'):
            # Switch to ADHD Buster tab
            if hasattr(main_window, 'tabs'):
                tab_index = main_window.tabs.indexOf(main_window.adhd_tab)
                if tab_index >= 0:
                    main_window.tabs.setCurrentIndex(tab_index)
            
            # Open character section if available
            if hasattr(main_window.adhd_tab, 'character_section'):
                main_window.adhd_tab.character_section.show()

    def _show_desktop_notification(self, title: str, message: str) -> None:
        """Show a Windows toast notification via system tray."""
        try:
            # Use Windows tray balloon tip (works on all Windows versions)
            main_window = self.window()
            if hasattr(main_window, 'tray_icon') and main_window.tray_icon:
                main_window.tray_icon.showMessage(
                    title,
                    message,
                    QtWidgets.QSystemTrayIcon.Information,
                    10000  # 10 seconds
                )
        except Exception:
            pass  # Silent fail - sound notification still works

    def _handle_session_complete(self) -> None:
        """Handle session completion."""
        self.timer_running = False
        self.qt_timer.stop()

        elapsed = 0
        if self.session_start:
            elapsed = int(QtCore.QDateTime.currentDateTime().toSecsSinceEpoch() - self.session_start)

        # Handle Pomodoro mode specially
        if self.blocker.mode == BlockMode.POMODORO:
            self._handle_pomodoro_complete(elapsed)
            return

        self.blocker.update_stats(elapsed, completed=True)
        self.blocker.unblock_sites(force=True)

        # Get notification mode
        notify_mode = self._get_notify_mode()
        
        # Play sound if enabled
        if notify_mode in ("sound", "both"):
            self._play_notification_sound()
        
        # Show desktop notification (tray balloon) always when running
        session_minutes = elapsed // 60
        self._show_desktop_notification(
            "üéâ Focus Session Complete!",
            f"Great job! You focused for {session_minutes} minutes.\nTime for a well-deserved break!"
        )

        self.timer_label.setText("00:00:00")
        self._set_action_btn_start_style()
        self.status_label.setText("Session complete üéâ")

        # Update tray icon to ready state
        main_window = self.window()
        if hasattr(main_window, '_update_tray_icon'):
            main_window._update_tray_icon(blocking=False)

        # Process events to update UI immediately before showing dialogs
        QtWidgets.QApplication.processEvents()

        session_minutes = elapsed // 60

        # Collect rewards first (needed for dialog display)
        rewards_info = {}
        if session_minutes > 0:
            rewards_info = self._collect_session_rewards(session_minutes)
        
        # Emit session_complete EARLY so stats refresh immediately
        # (will emit again after rewards to capture XP/item changes)
        self.session_complete.emit(elapsed)
        
        # Show session complete dialog if enabled
        if notify_mode in ("dialog", "both"):
            from session_complete_dialog import SessionCompleteDialog
            dialog = SessionCompleteDialog(elapsed, rewards_info, parent=self)
            
            # Connect quick action signals
            dialog.start_another_session.connect(self._start_session)
            dialog.view_stats.connect(lambda: self.window().tabs.setCurrentIndex(1))  # Switch to Stats tab
            main_window = self.window()
            if hasattr(main_window, 'show_priorities_dialog'):
                dialog.view_priorities.connect(main_window.show_priorities_dialog)
            
            dialog.exec()
        
        # Refresh quick stats
        self._refresh_quick_stats()
        
        # Process rewards after dialog shown
        if session_minutes > 0:
            QtCore.QTimer.singleShot(50, lambda: self._give_session_rewards_deferred(session_minutes))

    def _give_session_rewards_deferred(self, session_minutes: int) -> None:
        """Deferred session rewards to keep UI responsive.
        
        Uses a re-entrancy guard to prevent multiple reward grants
        if processEvents() triggers additional callbacks.
        """
        if self._giving_rewards:
            return  # Prevent re-entrancy from processEvents
        self._giving_rewards = True
        try:
            QtWidgets.QApplication.processEvents()
            self._give_session_rewards(session_minutes)
            QtWidgets.QApplication.processEvents()
            self._show_priority_time_log(session_minutes)
            # Calculate elapsed for signal - approximate from session_minutes
            self.session_complete.emit(session_minutes * 60)
        finally:
            self._giving_rewards = False
    
    def _collect_session_rewards(self, session_minutes: int) -> dict:
        """Collect reward information without actually awarding them yet.
        
        Returns dict with reward details for display in session complete dialog.
        """
        rewards = {
            "xp": 0,
            "coins": 0,
            "items": [],
            "streak_maintained": False,
            "current_streak": 0,
            "entity_perks_applied": [],  # Track which entity perks were applied
            "city_construction": None,  # Preview of construction contribution
        }
        
        if not GAMIFICATION_AVAILABLE:
            return rewards
        
        if not is_gamification_enabled(self.blocker.adhd_buster):
            return rewards
        
        streak = self.blocker.stats.get("streak_days", 0)
        rewards["current_streak"] = streak
        rewards["streak_maintained"] = streak > 0
        rewards["entity_streak_saved"] = self.blocker.stats.get("entity_streak_saved", False)
        
        # Clear the flag after reading it (one-time notification)
        if rewards["entity_streak_saved"]:
            self.blocker.stats["entity_streak_saved"] = False
        
        # Calculate XP
        equipped = self.blocker.adhd_buster.get("equipped", {})
        lucky_bonuses = {"xp_bonus": 0}
        if calculate_total_lucky_bonuses:
            lucky_bonuses = calculate_total_lucky_bonuses(equipped)
        xp_bonus_pct = min(lucky_bonuses.get("xp_bonus", 0), 200)
        xp_info = calculate_session_xp(
            session_minutes, streak, lucky_xp_bonus=xp_bonus_pct,
            adhd_buster=self.blocker.adhd_buster
        )
        base_xp_total = xp_info["total_xp"]
        
        # üèôÔ∏è CITY BONUS: Library XP bonus (preview what award_xp will apply)
        city_xp_bonus = 0
        try:
            from city import get_city_bonuses
            city_bonuses = get_city_bonuses(self.blocker.adhd_buster)
            xp_bonus_pct_city = city_bonuses.get("xp_bonus", 0)
            if xp_bonus_pct_city > 0 and base_xp_total > 0:
                city_xp_bonus = int(base_xp_total * xp_bonus_pct_city / 100.0)
        except Exception:
            pass
        
        rewards["xp"] = base_xp_total + city_xp_bonus
        rewards["city_xp_bonus"] = city_xp_bonus  # Track for display
        
        # Track XP entity perks from xp_info if available
        entity_xp_breakdown = xp_info.get("entity_xp_breakdown", [])
        if entity_xp_breakdown:
            for bonus_desc in entity_xp_breakdown:
                # bonus_desc is a string like "+5% Focus XP"
                rewards["entity_perks_applied"].append({
                    "type": "xp",
                    "description": f"{bonus_desc} (Entity Perk)",
                    "value": 0,  # Value already included in total
                })
        
        # Calculate coins
        session_hours = session_minutes / 60.0
        base_coins_per_hour = 10
        coins_earned = int(session_hours * base_coins_per_hour)
        
        if self.session_is_strategic:
            coins_earned = int(coins_earned * 2.5)
        
        # Streak bonus
        if streak >= 30:
            coins_earned += 100
        elif streak >= 14:
            coins_earned += 50
        elif streak >= 7:
            coins_earned += 25
        elif streak >= 3:
            coins_earned += 10
        
        # ‚ú® ENTITY PERK BONUS: Apply coin perks from collected entities
        try:
            from gamification import get_entity_coin_perks
            coin_perks = get_entity_coin_perks(self.blocker.adhd_buster, source="session")
            if coin_perks["coin_flat"] > 0:
                coins_earned += coin_perks["coin_flat"]
                rewards["entity_perks_applied"].append({
                    "type": "coins",
                    "description": f"+{coin_perks['coin_flat']} Coins (Entity Perk)",
                    "value": coin_perks["coin_flat"],
                })
            if coin_perks["coin_percent"] > 0:
                percent_bonus = int(coins_earned * (coin_perks["coin_percent"] / 100.0))
                coins_earned += percent_bonus
                rewards["entity_perks_applied"].append({
                    "type": "coins",
                    "description": f"+{coin_perks['coin_percent']}% Coins (Entity Perk)",
                    "value": percent_bonus,
                })
        except Exception:
            pass
        
        rewards["coins"] = coins_earned
        
        # üèõÔ∏è Preview Royal Mint income (coins from focus sessions)
        rewards["city_mint_coins"] = 0
        if CITY_AVAILABLE:
            try:
                from city import get_city_bonuses
                from city.city_buildings import CITY_BUILDINGS
                
                # Check if Royal Mint is built
                city_data = self.blocker.adhd_buster.get("city", {})
                grid = city_data.get("grid", [])
                
                for row in grid:
                    for cell in row:
                        if cell and cell.get("complete", False):
                            building_id = cell.get("building_id")
                            building_def = CITY_BUILDINGS.get(building_id, {})
                            effect = building_def.get("effect", {})
                            
                            if effect.get("type") == "focus_session_income":
                                level = cell.get("level", 1)
                                scaling = building_def.get("level_scaling", {})
                                
                                base_coins = effect.get("base_coins", 0)
                                base_coins += (level - 1) * scaling.get("base_coins", 0)
                                
                                coins_per_30min = effect.get("coins_per_30min", 0)
                                coins_per_30min += (level - 1) * scaling.get("coins_per_30min", 0)
                                
                                time_bonus = int((session_minutes / 30) * coins_per_30min)
                                mint_coins = base_coins + time_bonus
                                
                                rewards["city_mint_coins"] += mint_coins
                                rewards["coins"] += mint_coins
                                
                            # Wonder building multi-effect with focus_session_coins
                            elif effect.get("type") == "multi":
                                bonus_coins = effect.get("bonuses", {}).get("focus_session_coins", 0)
                                if bonus_coins > 0:
                                    time_bonus = int((session_minutes / 30) * (bonus_coins // 2))
                                    wonder_coins = bonus_coins + time_bonus
                                    rewards["city_mint_coins"] += wonder_coins
                                    rewards["coins"] += wonder_coins
            except Exception:
                pass
        
        # Mark that an item will be earned (actual item revealed via lottery animation)
        # Don't generate preview - the lottery will generate the real item
        rewards["items"] = [{"teaser": True}]  # Just a flag that item is coming
        
        # üèôÔ∏è Preview city construction contribution (actual award happens later)
        if CITY_AVAILABLE:
            try:
                from city import get_active_construction_info
                active = get_active_construction_info(self.blocker.adhd_buster)
                if active:
                    focus_earned = session_minutes // 30
                    building_name = active.get("building_name", "Building")
                    current_progress = active.get("effort_progress_percent", 0)
                    
                    if focus_earned > 0:
                        rewards["city_construction"] = {
                            "building_name": building_name,
                            "focus_earned": focus_earned,
                            "current_progress": current_progress,
                        }
                    else:
                        # Show how many more minutes needed for Focus
                        mins_needed = 30 - (session_minutes % 30)
                        rewards["city_construction"] = {
                            "building_name": building_name,
                            "focus_earned": 0,
                            "current_progress": current_progress,
                            "mins_needed": mins_needed,
                        }
            except Exception:
                pass
        
        return rewards

    def _show_priority_time_log(self, session_minutes: int) -> None:
        """Show priority time logging dialog."""
        today = datetime.now().strftime("%A")
        has_priorities = any(
            p.get("title", "").strip() and (not p.get("days") or today in p.get("days", []))
            for p in self.blocker.priorities
        )
        if has_priorities:
            priority_dialog = PriorityTimeLogDialog(self.blocker, session_minutes, self.window())
            priority_dialog.exec()
            priority_dialog.hide()  # Explicitly hide before deletion
            priority_dialog.deleteLater()  # Ensure dialog is cleaned up

    def _show_log_past_session_dialog(self) -> None:
        """Show dialog to log a past focus session retroactively."""
        dialog = LogPastSessionDialog(self.blocker, parent=self.window())
        result = dialog.exec()
        session_minutes = dialog.get_session_minutes() if result == QtWidgets.QDialog.Accepted else 0
        dialog.hide()  # Explicitly hide before deletion
        dialog.deleteLater()  # Ensure dialog is cleaned up
        
        if result == QtWidgets.QDialog.Accepted and session_minutes > 0:
            # Update stats for the past session
            self.blocker.update_stats(session_minutes * 60, completed=True)
            self.blocker.save_stats()
            
            # Notify GameState of focus time change
            try:
                from game_state import get_game_state
                game_state = get_game_state()
                if game_state:
                    game_state.notify_focus_time_changed()
            except Exception:
                pass
            
            # Award city resources BEFORE rewards dialog (so contribution shows in dialog)
            main_window = self.window()
            if CITY_AVAILABLE and hasattr(main_window, '_award_city_resources_for_session'):
                main_window._award_city_resources_for_session(session_minutes * 60)
            
            # Give rewards (same as a normal session)
            # Note: _give_session_rewards already includes entitidex encounter check
            self._give_session_rewards(session_minutes)
            
            # Show priority time log dialog
            self._show_priority_time_log(session_minutes)
            
            # Refresh City tab to show construction progress
            if CITY_AVAILABLE and hasattr(main_window, 'city_tab'):
                main_window.city_tab._refresh_city()
            
            self.status_label.setText(f"‚úÖ Logged {session_minutes} min session")
            self.status_label.setStyleSheet("""
                font-size: 16px;
                font-weight: bold;
                color: #00b894;
                background: transparent;
                padding: 5px;
            """)

    def _handle_pomodoro_complete(self, elapsed: int) -> None:
        """Handle Pomodoro work/break cycle transitions."""
        notify_mode = self._get_notify_mode()
        
        if self.pomodoro_is_break:
            # Break is over, start next work session
            self.pomodoro_is_break = False
            if notify_mode in ("sound", "both"):
                self._play_notification_sound()
            self._show_desktop_notification(
                "‚è∞ Break Over!",
                f"Break time is over!\nReady for another focus session?"
            )
            self.blocker.unblock_sites(force=True)

            if show_question(
                self, "Break Over! üçÖ",
                f"Break time is over!\n\n"
                f"Sessions completed: {self.pomodoro_session_count}\n"
                f"Total focus time: {self.pomodoro_total_work_time // 60} min\n\n"
                "Ready for another focus session?"
            ) == QtWidgets.QMessageBox.Yes:
                self._start_pomodoro_work()
            else:
                self._end_pomodoro_session()
        else:
            # Work session completed
            self.pomodoro_session_count += 1
            self.pomodoro_total_work_time += elapsed
            self.blocker.update_stats(elapsed, completed=True)
            if notify_mode in ("sound", "both"):
                self._play_notification_sound()
            
            # Show desktop notification
            session_minutes = elapsed // 60
            self._show_desktop_notification(
                f"üçÖ Pomodoro #{self.pomodoro_session_count} Complete!",
                f"Great work! You focused for {session_minutes} minutes.\nTime for a break!"
            )
            self.blocker.unblock_sites(force=True)

            # Give rewards for completing work session
            # Note: _give_session_rewards already includes entitidex encounter check
            if session_minutes > 0:
                self._give_session_rewards(session_minutes)

            # Determine break length
            sessions_before_long = self.blocker.pomodoro_sessions_before_long
            if self.pomodoro_session_count % sessions_before_long == 0:
                break_minutes = self.blocker.pomodoro_long_break
                break_type = "Long Break"
            else:
                break_minutes = self.blocker.pomodoro_break
                break_type = "Short Break"

            if show_question(
                self, f"Work Complete! üçÖ {break_type}",
                f"Great work! Session #{self.pomodoro_session_count} complete!\n\n"
                f"Time for a {break_minutes}-minute {break_type.lower()}.\n\n"
                "Start break timer?"
            ) == QtWidgets.QMessageBox.Yes:
                self._start_pomodoro_break(break_minutes)
            else:
                self._end_pomodoro_session()

    def _start_pomodoro_work(self) -> None:
        """Start a Pomodoro work session."""
        work_minutes = self.blocker.pomodoro_work
        total_seconds = work_minutes * 60

        success, message = self.blocker.block_sites(duration_seconds=total_seconds)
        if not success:
            show_error(self, "Blocking Failed", message)
            self._end_pomodoro_session()
            return

        self.remaining_seconds = total_seconds
        self.session_total_seconds = total_seconds  # Store for progress calculation
        self.timer_running = True
        self.session_start = QtCore.QDateTime.currentDateTime().toSecsSinceEpoch()
        self.pomodoro_is_break = False
        self.last_checkin_time = None

        self.timer_label.setText(self._format_time(self.remaining_seconds))
        self._set_action_btn_stop_style()
        self.status_label.setText(f"üçÖ WORK #{self.pomodoro_session_count + 1}")
        self.qt_timer.start()
        
        # Emit session started signal
        self.session_started.emit()

    def _start_pomodoro_break(self, break_minutes: int) -> None:
        """Start a Pomodoro break period."""
        total_seconds = break_minutes * 60

        self.remaining_seconds = total_seconds
        self.session_total_seconds = total_seconds  # Store for progress calculation
        self.timer_running = True
        self.session_start = QtCore.QDateTime.currentDateTime().toSecsSinceEpoch()
        self.pomodoro_is_break = True

        self.timer_label.setText(self._format_time(self.remaining_seconds))
        self.status_label.setText("‚òï BREAK")
        self.qt_timer.start()
        
        # Emit session started signal (breaks also lock controls)
        self.session_started.emit()

    def _end_pomodoro_session(self) -> None:
        """End the Pomodoro session completely."""
        session_minutes = self.pomodoro_total_work_time // 60

        self.timer_running = False
        self.qt_timer.stop()
        self.remaining_seconds = 0
        self.timer_label.setText("00:00:00")
        self._set_action_btn_start_style()
        self.pomodoro_is_break = False

        # Update tray icon to ready state
        main_window = self.window()
        if hasattr(main_window, '_update_tray_icon'):
            main_window._update_tray_icon(blocking=False)

        if self.pomodoro_session_count > 0:
            self.status_label.setText(
                f"üçÖ Done! {self.pomodoro_session_count} sessions, "
                f"{self.pomodoro_total_work_time // 60} min"
            )
            if session_minutes > 0:
                self._show_priority_time_log(session_minutes)
        else:
            self.status_label.setText("Ready to focus")

        # Emit session complete signal to refresh stats
        if session_minutes > 0:
            self.session_complete.emit(session_minutes * 60)

        self.pomodoro_session_count = 0
        self.pomodoro_total_work_time = 0

    def _force_stop_session(self) -> None:
        """Force stop the session without password check (for app exit)."""
        elapsed = 0
        if self.session_start:
            elapsed = int(QtCore.QDateTime.currentDateTime().toSecsSinceEpoch() - self.session_start)

        self.timer_running = False
        self.qt_timer.stop()
        self.remaining_seconds = 0
        self.timer_label.setText("00:00:00")
        self._set_action_btn_start_style()
        self.status_label.setText("Ready to focus")
        self.pomodoro_is_break = False
        self.pomodoro_session_count = 0
        self.pomodoro_total_work_time = 0

        # Update tray icon to ready state
        main_window = self.window()
        if hasattr(main_window, '_update_tray_icon'):
            main_window._update_tray_icon(blocking=False)

        # Unblock sites
        self.blocker.unblock_sites()

        # Record stats if ran > 60s
        if elapsed > 60:
            self.blocker.update_stats(elapsed, completed=False)
            self.session_complete.emit(elapsed)


class SitesTab(QtWidgets.QWidget):
    """Sites management tab - blacklist and whitelist."""

    def __init__(self, blocker: BlockerCore, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.blocker = blocker
        self.analyzer = ProductivityAnalyzer(blocker.stats_path) if ProductivityAnalyzer else None
        self.gamification = GamificationEngine(blocker.stats_path) if GamificationEngine else None
        self.focus_goals = FocusGoals(blocker.goals_path, blocker.stats_path) if FocusGoals else None
        self._build_ui()
        self._refresh_lists()

    def _build_ui(self) -> None:
        layout = QtWidgets.QVBoxLayout(self)

        # Help button (moves to bottom after read)
        add_tab_help_button(layout, "sites", self)

        # Blacklist section
        black_group = QtWidgets.QGroupBox("Blocked Sites (Custom)")
        black_layout = QtWidgets.QVBoxLayout(black_group)
        self.black_list = QtWidgets.QListWidget()
        self.black_list.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        black_layout.addWidget(self.black_list)

        black_input_layout = QtWidgets.QHBoxLayout()
        self.black_entry = QtWidgets.QLineEdit()
        self.black_entry.setPlaceholderText("Enter site to block...")
        self.black_entry.returnPressed.connect(self._add_black)
        black_input_layout.addWidget(self.black_entry)
        add_black_btn = QtWidgets.QPushButton("+ Add")
        add_black_btn.clicked.connect(self._add_black)
        black_input_layout.addWidget(add_black_btn)
        rem_black_btn = QtWidgets.QPushButton("- Remove")
        rem_black_btn.clicked.connect(self._remove_black)
        black_input_layout.addWidget(rem_black_btn)
        black_layout.addLayout(black_input_layout)
        layout.addWidget(black_group)

        # Whitelist section
        white_group = QtWidgets.QGroupBox("Whitelist (Never Block)")
        white_layout = QtWidgets.QVBoxLayout(white_group)
        self.white_list = QtWidgets.QListWidget()
        white_layout.addWidget(self.white_list)

        white_input_layout = QtWidgets.QHBoxLayout()
        self.white_entry = QtWidgets.QLineEdit()
        self.white_entry.setPlaceholderText("Enter site to whitelist...")
        self.white_entry.returnPressed.connect(self._add_white)
        white_input_layout.addWidget(self.white_entry)
        add_white_btn = QtWidgets.QPushButton("+ Add")
        add_white_btn.clicked.connect(self._add_white)
        white_input_layout.addWidget(add_white_btn)
        rem_white_btn = QtWidgets.QPushButton("- Remove")
        rem_white_btn.clicked.connect(self._remove_white)
        white_input_layout.addWidget(rem_white_btn)
        white_layout.addLayout(white_input_layout)
        layout.addWidget(white_group)

        # Import/Export buttons
        io_layout = QtWidgets.QHBoxLayout()
        import_btn = QtWidgets.QPushButton("üì• Import")
        import_btn.clicked.connect(self._import_sites)
        io_layout.addWidget(import_btn)
        export_btn = QtWidgets.QPushButton("üì§ Export")
        export_btn.clicked.connect(self._export_sites)
        io_layout.addWidget(export_btn)
        io_layout.addStretch()
        layout.addLayout(io_layout)

    def _refresh_lists(self) -> None:
        self.black_list.clear()
        for site in sorted(self.blocker.blacklist):
            self.black_list.addItem(site)
        self.white_list.clear()
        for site in sorted(self.blocker.whitelist):
            self.white_list.addItem(site)

    def _add_black(self) -> None:
        site = self.black_entry.text().strip()
        if site and self.blocker.add_site(site):
            self._refresh_lists()
            self.black_entry.clear()

    def _remove_black(self) -> None:
        for item in self.black_list.selectedItems():
            self.blocker.remove_site(item.text())
        self._refresh_lists()

    def _add_white(self) -> None:
        site = self.white_entry.text().strip()
        if site and self.blocker.add_to_whitelist(site):
            self._refresh_lists()
            self.white_entry.clear()

    def _remove_white(self) -> None:
        for item in self.white_list.selectedItems():
            self.blocker.remove_from_whitelist(item.text())
        self._refresh_lists()

    def _import_sites(self) -> None:
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Import Sites", "", "JSON Files (*.json)")
        if path and self.blocker.import_config(path):
            self._refresh_lists()
            show_info(self, "Import", "Sites imported successfully!")

    def _export_sites(self) -> None:
        path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Export Sites", "", "JSON Files (*.json)")
        if path and self.blocker.export_config(path):
            show_info(self, "Export", "Sites exported successfully!")


class CategoriesTab(QtWidgets.QWidget):
    """Categories tab - toggle entire categories of sites."""

    def __init__(self, blocker: BlockerCore, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.blocker = blocker
        self.category_checks: Dict[str, QtWidgets.QCheckBox] = {}
        self._build_ui()

    def _build_ui(self) -> None:
        layout = QtWidgets.QVBoxLayout(self)
        
        layout.addWidget(QtWidgets.QLabel("Enable/disable entire categories of sites:"))
        add_tab_help_button(layout, "categories", self)

        scroll = QtWidgets.QScrollArea()
        scroll.setWidgetResizable(True)
        container = QtWidgets.QWidget()
        cat_layout = QtWidgets.QVBoxLayout(container)

        for category, sites in SITE_CATEGORIES.items():
            row = QtWidgets.QHBoxLayout()
            cb = QtWidgets.QCheckBox(f"{category} ({len(sites)} sites)")
            cb.setChecked(self.blocker.categories_enabled.get(category, True))
            cb.stateChanged.connect(lambda state, c=category: self._toggle(c, state))
            self.category_checks[category] = cb
            row.addWidget(cb)
            view_btn = QtWidgets.QPushButton("View")
            view_btn.setFixedWidth(60)
            view_btn.clicked.connect(lambda _, c=category: self._show_sites(c))
            row.addWidget(view_btn)
            row.addStretch()
            cat_layout.addLayout(row)

        cat_layout.addStretch()
        scroll.setWidget(container)
        layout.addWidget(scroll)

        self.total_label = QtWidgets.QLabel()
        layout.addWidget(self.total_label)
        self._update_total()

    def _toggle(self, category: str, state: int) -> None:
        self.blocker.categories_enabled[category] = (state == QtCore.Qt.Checked)
        self.blocker.save_config()
        self._update_total()

    def _show_sites(self, category: str) -> None:
        sites = SITE_CATEGORIES.get(category, [])
        text = "\n".join(sorted(set(s.replace("www.", "") for s in sites)))
        show_info(self, f"{category} Sites", text)

    def refresh(self) -> None:
        """Refresh checkboxes from blocker config."""
        for category, cb in self.category_checks.items():
            cb.setChecked(self.blocker.categories_enabled.get(category, True))
        self._update_total()

    def _update_total(self) -> None:
        total = len(self.blocker.get_effective_blacklist())
        self.total_label.setText(f"Total sites to block: {total}")


class ScheduleTab(QtWidgets.QWidget):
    """Schedule tab - automatic blocking schedules."""

    def __init__(self, blocker: BlockerCore, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.blocker = blocker
        self._build_ui()
        self._refresh_table()

    def _build_ui(self) -> None:
        layout = QtWidgets.QVBoxLayout(self)
        
        layout.addWidget(QtWidgets.QLabel("Automatic blocking schedules:"))
        add_tab_help_button(layout, "schedule", self)

        # Schedule table
        self.table = QtWidgets.QTableWidget(0, 3)
        self.table.setHorizontalHeaderLabels(["Days", "Time", "Status"])
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        layout.addWidget(self.table)

        # Add schedule form
        add_group = QtWidgets.QGroupBox("Add Schedule")
        add_layout = QtWidgets.QVBoxLayout(add_group)

        days_layout = QtWidgets.QHBoxLayout()
        days_layout.addWidget(QtWidgets.QLabel("Days:"))
        self.day_checks: list[QtWidgets.QCheckBox] = []
        day_names = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        for i, name in enumerate(day_names):
            cb = QtWidgets.QCheckBox(name)
            cb.setChecked(i < 5)  # default weekdays
            self.day_checks.append(cb)
            days_layout.addWidget(cb)
        days_layout.addStretch()
        add_layout.addLayout(days_layout)

        time_layout = QtWidgets.QHBoxLayout()
        time_layout.addWidget(QtWidgets.QLabel("From:"))
        self.start_time = QtWidgets.QTimeEdit(QtCore.QTime(9, 0))
        time_layout.addWidget(self.start_time)
        time_layout.addWidget(QtWidgets.QLabel("To:"))
        self.end_time = QtWidgets.QTimeEdit(QtCore.QTime(17, 0))
        time_layout.addWidget(self.end_time)
        time_layout.addStretch()
        add_layout.addLayout(time_layout)

        add_btn = QtWidgets.QPushButton("+ Add Schedule")
        add_btn.clicked.connect(self._add_schedule)
        add_layout.addWidget(add_btn)
        layout.addWidget(add_group)

        # Actions
        action_layout = QtWidgets.QHBoxLayout()
        toggle_btn = QtWidgets.QPushButton("Toggle")
        toggle_btn.clicked.connect(self._toggle_schedule)
        action_layout.addWidget(toggle_btn)
        delete_btn = QtWidgets.QPushButton("Delete")
        delete_btn.clicked.connect(self._delete_schedule)
        action_layout.addWidget(delete_btn)
        action_layout.addStretch()
        layout.addLayout(action_layout)

    def _refresh_table(self) -> None:
        self.table.setRowCount(0)
        day_names = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        for sched in self.blocker.schedules:
            row = self.table.rowCount()
            self.table.insertRow(row)
            days_str = ", ".join(day_names[d] for d in sorted(sched.get("days", [])))
            time_str = f"{sched.get('start_time', '')} - {sched.get('end_time', '')}"
            status = "‚úÖ Active" if sched.get("enabled", True) else "‚è∏ Paused"
            self.table.setItem(row, 0, QtWidgets.QTableWidgetItem(days_str))
            self.table.setItem(row, 1, QtWidgets.QTableWidgetItem(time_str))
            self.table.setItem(row, 2, QtWidgets.QTableWidgetItem(status))
            # Store schedule id
            self.table.item(row, 0).setData(QtCore.Qt.UserRole, sched["id"])

    def _add_schedule(self) -> None:
        days = [i for i, cb in enumerate(self.day_checks) if cb.isChecked()]
        if not days:
            show_warning(self, "No Days Selected", "Please select at least one day for the schedule.")
            return
        start = self.start_time.time().toString("HH:mm")
        end = self.end_time.time().toString("HH:mm")
        self.blocker.add_schedule(days, start, end)
        self._refresh_table()

    def _selected_id(self) -> Optional[str]:
        row = self.table.currentRow()
        if row < 0:
            return None
        item = self.table.item(row, 0)
        return item.data(QtCore.Qt.UserRole) if item else None

    def _toggle_schedule(self) -> None:
        sid = self._selected_id()
        if sid:
            self.blocker.toggle_schedule(sid)
            self._refresh_table()

    def _delete_schedule(self) -> None:
        sid = self._selected_id()
        if sid:
            self.blocker.remove_schedule(sid)
            self._refresh_table()


# ============================================================================
# PRODUCTIVITY ANALYTICS WIDGETS
# ============================================================================

class HourlyTimelineWidget(QtWidgets.QWidget):
    """
    Custom widget that renders a 24-hour timeline showing focus time distribution.
    Uses heatmap-style coloring with hour labels at 00:00-24:00.
    """
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.hourly_data = [0.0] * 24  # Average minutes per hour
        self.setMinimumHeight(80)
        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
    
    def set_data(self, hourly_data: list):
        """Set the hourly data (list of 24 floats representing avg minutes per hour)."""
        self.hourly_data = hourly_data[:24] if len(hourly_data) >= 24 else hourly_data + [0.0] * (24 - len(hourly_data))
        self.update()
    
    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        
        rect = self.rect()
        margin_left = 30
        margin_right = 10
        margin_top = 15
        margin_bottom = 25
        
        chart_left = margin_left
        chart_right = rect.width() - margin_right
        chart_top = margin_top
        chart_bottom = rect.height() - margin_bottom
        chart_width = chart_right - chart_left
        chart_height = chart_bottom - chart_top
        
        if chart_width < 50 or chart_height < 20:
            return
        
        # Background
        painter.fillRect(rect, QtGui.QColor("#333333"))
        
        # Find max value for scaling
        max_val = max(self.hourly_data) if max(self.hourly_data) > 0 else 1
        
        # Draw bars
        bar_width = chart_width / 24
        for hour, value in enumerate(self.hourly_data):
            x = chart_left + hour * bar_width
            
            # Calculate bar height
            bar_height = (value / max_val) * chart_height if max_val > 0 else 0
            
            # Calculate color intensity (gradient from dark to bright cyan/green)
            intensity = value / max_val if max_val > 0 else 0
            if intensity > 0.8:
                color = QtGui.QColor("#10b981")  # Bright green for peak
            elif intensity > 0.6:
                color = QtGui.QColor("#34d399")  # Medium green
            elif intensity > 0.4:
                color = QtGui.QColor("#6ee7b7")  # Light green
            elif intensity > 0.2:
                color = QtGui.QColor("#99f6e4")  # Very light cyan
            elif intensity > 0:
                color = QtGui.QColor("#5eead4")  # Light cyan
            else:
                color = QtGui.QColor("#374151")  # Dark gray for zero
            
            # Draw bar
            bar_rect = QtCore.QRectF(x + 1, chart_bottom - bar_height, bar_width - 2, bar_height)
            painter.fillRect(bar_rect, color)
            
            # Draw subtle border
            painter.setPen(QtGui.QPen(QtGui.QColor("#555"), 0.5))
            painter.drawRect(bar_rect)
        
        # Draw hour labels (every 3 hours)
        painter.setPen(QtGui.QColor("#9ca3af"))
        painter.setFont(QtGui.QFont("Arial", 8))
        for hour in range(0, 25, 3):
            x = chart_left + hour * bar_width
            if hour < 24:
                label = f"{hour:02d}"
            else:
                label = "24"
                x = chart_right
            painter.drawText(int(x - 8), chart_bottom + 15, label)
        
        # Draw "00:00" and "24:00" labels at edges
        painter.drawText(chart_left - 5, chart_bottom + 15, "00")
        
        # Draw Y-axis labels (max value)
        painter.setPen(QtGui.QColor("#6b7280"))
        if max_val > 0:
            painter.drawText(2, chart_top + 10, f"{int(max_val)}m")
        painter.drawText(2, chart_bottom, "0m")
        
        # Draw horizontal grid line at top
        painter.setPen(QtGui.QPen(QtGui.QColor("#444"), 1, QtCore.Qt.DashLine))
        painter.drawLine(chart_left, chart_top, chart_right, chart_top)


class DayOfWeekPatternWidget(QtWidgets.QWidget):
    """
    Custom widget showing day-of-week patterns with confidence intervals.
    Displays bars for each day with error bars showing 95% CI.
    """
    
    def __init__(self, parent=None):
        super().__init__(parent)
        # Data: [(mean, lower_ci, upper_ci) for each day Mon-Sun]
        self.dow_data = [(0.0, 0.0, 0.0)] * 7
        self.day_names = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        self.setMinimumHeight(120)
        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
    
    def set_data(self, dow_data: list):
        """Set day-of-week data: list of 7 tuples (mean, lower_ci, upper_ci)."""
        self.dow_data = dow_data[:7] if len(dow_data) >= 7 else dow_data + [(0.0, 0.0, 0.0)] * (7 - len(dow_data))
        self.update()
    
    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        
        rect = self.rect()
        margin_left = 35
        margin_right = 10
        margin_top = 15
        margin_bottom = 30
        
        chart_left = margin_left
        chart_right = rect.width() - margin_right
        chart_top = margin_top
        chart_bottom = rect.height() - margin_bottom
        chart_width = chart_right - chart_left
        chart_height = chart_bottom - chart_top
        
        if chart_width < 50 or chart_height < 30:
            return
        
        # Background
        painter.fillRect(rect, QtGui.QColor("#333333"))
        
        # Find max value for scaling (use upper CI bounds)
        max_val = max(d[2] for d in self.dow_data) if any(d[2] > 0 for d in self.dow_data) else 60
        max_val = max(max_val, 10)  # Minimum scale of 10 minutes
        
        # Draw bars with confidence intervals
        bar_width = chart_width / 7
        bar_inner_width = bar_width * 0.6
        
        for day_idx, (mean, lower_ci, upper_ci) in enumerate(self.dow_data):
            center_x = chart_left + day_idx * bar_width + bar_width / 2
            bar_left = center_x - bar_inner_width / 2
            
            # Calculate heights
            mean_height = (mean / max_val) * chart_height if max_val > 0 else 0
            lower_height = (lower_ci / max_val) * chart_height if max_val > 0 else 0
            upper_height = (upper_ci / max_val) * chart_height if max_val > 0 else 0
            
            # Determine bar color (gradient based on value)
            intensity = mean / max_val if max_val > 0 else 0
            if intensity > 0.8:
                bar_color = QtGui.QColor("#8b5cf6")  # Purple for highest
            elif intensity > 0.6:
                bar_color = QtGui.QColor("#a78bfa")
            elif intensity > 0.4:
                bar_color = QtGui.QColor("#c4b5fd")
            elif intensity > 0.2:
                bar_color = QtGui.QColor("#6366f1")  # Indigo
            else:
                bar_color = QtGui.QColor("#4f46e5")  # Darker indigo
            
            # Draw confidence interval (error bar)
            if upper_ci > lower_ci:
                ci_x = int(center_x)
                ci_top = int(chart_bottom - upper_height)
                ci_bottom = int(chart_bottom - lower_height)
                
                # Vertical line
                painter.setPen(QtGui.QPen(QtGui.QColor("#6b7280"), 2))
                painter.drawLine(ci_x, ci_top, ci_x, ci_bottom)
                
                # Horizontal caps
                cap_width = 4
                painter.drawLine(ci_x - cap_width, ci_top, ci_x + cap_width, ci_top)
                painter.drawLine(ci_x - cap_width, ci_bottom, ci_x + cap_width, ci_bottom)
            
            # Draw main bar
            bar_rect = QtCore.QRectF(bar_left, chart_bottom - mean_height, bar_inner_width, mean_height)
            painter.fillRect(bar_rect, bar_color)
            painter.setPen(QtGui.QPen(QtGui.QColor("#fff"), 0.5))
            painter.drawRect(bar_rect)
            
            # Draw value on top of bar
            if mean > 0:
                painter.setPen(QtGui.QColor("#e5e7eb"))
                painter.setFont(QtGui.QFont("Arial", 8, QtGui.QFont.Bold))
                value_text = f"{int(mean)}m" if mean < 60 else f"{mean/60:.1f}h"
                text_rect = QtCore.QRectF(bar_left - 5, chart_bottom - mean_height - 15, bar_inner_width + 10, 15)
                painter.drawText(text_rect, QtCore.Qt.AlignCenter, value_text)
        
        # Draw day labels
        painter.setPen(QtGui.QColor("#9ca3af"))
        painter.setFont(QtGui.QFont("Arial", 9))
        for day_idx, day_name in enumerate(self.day_names):
            center_x = chart_left + day_idx * bar_width + bar_width / 2
            text_rect = QtCore.QRectF(center_x - 20, chart_bottom + 5, 40, 20)
            painter.drawText(text_rect, QtCore.Qt.AlignCenter, day_name)
        
        # Draw Y-axis labels
        painter.setPen(QtGui.QColor("#6b7280"))
        painter.setFont(QtGui.QFont("Arial", 8))
        if max_val >= 60:
            painter.drawText(2, chart_top + 10, f"{max_val/60:.1f}h")
        else:
            painter.drawText(2, chart_top + 10, f"{int(max_val)}m")
        painter.drawText(2, chart_bottom, "0")
        
        # Draw horizontal grid lines
        painter.setPen(QtGui.QPen(QtGui.QColor("#444"), 1, QtCore.Qt.DashLine))
        painter.drawLine(chart_left, chart_top, chart_right, chart_top)
        mid_y = chart_top + chart_height / 2
        painter.drawLine(chart_left, int(mid_y), chart_right, int(mid_y))


class StatsTab(QtWidgets.QWidget):
    """Statistics tab - focus time, sessions, streaks, weekly chart."""

    def __init__(self, blocker: BlockerCore, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.blocker = blocker
        self._build_ui()
        self.refresh()

    def _build_ui(self) -> None:
        layout = QtWidgets.QVBoxLayout(self)
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)

        scroll = QtWidgets.QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("""
            QScrollArea {
                border: none;
                background: transparent;
            }
        """)
        container = QtWidgets.QWidget()
        inner = QtWidgets.QVBoxLayout(container)
        inner.setSpacing(20)

        # Header row with title and help button
        title = QtWidgets.QLabel("üìä Focus Statistics")
        title.setFont(QtGui.QFont("Arial", 16, QtGui.QFont.Bold))
        title.setStyleSheet("""
            QLabel {
                color: #a5b4fc;
                padding: 8px;
                margin-bottom: 8px;
            }
        """)
        inner.addWidget(title)
        add_tab_help_button(inner, "stats", self)

        # AGI Assistant Chad Tips Section - hidden by default until entity is unlocked
        self.chad_tips_section = QtWidgets.QGroupBox()
        self.chad_tips_section.setStyleSheet("""
            QGroupBox {
                background: #2a2a2a;
                border: 1px solid #3d3d3d;
                border-radius: 8px;
                padding: 16px;
                margin-top: 8px;
            }
        """)
        self.chad_tips_section.setVisible(False)  # Hidden until entity is unlocked
        
        chad_layout = QtWidgets.QVBoxLayout(self.chad_tips_section)
        chad_layout.setSpacing(12)
        
        # Chad section title
        self.chad_section_title = QtWidgets.QLabel("ü§ñ AGI Assistant Productivity Tips")
        self.chad_section_title.setFont(QtGui.QFont("Arial", 12, QtGui.QFont.Bold))
        self.chad_section_title.setStyleSheet("color: #a5b4fc; padding: 4px;")
        chad_layout.addWidget(self.chad_section_title)
        
        # Entity card container (icon + name)
        chad_card_container = QtWidgets.QHBoxLayout()
        chad_card_container.setSpacing(12)
        
        # Entity icon (48x48)
        self.chad_icon_label = QtWidgets.QLabel()
        self.chad_icon_label.setFixedSize(48, 48)
        self.chad_icon_label.setAlignment(QtCore.Qt.AlignCenter)
        self.chad_icon_label.setStyleSheet("""
            QLabel {
                background: #333;
                border: 1px solid #444;
                border-radius: 6px;
            }
        """)
        chad_card_container.addWidget(self.chad_icon_label)
        
        # Entity name and tip number
        chad_info = QtWidgets.QVBoxLayout()
        self.chad_entity_name = QtWidgets.QLabel("AGI Assistant Chad")
        self.chad_entity_name.setStyleSheet("color: #9ca3af; font-size: 10px;")
        chad_info.addWidget(self.chad_entity_name)
        
        self.chad_tip_number = QtWidgets.QLabel("Tip #1 of 100")
        self.chad_tip_number.setStyleSheet("color: #9ca3af; font-size: 10px;")
        self.chad_tip_number.hide()  # Hidden - tip number not important
        chad_info.addWidget(self.chad_tip_number)
        
        chad_card_container.addLayout(chad_info)
        chad_card_container.addStretch()
        chad_layout.addLayout(chad_card_container)
        
        # Tip text display
        self.chad_tip_text = QtWidgets.QLabel("")
        self.chad_tip_text.setWordWrap(True)
        self.chad_tip_text.setStyleSheet("""
            QLabel {
                background: #333;
                border: 1px solid #444;
                border-radius: 6px;
                padding: 14px;
                color: #f0f0f0;
                font-size: 14px;
                line-height: 1.5;
            }
        """)
        chad_layout.addWidget(self.chad_tip_text)
        
        # Acknowledge button
        self.chad_acknowledge_btn = QtWidgets.QPushButton("‚úì Got it! (+1 ü™ô)")
        self.chad_acknowledge_btn.setStyleSheet("""
            QPushButton {
                background: #4ade80;
                color: #1a1a1a;
                border: none;
                border-radius: 4px;
                padding: 10px 18px;
                font-weight: 600;
                font-size: 11px;
            }
            QPushButton:hover {
                background: #22c55e;
            }
            QPushButton:disabled {
                background: #3d3d3d;
                color: #888;
            }
        """)
        self.chad_acknowledge_btn.clicked.connect(self._acknowledge_chad_tip)
        chad_layout.addWidget(self.chad_acknowledge_btn)
        
        inner.addWidget(self.chad_tips_section)

        # Overview cards - dark theme
        overview_group = QtWidgets.QGroupBox()
        overview_group.setStyleSheet("""
            QGroupBox {
                background: #2a2a2a;
                border: 1px solid #3d3d3d;
                border-radius: 8px;
                padding: 16px;
                margin-top: 8px;
            }
        """)
        overview_layout = QtWidgets.QGridLayout(overview_group)
        overview_layout.setSpacing(12)
        
        # Create stat cards - dark theme
        def create_stat_card(icon: str, label_text: str, value_widget, color: str) -> QtWidgets.QWidget:
            card = QtWidgets.QFrame()
            card.setStyleSheet(f"""
                QFrame {{
                    background: #333333;
                    border: 1px solid #444444;
                    border-radius: 8px;
                    padding: 12px;
                }}
            """)
            card_layout = QtWidgets.QVBoxLayout(card)
            card_layout.setSpacing(6)
            
            label = QtWidgets.QLabel(f"{icon} {label_text}")
            label.setFont(QtGui.QFont("Arial", 9))
            label.setStyleSheet("color: #9ca3af; font-weight: 500;")
            card_layout.addWidget(label)
            
            value_widget.setFont(QtGui.QFont("Arial", 20, QtGui.QFont.Bold))
            value_widget.setStyleSheet(f"color: #e5e7eb; padding: 4px;")
            value_widget.setAlignment(QtCore.Qt.AlignCenter)
            card_layout.addWidget(value_widget)
            
            return card
        
        self.total_hours_lbl = QtWidgets.QLabel("0h")
        self.sessions_lbl = QtWidgets.QLabel("0")
        self.streak_lbl = QtWidgets.QLabel("0 days")
        self.best_streak_lbl = QtWidgets.QLabel("0 days")
        
        overview_layout.addWidget(
            create_stat_card("‚è±Ô∏è", "Total Focus Time", self.total_hours_lbl, "#2196f3"), 0, 0
        )
        overview_layout.addWidget(
            create_stat_card("‚úÖ", "Sessions Completed", self.sessions_lbl, "#4caf50"), 0, 1
        )
        overview_layout.addWidget(
            create_stat_card("üî•", "Current Streak", self.streak_lbl, "#ff9800"), 1, 0
        )
        overview_layout.addWidget(
            create_stat_card("üèÜ", "Best Streak", self.best_streak_lbl, "#9c27b0"), 1, 1
        )
        inner.addWidget(overview_group)

        # Focus goals dashboard - dark theme
        goals_group = QtWidgets.QGroupBox()
        goals_group.setStyleSheet("""
            QGroupBox {
                background: #2a2a2a;
                border: 1px solid #3d3d3d;
                border-radius: 8px;
                padding: 16px;
                margin-top: 8px;
            }
        """)
        goals_layout = QtWidgets.QVBoxLayout(goals_group)
        goals_layout.setSpacing(12)
        
        # Goals title
        goals_title = QtWidgets.QLabel("üéØ Focus Goals")
        goals_title.setFont(QtGui.QFont("Arial", 12, QtGui.QFont.Bold))
        goals_title.setStyleSheet("color: #a5b4fc; padding: 4px;")
        goals_layout.addWidget(goals_title)

        # Weekly goal - dark theme
        weekly_card = QtWidgets.QFrame()
        weekly_card.setStyleSheet("""
            QFrame {
                background: #333333;
                border: 1px solid #444444;
                border-radius: 6px;
                padding: 10px;
            }
        """)
        weekly_layout = QtWidgets.QVBoxLayout(weekly_card)
        weekly_layout.setSpacing(6)
        
        weekly_label = QtWidgets.QLabel("üìÖ Weekly Goal")
        weekly_label.setFont(QtGui.QFont("Arial", 10, QtGui.QFont.Bold))
        weekly_label.setStyleSheet("color: #93c5fd;")
        weekly_layout.addWidget(weekly_label)
        
        self.weekly_bar = QtWidgets.QProgressBar()
        self.weekly_bar.setMaximum(100)
        self.weekly_bar.setTextVisible(True)
        self.weekly_bar.setStyleSheet("""
            QProgressBar {
                border: 1px solid #4a4a4a;
                border-radius: 4px;
                text-align: center;
                background: #2a2a2a;
                height: 24px;
                color: #e5e7eb;
            }
            QProgressBar::chunk {
                background: #6366f1;
                border-radius: 3px;
            }
        """)
        weekly_layout.addWidget(self.weekly_bar)
        
        weekly_controls = QtWidgets.QHBoxLayout()
        target_lbl = QtWidgets.QLabel("Target:")
        target_lbl.setStyleSheet("color: #9ca3af;")
        weekly_controls.addWidget(target_lbl)
        self.weekly_target = NoScrollDoubleSpinBox()
        self.weekly_target.setRange(1, 200)
        self.weekly_target.setSuffix(" h")
        self.weekly_target.setStyleSheet("""
            QDoubleSpinBox {
                border: 1px solid #4a4a4a;
                border-radius: 4px;
                padding: 4px;
                min-width: 80px;
                background: #2a2a2a;
                color: #e5e7eb;
            }
        """)
        try:
            self.weekly_target.setValue(float(self.blocker.stats.get("weekly_goal_hours", 10)))
        except (ValueError, TypeError):
            self.weekly_target.setValue(10.0)
        weekly_controls.addWidget(self.weekly_target)
        
        weekly_set = QtWidgets.QPushButton("Set Goal")
        weekly_set.setStyleSheet("""
            QPushButton {
                background: #6366f1;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 6px 14px;
                font-weight: 500;
            }
            QPushButton:hover {
                background: #4f46e5;
            }
        """)
        weekly_set.clicked.connect(self._set_weekly_goal)
        weekly_controls.addWidget(weekly_set)
        weekly_controls.addStretch()
        weekly_layout.addLayout(weekly_controls)
        goals_layout.addWidget(weekly_card)

        # Monthly goal - dark theme
        monthly_card = QtWidgets.QFrame()
        monthly_card.setStyleSheet("""
            QFrame {
                background: #333333;
                border: 1px solid #444444;
                border-radius: 6px;
                padding: 10px;
            }
        """)
        monthly_layout = QtWidgets.QVBoxLayout(monthly_card)
        monthly_layout.setSpacing(6)
        
        monthly_label = QtWidgets.QLabel("üìÜ Monthly Goal")
        monthly_label.setFont(QtGui.QFont("Arial", 10, QtGui.QFont.Bold))
        monthly_label.setStyleSheet("color: #c4b5fd;")
        monthly_layout.addWidget(monthly_label)
        
        self.monthly_bar = QtWidgets.QProgressBar()
        self.monthly_bar.setMaximum(100)
        self.monthly_bar.setTextVisible(True)
        self.monthly_bar.setStyleSheet("""
            QProgressBar {
                border: 1px solid #4a4a4a;
                border-radius: 4px;
                text-align: center;
                background: #2a2a2a;
                height: 24px;
                color: #e5e7eb;
            }
            QProgressBar::chunk {
                background: #8b5cf6;
                border-radius: 3px;
            }
        """)
        monthly_layout.addWidget(self.monthly_bar)
        
        monthly_controls = QtWidgets.QHBoxLayout()
        target_lbl2 = QtWidgets.QLabel("Target:")
        target_lbl2.setStyleSheet("color: #9ca3af;")
        monthly_controls.addWidget(target_lbl2)
        self.monthly_target = NoScrollDoubleSpinBox()
        self.monthly_target.setRange(1, 1000)
        self.monthly_target.setSuffix(" h")
        self.monthly_target.setStyleSheet("""
            QDoubleSpinBox {
                border: 1px solid #4a4a4a;
                border-radius: 4px;
                padding: 4px;
                min-width: 80px;
                background: #2a2a2a;
                color: #e5e7eb;
            }
        """)
        try:
            self.monthly_target.setValue(float(self.blocker.stats.get("monthly_goal_hours", 40)))
        except (ValueError, TypeError):
            self.monthly_target.setValue(40.0)
        monthly_controls.addWidget(self.monthly_target)
        
        monthly_set = QtWidgets.QPushButton("Set Goal")
        monthly_set.setStyleSheet("""
            QPushButton {
                background: #8b5cf6;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 6px 14px;
                font-weight: 500;
            }
            QPushButton:hover {
                background: #7c3aed;
            }
        """)
        monthly_set.clicked.connect(self._set_monthly_goal)
        monthly_controls.addWidget(monthly_set)
        monthly_controls.addStretch()
        monthly_layout.addLayout(monthly_controls)
        goals_layout.addWidget(monthly_card)

        inner.addWidget(goals_group)

        # Weekly chart - dark theme
        week_group = QtWidgets.QGroupBox()
        week_group.setStyleSheet("""
            QGroupBox {
                background: #2a2a2a;
                border: 1px solid #3d3d3d;
                border-radius: 8px;
                padding: 12px;
                margin-top: 8px;
            }
        """)
        week_layout = QtWidgets.QVBoxLayout(week_group)
        week_layout.setSpacing(6)
        
        week_title = QtWidgets.QLabel("üìä Weekly Focus Time")
        week_title.setFont(QtGui.QFont("Arial", 11, QtGui.QFont.Bold))
        week_title.setStyleSheet("color: #a5b4fc; padding: 0px 0px 4px 0px;")
        week_layout.addWidget(week_title)
        
        # Store weekly progress bars
        self.week_bars = {}
        days = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        for day in days:
            day_layout = QtWidgets.QHBoxLayout()
            day_layout.setSpacing(8)
            
            day_label = QtWidgets.QLabel(day)
            day_label.setFixedWidth(35)
            day_label.setStyleSheet("color: #9ca3af; font-weight: 500;")
            day_layout.addWidget(day_label)
            
            progress = QtWidgets.QProgressBar()
            progress.setMaximum(100)
            progress.setValue(0)
            progress.setTextVisible(True)
            progress.setFixedHeight(18)
            progress.setStyleSheet("""
                QProgressBar {
                    border: 1px solid #444444;
                    border-radius: 3px;
                    background: #333333;
                    text-align: center;
                    color: #e5e7eb;
                    font-size: 10px;
                }
                QProgressBar::chunk {
                    background: #10b981;
                    border-radius: 2px;
                }
            """)
            day_layout.addWidget(progress, 1)
            
            week_layout.addLayout(day_layout)
            self.week_bars[day] = progress
        
        # Total summary
        self.week_total_label = QtWidgets.QLabel("")
        self.week_total_label.setStyleSheet("""
            color: #e5e7eb;
            font-weight: 500;
            padding: 6px 0px 0px 0px;
            border-top: 1px solid #444444;
            margin-top: 4px;
        """)
        week_layout.addWidget(self.week_total_label)
        
        inner.addWidget(week_group)

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # PRODUCTIVITY ANALYTICS SECTION - State-of-the-art visualization
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        analytics_group = QtWidgets.QGroupBox()
        analytics_group.setStyleSheet("""
            QGroupBox {
                background: #2a2a2a;
                border: 1px solid #3d3d3d;
                border-radius: 8px;
                padding: 12px;
                margin-top: 8px;
            }
        """)
        analytics_layout = QtWidgets.QVBoxLayout(analytics_group)
        analytics_layout.setSpacing(12)
        
        # Analytics header with period selector
        analytics_header = QtWidgets.QHBoxLayout()
        analytics_title = QtWidgets.QLabel("üìà Productivity Analytics")
        analytics_title.setFont(QtGui.QFont("Arial", 12, QtGui.QFont.Bold))
        analytics_title.setStyleSheet("color: #a5b4fc; padding: 4px;")
        analytics_header.addWidget(analytics_title)
        analytics_header.addStretch()
        
        # Period selector
        period_label = QtWidgets.QLabel("Period:")
        period_label.setStyleSheet("color: #9ca3af;")
        analytics_header.addWidget(period_label)
        
        self.analytics_period = NoScrollComboBox()
        self.analytics_period.addItem("Last 7 Days", 7)
        self.analytics_period.addItem("Last 30 Days", 30)
        self.analytics_period.addItem("Last 60 Days", 60)
        self.analytics_period.addItem("Last 6 Months", 180)
        self.analytics_period.addItem("Lifetime", -1)
        self.analytics_period.setCurrentIndex(1)  # Default: 30 days
        self.analytics_period.setStyleSheet("""
            QComboBox {
                background: #333;
                color: #e5e7eb;
                border: 1px solid #444;
                border-radius: 4px;
                padding: 4px 8px;
                min-width: 120px;
            }
            QComboBox::drop-down {
                border: none;
            }
            QComboBox QAbstractItemView {
                background: #333;
                color: #e5e7eb;
                selection-background-color: #4f46e5;
            }
        """)
        self.analytics_period.currentIndexChanged.connect(self._refresh_analytics)
        analytics_header.addWidget(self.analytics_period)
        analytics_layout.addLayout(analytics_header)
        
        # 24-Hour Timeline Section
        timeline_card = QtWidgets.QFrame()
        timeline_card.setStyleSheet("""
            QFrame {
                background: #333333;
                border: 1px solid #444444;
                border-radius: 6px;
                padding: 10px;
            }
        """)
        timeline_layout = QtWidgets.QVBoxLayout(timeline_card)
        timeline_layout.setSpacing(8)
        
        timeline_title = QtWidgets.QLabel("üïê 24-Hour Focus Timeline")
        timeline_title.setFont(QtGui.QFont("Arial", 10, QtGui.QFont.Bold))
        timeline_title.setStyleSheet("color: #93c5fd;")
        timeline_layout.addWidget(timeline_title)
        
        timeline_subtitle = QtWidgets.QLabel("Average focus time by hour of day")
        timeline_subtitle.setStyleSheet("color: #6b7280; font-size: 10px;")
        timeline_layout.addWidget(timeline_subtitle)
        
        # Timeline canvas widget
        self.timeline_canvas = HourlyTimelineWidget()
        self.timeline_canvas.setMinimumHeight(100)
        self.timeline_canvas.setMaximumHeight(120)
        timeline_layout.addWidget(self.timeline_canvas)
        
        # Peak hours label
        self.peak_hours_label = QtWidgets.QLabel("Peak productivity: -")
        self.peak_hours_label.setStyleSheet("color: #10b981; font-size: 10px; font-weight: 500;")
        timeline_layout.addWidget(self.peak_hours_label)
        
        analytics_layout.addWidget(timeline_card)
        
        # Day-of-Week Pattern Analysis with Confidence Intervals
        dow_card = QtWidgets.QFrame()
        dow_card.setStyleSheet("""
            QFrame {
                background: #333333;
                border: 1px solid #444444;
                border-radius: 6px;
                padding: 10px;
            }
        """)
        dow_layout = QtWidgets.QVBoxLayout(dow_card)
        dow_layout.setSpacing(8)
        
        dow_title = QtWidgets.QLabel("üìÖ Weekly Productivity Patterns")
        dow_title.setFont(QtGui.QFont("Arial", 10, QtGui.QFont.Bold))
        dow_title.setStyleSheet("color: #c4b5fd;")
        dow_layout.addWidget(dow_title)
        
        dow_subtitle = QtWidgets.QLabel("Average focus time per day of week (with 95% confidence intervals)")
        dow_subtitle.setStyleSheet("color: #6b7280; font-size: 10px;")
        dow_layout.addWidget(dow_subtitle)
        
        # Day of week canvas
        self.dow_canvas = DayOfWeekPatternWidget()
        self.dow_canvas.setMinimumHeight(140)
        self.dow_canvas.setMaximumHeight(160)
        dow_layout.addWidget(self.dow_canvas)
        
        # Best/worst day labels
        self.best_day_label = QtWidgets.QLabel("Most productive: -")
        self.best_day_label.setStyleSheet("color: #10b981; font-size: 10px; font-weight: 500;")
        dow_layout.addWidget(self.best_day_label)
        
        self.worst_day_label = QtWidgets.QLabel("Least productive: -")
        self.worst_day_label.setStyleSheet("color: #f87171; font-size: 10px; font-weight: 500;")
        dow_layout.addWidget(self.worst_day_label)
        
        analytics_layout.addWidget(dow_card)
        
        # Statistics summary card
        stats_summary_card = QtWidgets.QFrame()
        stats_summary_card.setStyleSheet("""
            QFrame {
                background: #333333;
                border: 1px solid #444444;
                border-radius: 6px;
                padding: 10px;
            }
        """)
        stats_summary_layout = QtWidgets.QVBoxLayout(stats_summary_card)
        
        stats_summary_title = QtWidgets.QLabel("üìä Statistical Summary")
        stats_summary_title.setFont(QtGui.QFont("Arial", 10, QtGui.QFont.Bold))
        stats_summary_title.setStyleSheet("color: #fbbf24;")
        stats_summary_layout.addWidget(stats_summary_title)
        
        # Grid of statistics
        stats_grid = QtWidgets.QGridLayout()
        stats_grid.setSpacing(8)
        
        # Create stat labels
        def create_mini_stat(label_text: str, color: str) -> tuple:
            container = QtWidgets.QWidget()
            container_layout = QtWidgets.QVBoxLayout(container)
            container_layout.setContentsMargins(4, 4, 4, 4)
            container_layout.setSpacing(2)
            
            value_lbl = QtWidgets.QLabel("-")
            value_lbl.setFont(QtGui.QFont("Arial", 14, QtGui.QFont.Bold))
            value_lbl.setStyleSheet(f"color: {color};")
            value_lbl.setAlignment(QtCore.Qt.AlignCenter)
            container_layout.addWidget(value_lbl)
            
            label = QtWidgets.QLabel(label_text)
            label.setStyleSheet("color: #6b7280; font-size: 9px;")
            label.setAlignment(QtCore.Qt.AlignCenter)
            container_layout.addWidget(label)
            
            return container, value_lbl
        
        # Row 1: Productivity Score, Total Time, Sessions, Avg/day
        c0, self.stat_productivity_score = create_mini_stat("Score", "#10b981")
        c1, self.stat_total_time = create_mini_stat("Total Time", "#60a5fa")
        c2, self.stat_total_sessions = create_mini_stat("Sessions", "#34d399")
        c3, self.stat_avg_daily = create_mini_stat("Avg/Day", "#a78bfa")
        
        stats_grid.addWidget(c0, 0, 0)
        stats_grid.addWidget(c1, 0, 1)
        stats_grid.addWidget(c2, 0, 2)
        stats_grid.addWidget(c3, 0, 3)
        
        # Row 2: Consistency, Deep Work %, Avg Session, Goal Rate
        c4, self.stat_consistency = create_mini_stat("Consistency", "#fbbf24")
        c5, self.stat_deep_work = create_mini_stat("Deep Work", "#f472b6")
        c6, self.stat_avg_session = create_mini_stat("Avg Session", "#2dd4bf")
        c7, self.stat_goal_rate = create_mini_stat("Goal Rate", "#fb923c")
        
        stats_grid.addWidget(c4, 1, 0)
        stats_grid.addWidget(c5, 1, 1)
        stats_grid.addWidget(c6, 1, 2)
        stats_grid.addWidget(c7, 1, 3)
        
        # Row 3: Active Days, Best Day, Std Dev, Trend
        c8, self.stat_active_days = create_mini_stat("Active Days", "#818cf8")
        c9, self.stat_max_day = create_mini_stat("Best Day", "#f97316")
        c10, self.stat_std_dev = create_mini_stat("Variability", "#94a3b8")
        c11, self.stat_trend = create_mini_stat("Trend", "#22d3ee")
        
        stats_grid.addWidget(c8, 2, 0)
        stats_grid.addWidget(c9, 2, 1)
        stats_grid.addWidget(c10, 2, 2)
        stats_grid.addWidget(c11, 2, 3)
        
        # Row 4: Week-over-week change
        wow_container = QtWidgets.QWidget()
        wow_layout = QtWidgets.QHBoxLayout(wow_container)
        wow_layout.setContentsMargins(4, 8, 4, 4)
        wow_layout.setSpacing(12)
        
        self.stat_wow_label = QtWidgets.QLabel("üìà Week-over-Week:")
        self.stat_wow_label.setStyleSheet("color: #9ca3af; font-size: 10px;")
        wow_layout.addWidget(self.stat_wow_label)
        
        self.stat_wow_value = QtWidgets.QLabel("-")
        self.stat_wow_value.setFont(QtGui.QFont("Arial", 11, QtGui.QFont.Bold))
        self.stat_wow_value.setStyleSheet("color: #22d3ee;")
        wow_layout.addWidget(self.stat_wow_value)
        
        self.stat_vs_avg_label = QtWidgets.QLabel("   vs. Period Avg:")
        self.stat_vs_avg_label.setStyleSheet("color: #9ca3af; font-size: 10px;")
        wow_layout.addWidget(self.stat_vs_avg_label)
        
        self.stat_vs_avg_value = QtWidgets.QLabel("-")
        self.stat_vs_avg_value.setFont(QtGui.QFont("Arial", 11, QtGui.QFont.Bold))
        self.stat_vs_avg_value.setStyleSheet("color: #a78bfa;")
        wow_layout.addWidget(self.stat_vs_avg_value)
        
        wow_layout.addStretch()
        stats_grid.addWidget(wow_container, 3, 0, 1, 4)
        
        stats_summary_layout.addLayout(stats_grid)
        analytics_layout.addWidget(stats_summary_card)
        
        inner.addWidget(analytics_group)

        # Distraction attempts (bypass) - dark theme
        if BYPASS_LOGGER_AVAILABLE:
            bypass_group = QtWidgets.QGroupBox()
            bypass_group.setStyleSheet("""
                QGroupBox {
                    background: #2a2a2a;
                    border: 1px solid #3d3d3d;
                    border-radius: 8px;
                    padding: 16px;
                    margin-top: 8px;
                }
            """)
            bypass_layout = QtWidgets.QVBoxLayout(bypass_group)
            bypass_layout.setSpacing(10)
            
            bypass_title = QtWidgets.QLabel("üö´ Distraction Attempts")
            bypass_title.setFont(QtGui.QFont("Arial", 12, QtGui.QFont.Bold))
            bypass_title.setStyleSheet("color: #fca5a5; padding: 4px;")
            bypass_layout.addWidget(bypass_title)
            
            # Session stats card
            session_card = QtWidgets.QFrame()
            session_card.setStyleSheet("""
                QFrame {
                    background: #3d2a2a;
                    border: 1px solid #5c4444;
                    border-radius: 6px;
                    padding: 10px;
                }
            """)
            session_layout = QtWidgets.QVBoxLayout(session_card)
            
            self.bypass_session_label = QtWidgets.QLabel("Current Session: 0 attempts")
            self.bypass_session_label.setFont(QtGui.QFont("Arial", 10, QtGui.QFont.Bold))
            self.bypass_session_label.setStyleSheet("color: #f87171;")
            session_layout.addWidget(self.bypass_session_label)
            
            self.bypass_session_sites = QtWidgets.QLabel("No sites accessed")
            self.bypass_session_sites.setStyleSheet("color: #9ca3af; padding-left: 8px;")
            session_layout.addWidget(self.bypass_session_sites)
            bypass_layout.addWidget(session_card)
            
            # Overall stats card
            overall_card = QtWidgets.QFrame()
            overall_card.setStyleSheet("""
                QFrame {
                    background: #333333;
                    border: 1px solid #444444;
                    border-radius: 6px;
                    padding: 10px;
                }
            """)
            overall_layout = QtWidgets.QVBoxLayout(overall_card)

            self.bypass_total_label = QtWidgets.QLabel("Total attempts: 0")
            self.bypass_total_label.setFont(QtGui.QFont("Arial", 10, QtGui.QFont.Bold))
            self.bypass_total_label.setStyleSheet("color: #e5e7eb;")
            overall_layout.addWidget(self.bypass_total_label)
            
            self.bypass_top_sites = QtWidgets.QLabel("Top distractions: -")
            self.bypass_top_sites.setStyleSheet("padding-left: 8px; color: #9ca3af;")
            overall_layout.addWidget(self.bypass_top_sites)
            
            self.bypass_peak_hours = QtWidgets.QLabel("Peak hours: -")
            self.bypass_peak_hours.setStyleSheet("padding-left: 8px; color: #9ca3af;")
            overall_layout.addWidget(self.bypass_peak_hours)
            bypass_layout.addWidget(overall_card)

            # Insights
            self.bypass_insights = QtWidgets.QTextEdit()
            self.bypass_insights.setReadOnly(True)
            self.bypass_insights.setMaximumHeight(70)
            self.bypass_insights.setStyleSheet("""
                QTextEdit {
                    background: #3d3a2a;
                    border: 1px solid #5c5944;
                    border-radius: 6px;
                    padding: 8px;
                    color: #fbbf24;
                }
            """)
            bypass_layout.addWidget(self.bypass_insights)

            refresh_bypass = QtWidgets.QPushButton("üîÑ Refresh Attempts")
            refresh_bypass.setStyleSheet("""
                QPushButton {
                    background: #ef4444;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    padding: 8px 14px;
                    font-weight: 500;
                }
                QPushButton:hover {
                    background: #dc2626;
                }
            """)
            refresh_bypass.clicked.connect(self._refresh_bypass_stats)
            bypass_layout.addWidget(refresh_bypass)

            inner.addWidget(bypass_group)

        # Reset button - dark theme
        reset_btn = QtWidgets.QPushButton("üîÑ Reset All Statistics")
        reset_btn.setStyleSheet("""
            QPushButton {
                background: #4b5563;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 10px 18px;
                font-weight: 500;
                font-size: 11px;
            }
            QPushButton:hover {
                background: #374151;
            }
        """)
        reset_btn.clicked.connect(self._reset_stats)
        inner.addWidget(reset_btn)

        inner.addStretch()
        scroll.setWidget(container)
        layout.addWidget(scroll)

    def refresh(self) -> None:
        from datetime import datetime, timedelta
        stats = self.blocker.get_stats_summary()
        self.total_hours_lbl.setText(f"{stats['total_hours']}h")
        self.sessions_lbl.setText(str(stats["sessions_completed"]))
        self.streak_lbl.setText(f"{stats['current_streak']} days")
        self.best_streak_lbl.setText(f"{stats['best_streak']} days")

        # Goals progress
        try:
            weekly_target = float(self.blocker.stats.get("weekly_goal_hours", 10))
        except (ValueError, TypeError):
            weekly_target = 10.0
        try:
            monthly_target = float(self.blocker.stats.get("monthly_goal_hours", 40))
        except (ValueError, TypeError):
            monthly_target = 40.0
        weekly_minutes = self._sum_focus_minutes(7)
        monthly_minutes = self._sum_focus_minutes(30)

        weekly_pct = 0 if weekly_target <= 0 else min(100, int((weekly_minutes / 60) / weekly_target * 100))
        monthly_pct = 0 if monthly_target <= 0 else min(100, int((monthly_minutes / 60) / monthly_target * 100))

        self.weekly_bar.setFormat(f"{weekly_minutes/60:.1f}h / {weekly_target:.0f}h ({weekly_pct}%)")
        self.weekly_bar.setValue(weekly_pct)
        self.monthly_bar.setFormat(f"{monthly_minutes/60:.1f}h / {monthly_target:.0f}h ({monthly_pct}%)")
        self.monthly_bar.setValue(monthly_pct)

        # Weekly chart with graphical bars
        days = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        today = datetime.now()
        week_data = {}
        max_time = 1
        total_week = 0
        
        for i in range(6, -1, -1):
            date_str = (today - timedelta(days=i)).strftime("%Y-%m-%d")
            dt = datetime.strptime(date_str, "%Y-%m-%d")
            day_name = days[dt.weekday()]
            daily = self.blocker.stats.get("daily_stats", {}).get(date_str, {})
            time_min = daily.get("focus_time", 0) // 60
            week_data[day_name] = time_min
            max_time = max(max_time, time_min)
            total_week += time_min

        # Update each day's progress bar
        for day in days:
            time_min = week_data.get(day, 0)
            percentage = int((time_min / max_time) * 100) if max_time > 0 else 0
            bar = self.week_bars.get(day)
            if bar:
                bar.setValue(percentage)
                hours = time_min // 60
                mins = time_min % 60
                if hours > 0:
                    bar.setFormat(f"{hours}h {mins}m")
                else:
                    bar.setFormat(f"{mins}m")
        
        # Update total
        total_hours = total_week // 60
        total_mins = total_week % 60
        self.week_total_label.setText(f"Total: {total_hours}h {total_mins}m")

        if BYPASS_LOGGER_AVAILABLE:
            self._refresh_bypass_stats()
        
        # Refresh productivity analytics
        self._refresh_analytics()
        
        # Refresh AGI Assistant Chad tips
        self._refresh_chad_tips()

    def _sum_focus_minutes(self, days_back: int) -> int:
        from datetime import datetime, timedelta

        total = 0
        today = datetime.now()
        for i in range(days_back):
            date_str = (today - timedelta(days=i)).strftime("%Y-%m-%d")
            daily = self.blocker.stats.get("daily_stats", {}).get(date_str, {})
            total += daily.get("focus_time", 0) // 60
        return total

    def _set_weekly_goal(self) -> None:
        self.blocker.stats["weekly_goal_hours"] = float(self.weekly_target.value())
        self.blocker.save_stats()
        self.refresh()

    def _set_monthly_goal(self) -> None:
        self.blocker.stats["monthly_goal_hours"] = float(self.monthly_target.value())
        self.blocker.save_stats()
        self.refresh()

    def _refresh_bypass_stats(self) -> None:
        if not BYPASS_LOGGER_AVAILABLE:
            return
        stats = self.blocker.get_bypass_statistics()
        if not stats:
            return

        session_count = stats.get("current_session", 0)
        session_sites = stats.get("session_sites", [])
        self.bypass_session_label.setText(f"Current Session: {session_count} attempts")
        if session_sites:
            sites_text = ", ".join(session_sites[:5])
            if len(session_sites) > 5:
                sites_text += f" (+{len(session_sites) - 5} more)"
            self.bypass_session_sites.setText(f"Sites: {sites_text}")
        else:
            self.bypass_session_sites.setText("No sites accessed")

        self.bypass_total_label.setText(f"Total attempts: {stats.get('total_attempts', 0)}")
        top_sites = stats.get("top_sites", [])[:3]
        if top_sites:
            self.bypass_top_sites.setText(
                "Top distractions: " + ", ".join(f"{s} ({c})" for s, c in top_sites)
            )
        else:
            self.bypass_top_sites.setText("Top distractions: -")

        peak_hours = stats.get("peak_hours", [])[:3]
        if peak_hours:
            self.bypass_peak_hours.setText(
                "Peak hours: " + ", ".join(f"{int(h)}:00" for h, _ in peak_hours)
            )
        else:
            self.bypass_peak_hours.setText("Peak hours: -")

        insights = self.blocker.get_bypass_insights()
        if insights:
            self.bypass_insights.setPlainText("\n".join(insights))
        else:
            self.bypass_insights.setPlainText("No insights yet. Keep focusing!")

    def _refresh_analytics(self) -> None:
        """Refresh the productivity analytics section with statistical analysis."""
        from datetime import datetime, timedelta
        import math
        
        # Get selected period
        period_days = self.analytics_period.currentData()
        
        # Collect daily stats for the period
        daily_stats = self.blocker.stats.get("daily_stats", {})
        today = datetime.now()
        
        # Filter dates within period
        if period_days == -1:  # Lifetime
            relevant_dates = sorted(daily_stats.keys())
        else:
            cutoff = today - timedelta(days=period_days)
            relevant_dates = [d for d in daily_stats.keys() 
                            if datetime.strptime(d, "%Y-%m-%d") >= cutoff]
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # 24-HOUR TIMELINE ANALYSIS
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        hourly_totals = [0.0] * 24
        hourly_counts = [0] * 24
        
        for date_str in relevant_dates:
            day_data = daily_stats.get(date_str, {})
            hourly = day_data.get("hourly", {})
            for hour_str, seconds in hourly.items():
                try:
                    hour = int(hour_str)
                    if 0 <= hour < 24:
                        hourly_totals[hour] += seconds / 60  # Convert to minutes
                        hourly_counts[hour] += 1
                except ValueError:
                    pass
        
        # Calculate averages
        hourly_averages = [
            hourly_totals[h] / max(hourly_counts[h], 1) 
            for h in range(24)
        ]
        
        # Update timeline widget
        self.timeline_canvas.set_data(hourly_averages)
        
        # Find peak hours
        peak_hours = sorted(enumerate(hourly_averages), key=lambda x: x[1], reverse=True)[:3]
        if peak_hours[0][1] > 0:
            peak_text = ", ".join([f"{h:02d}:00 ({m:.0f}m)" for h, m in peak_hours if m > 0])
            self.peak_hours_label.setText(f"üî• Peak productivity: {peak_text}")
        else:
            self.peak_hours_label.setText("Peak productivity: No data yet")
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # DAY-OF-WEEK PATTERN ANALYSIS WITH CONFIDENCE INTERVALS
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        # Collect data by day of week
        dow_data = {i: [] for i in range(7)}  # 0=Monday, 6=Sunday
        
        for date_str in relevant_dates:
            try:
                dt = datetime.strptime(date_str, "%Y-%m-%d")
                day_of_week = dt.weekday()
                day_data = daily_stats.get(date_str, {})
                focus_minutes = day_data.get("focus_time", 0) / 60
                dow_data[day_of_week].append(focus_minutes)
            except ValueError:
                pass
        
        # Calculate statistics with 95% confidence intervals
        dow_stats = []
        day_names = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
        
        for dow in range(7):
            values = dow_data[dow]
            if len(values) > 1:
                n = len(values)
                mean = sum(values) / n
                variance = sum((x - mean) ** 2 for x in values) / (n - 1) if n > 1 else 0
                std_dev = math.sqrt(variance)
                std_error = std_dev / math.sqrt(n)
                
                # 95% CI using t-distribution approximation (z ‚âà 1.96 for large n)
                # For small n, use t-value (approximation)
                if n >= 30:
                    t_value = 1.96
                elif n >= 10:
                    t_value = 2.228
                else:
                    t_value = 2.571
                
                margin = t_value * std_error
                lower_ci = max(0, mean - margin)
                upper_ci = mean + margin
                dow_stats.append((mean, lower_ci, upper_ci))
            elif len(values) == 1:
                dow_stats.append((values[0], values[0], values[0]))
            else:
                dow_stats.append((0.0, 0.0, 0.0))
        
        # Update DOW widget
        self.dow_canvas.set_data(dow_stats)
        
        # Find best and worst days
        valid_days = [(i, dow_stats[i][0]) for i in range(7) if dow_stats[i][0] > 0]
        if valid_days:
            best_day_idx = max(valid_days, key=lambda x: x[1])[0]
            worst_day_idx = min(valid_days, key=lambda x: x[1])[0]
            best_mean = dow_stats[best_day_idx][0]
            worst_mean = dow_stats[worst_day_idx][0]
            
            if best_mean >= 60:
                self.best_day_label.setText(f"üèÜ Most productive: {day_names[best_day_idx]} ({best_mean/60:.1f}h avg)")
            else:
                self.best_day_label.setText(f"üèÜ Most productive: {day_names[best_day_idx]} ({best_mean:.0f}m avg)")
            
            if worst_mean >= 60:
                self.worst_day_label.setText(f"üìâ Least productive: {day_names[worst_day_idx]} ({worst_mean/60:.1f}h avg)")
            else:
                self.worst_day_label.setText(f"üìâ Least productive: {day_names[worst_day_idx]} ({worst_mean:.0f}m avg)")
        else:
            self.best_day_label.setText("üèÜ Most productive: -")
            self.worst_day_label.setText("üìâ Least productive: -")
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # STATISTICAL SUMMARY (Industry-Standard Metrics)
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        # Collect all daily focus times and session details
        all_daily_focus = []
        total_sessions = 0
        session_lengths = []  # Individual session lengths for analysis
        deep_work_sessions = 0  # Sessions >= 45 minutes
        
        for date_str in relevant_dates:
            day_data = daily_stats.get(date_str, {})
            focus_min = day_data.get("focus_time", 0) / 60
            sessions = day_data.get("sessions", 0)
            all_daily_focus.append(focus_min)
            total_sessions += sessions
            
            # Estimate average session length for this day
            if sessions > 0:
                avg_session_this_day = focus_min / sessions
                session_lengths.append(avg_session_this_day)
                # Count deep work (assume session >= 45min is deep work)
                if avg_session_this_day >= 45:
                    deep_work_sessions += sessions
        
        # Calculate core statistics
        total_focus = sum(all_daily_focus)
        active_days = len([f for f in all_daily_focus if f > 0])
        num_days = len(all_daily_focus) if all_daily_focus else 1
        
        avg_daily = total_focus / num_days if num_days > 0 else 0
        
        if len(all_daily_focus) > 1:
            variance = sum((x - avg_daily) ** 2 for x in all_daily_focus) / (len(all_daily_focus) - 1)
            std_dev = math.sqrt(variance)
        else:
            std_dev = 0
        
        max_day = max(all_daily_focus) if all_daily_focus else 0
        
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # INDUSTRY-STANDARD METRICS
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        
        # 1. PRODUCTIVITY SCORE (0-100)
        # Composite score based on: consistency, avg focus, trend, goal achievement
        # Industry standard: RescueTime uses similar composite scoring
        
        # Normalize avg daily (assume 120min/day = 100% baseline for solo productivity)
        daily_target = 120  # 2 hours of focused work
        avg_score = min(100, (avg_daily / daily_target) * 100) if daily_target > 0 else 0
        
        # Consistency score (active days percentage, weighted 30%)
        consistency = (active_days / num_days * 100) if num_days > 0 else 0
        consistency_score = consistency  # Already 0-100
        
        # Regularity score (lower std dev = more regular = better)
        # If std_dev is less than 30% of avg, that's good regularity
        if avg_daily > 0:
            cv = (std_dev / avg_daily) if avg_daily > 0 else 1  # Coefficient of variation
            regularity_score = max(0, min(100, (1 - cv) * 100))
        else:
            regularity_score = 0
        
        # Calculate final productivity score (weighted average)
        productivity_score = int(
            avg_score * 0.4 +          # 40% weight on avg focus
            consistency_score * 0.35 + # 35% weight on consistency
            regularity_score * 0.25    # 25% weight on regularity
        )
        productivity_score = max(0, min(100, productivity_score))
        
        # 2. DEEP WORK PERCENTAGE
        # Sessions >= 45 min (Cal Newport's definition)
        deep_work_pct = (deep_work_sessions / total_sessions * 100) if total_sessions > 0 else 0
        
        # 3. AVERAGE SESSION LENGTH
        avg_session = sum(session_lengths) / len(session_lengths) if session_lengths else 0
        
        # 4. GOAL COMPLETION RATE
        # Compare against weekly and monthly goals
        try:
            weekly_target = float(self.blocker.stats.get("weekly_goal_hours", 10)) * 60  # Convert to minutes
        except (ValueError, TypeError):
            weekly_target = 600  # Default 10 hours
        
        # Calculate goal rate based on period
        if period_days == 7:
            goal_rate = min(100, (total_focus / weekly_target * 100)) if weekly_target > 0 else 0
        elif period_days in [30, 60, 180, -1]:
            # Scale weekly goal to period
            weeks_in_period = num_days / 7 if num_days > 0 else 1
            period_target = weekly_target * weeks_in_period
            goal_rate = min(100, (total_focus / period_target * 100)) if period_target > 0 else 0
        else:
            goal_rate = 0
        
        # 5. WEEK-OVER-WEEK CHANGE
        # Compare last 7 days vs previous 7 days
        last_7_days = []
        prev_7_days = []
        for i, date_str in enumerate(sorted(relevant_dates, reverse=True)):
            if i < 7:
                day_data = daily_stats.get(date_str, {})
                last_7_days.append(day_data.get("focus_time", 0) / 60)
            elif i < 14:
                day_data = daily_stats.get(date_str, {})
                prev_7_days.append(day_data.get("focus_time", 0) / 60)
        
        last_7_total = sum(last_7_days)
        prev_7_total = sum(prev_7_days) if prev_7_days else 0
        
        if prev_7_total > 0:
            wow_change = ((last_7_total - prev_7_total) / prev_7_total) * 100
        else:
            wow_change = 100 if last_7_total > 0 else 0
        
        # 6. VS PERIOD AVERAGE
        if avg_daily > 0 and len(last_7_days) >= 7:
            last_7_avg = last_7_total / 7
            vs_avg_pct = ((last_7_avg - avg_daily) / avg_daily) * 100
        else:
            vs_avg_pct = 0
        
        # 7. TREND (compare first half vs second half)
        if len(all_daily_focus) >= 4:
            half = len(all_daily_focus) // 2
            first_half_avg = sum(all_daily_focus[:half]) / half if half > 0 else 0
            second_half_avg = sum(all_daily_focus[half:]) / (len(all_daily_focus) - half) if (len(all_daily_focus) - half) > 0 else 0
            
            if first_half_avg > 0:
                trend_pct = ((second_half_avg - first_half_avg) / first_half_avg) * 100
                if trend_pct > 5:
                    trend_text = f"‚Üó+{trend_pct:.0f}%"
                    self.stat_trend.setStyleSheet("color: #10b981; font-weight: bold;")
                elif trend_pct < -5:
                    trend_text = f"‚Üò{trend_pct:.0f}%"
                    self.stat_trend.setStyleSheet("color: #f87171; font-weight: bold;")
                else:
                    trend_text = "‚Üí 0%"
                    self.stat_trend.setStyleSheet("color: #94a3b8;")
            else:
                trend_text = "-"
                self.stat_trend.setStyleSheet("color: #94a3b8;")
        else:
            trend_text = "-"
            self.stat_trend.setStyleSheet("color: #94a3b8;")
        
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # UPDATE UI LABELS
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        
        # Productivity Score with color coding
        if productivity_score >= 80:
            self.stat_productivity_score.setStyleSheet("color: #10b981; font-weight: bold;")
        elif productivity_score >= 60:
            self.stat_productivity_score.setStyleSheet("color: #34d399;")
        elif productivity_score >= 40:
            self.stat_productivity_score.setStyleSheet("color: #fbbf24;")
        else:
            self.stat_productivity_score.setStyleSheet("color: #f87171;")
        self.stat_productivity_score.setText(f"{productivity_score}")
        
        # Total time
        if total_focus >= 60:
            self.stat_total_time.setText(f"{total_focus/60:.1f}h")
        else:
            self.stat_total_time.setText(f"{total_focus:.0f}m")
        
        self.stat_total_sessions.setText(str(total_sessions))
        
        # Avg daily
        if avg_daily >= 60:
            self.stat_avg_daily.setText(f"{avg_daily/60:.1f}h")
        else:
            self.stat_avg_daily.setText(f"{avg_daily:.0f}m")
        
        # Consistency
        self.stat_consistency.setText(f"{consistency:.0f}%")
        
        # Deep work percentage
        if deep_work_pct >= 50:
            self.stat_deep_work.setStyleSheet("color: #10b981; font-weight: bold;")
        elif deep_work_pct >= 25:
            self.stat_deep_work.setStyleSheet("color: #f472b6;")
        else:
            self.stat_deep_work.setStyleSheet("color: #94a3b8;")
        self.stat_deep_work.setText(f"{deep_work_pct:.0f}%")
        
        # Average session length
        if avg_session >= 45:
            self.stat_avg_session.setStyleSheet("color: #10b981; font-weight: bold;")
        elif avg_session >= 25:
            self.stat_avg_session.setStyleSheet("color: #2dd4bf;")
        else:
            self.stat_avg_session.setStyleSheet("color: #94a3b8;")
        self.stat_avg_session.setText(f"{avg_session:.0f}m")
        
        # Goal completion rate
        if goal_rate >= 100:
            self.stat_goal_rate.setStyleSheet("color: #10b981; font-weight: bold;")
        elif goal_rate >= 75:
            self.stat_goal_rate.setStyleSheet("color: #34d399;")
        elif goal_rate >= 50:
            self.stat_goal_rate.setStyleSheet("color: #fbbf24;")
        else:
            self.stat_goal_rate.setStyleSheet("color: #fb923c;")
        self.stat_goal_rate.setText(f"{goal_rate:.0f}%")
        
        # Active days
        self.stat_active_days.setText(str(active_days))
        
        # Best day (max)
        if max_day >= 60:
            self.stat_max_day.setText(f"{max_day/60:.1f}h")
        else:
            self.stat_max_day.setText(f"{max_day:.0f}m")
        
        # Std dev (variability)
        if std_dev >= 60:
            self.stat_std_dev.setText(f"¬±{std_dev/60:.1f}h")
        else:
            self.stat_std_dev.setText(f"¬±{std_dev:.0f}m")
        
        # Trend
        self.stat_trend.setText(trend_text)
        
        # Week-over-week change
        if wow_change > 0:
            self.stat_wow_value.setText(f"‚Üó +{wow_change:.0f}%")
            self.stat_wow_value.setStyleSheet("color: #10b981; font-weight: bold;")
        elif wow_change < 0:
            self.stat_wow_value.setText(f"‚Üò {wow_change:.0f}%")
            self.stat_wow_value.setStyleSheet("color: #f87171; font-weight: bold;")
        else:
            self.stat_wow_value.setText("‚Üí 0%")
            self.stat_wow_value.setStyleSheet("color: #94a3b8;")
        
        # Vs period average
        if vs_avg_pct > 0:
            self.stat_vs_avg_value.setText(f"‚Üó +{vs_avg_pct:.0f}%")
            self.stat_vs_avg_value.setStyleSheet("color: #10b981; font-weight: bold;")
        elif vs_avg_pct < 0:
            self.stat_vs_avg_value.setText(f"‚Üò {vs_avg_pct:.0f}%")
            self.stat_vs_avg_value.setStyleSheet("color: #f87171; font-weight: bold;")
        else:
            self.stat_vs_avg_value.setText("‚Üí 0%")
            self.stat_vs_avg_value.setStyleSheet("color: #94a3b8;")

    def _refresh_chad_tips(self) -> None:
        """Refresh the AGI Assistant Chad productivity tips section."""
        from datetime import datetime
        
        CHAD_ENTITY_ID = "underdog_008"  # AGI Assistant Chad
        
        try:
            from gamification import get_entitidex_manager
            from entitidex_tab import _resolve_entity_svg_path
            from entitidex.entity_pools import get_entity_by_id as get_entity
            from PySide6.QtSvg import QSvgRenderer
            from productivity_tips import get_tip_by_index, get_tip_count
        except ImportError as e:
            # Dependencies not available
            self.chad_tips_section.setVisible(False)
            return
        
        # Get entitidex manager to check entity collection
        try:
            manager = get_entitidex_manager(self.blocker.adhd_buster)
        except Exception:
            self.chad_tips_section.setVisible(False)
            return
        
        # Check if user has collected Chad (normal or exceptional)
        has_normal = CHAD_ENTITY_ID in manager.progress.collected_entity_ids
        has_exceptional = manager.progress.is_exceptional(CHAD_ENTITY_ID)
        
        if not has_normal and not has_exceptional:
            # Entity not collected - hide section
            self.chad_tips_section.setVisible(False)
            return
        
        # Entity is collected - show section
        self.chad_tips_section.setVisible(True)
        
        # Determine if we use exceptional tips
        is_exceptional = has_exceptional
        
        # Update section title based on variant
        if is_exceptional:
            self.chad_section_title.setText("‚≠ê AGI Assistant (Exceptional) Advanced Tips")
            self.chad_section_title.setStyleSheet("color: #ffd700; padding: 4px;")
            self.chad_entity_name.setText("‚≠ê AGI Assistant Chad")
            self.chad_entity_name.setStyleSheet("color: #ffd700; font-weight: bold; font-size: 12px;")
        else:
            self.chad_section_title.setText("ü§ñ AGI Assistant Productivity Tips")
            self.chad_section_title.setStyleSheet("color: #a5b4fc; padding: 4px;")
            self.chad_entity_name.setText("AGI Assistant Chad")
            self.chad_entity_name.setStyleSheet("color: #e5e7eb; font-weight: bold; font-size: 12px;")
        
        # Load entity icon
        try:
            entity = get_entity(CHAD_ENTITY_ID)
            if entity:
                svg_path = _resolve_entity_svg_path(entity, is_exceptional)
                if svg_path:
                    renderer = QSvgRenderer(svg_path)
                    if renderer.isValid():
                        icon_size = 48
                        pixmap = QtGui.QPixmap(icon_size, icon_size)
                        pixmap.fill(QtCore.Qt.transparent)
                        painter = QtGui.QPainter(pixmap)
                        renderer.render(painter)
                        painter.end()
                        self.chad_icon_label.setPixmap(pixmap)
                        
                        # Update icon border for exceptional
                        if is_exceptional:
                            self.chad_icon_label.setStyleSheet("""
                                QLabel {
                                    background: #333;
                                    border: 2px solid #ffd700;
                                    border-radius: 6px;
                                }
                            """)
                        else:
                            self.chad_icon_label.setStyleSheet("""
                                QLabel {
                                    background: #333;
                                    border: 1px solid #444;
                                    border-radius: 6px;
                                }
                            """)
        except Exception:
            # Fallback - just show text
            self.chad_icon_label.setText("ü§ñ")
        
        # Get current tip index (sequential cycling)
        tip_key = "chad_tip_index_exceptional" if is_exceptional else "chad_tip_index"
        tip_index = self.blocker.stats.get(tip_key, 0)
        total_tips = get_tip_count(is_exceptional)
        
        # Get the tip at current index
        tip_text, category_emoji = get_tip_by_index(tip_index, is_exceptional)
        
        # Update tip display
        self.chad_tip_number.setText(f"Tip #{tip_index + 1} of {total_tips}")
        self.chad_tip_text.setText(f"{category_emoji} {tip_text}")
        
        # Check if already acknowledged today
        today_str = datetime.now().strftime("%Y-%m-%d")
        ack_key = "chad_tip_acknowledged_date_exceptional" if is_exceptional else "chad_tip_acknowledged_date"
        last_acknowledged = self.blocker.stats.get(ack_key, "")
        
        if last_acknowledged == today_str:
            # Already acknowledged today
            self.chad_acknowledge_btn.setEnabled(False)
            self.chad_acknowledge_btn.setText("‚úì +1 ü™ô collected!")
        else:
            # Can acknowledge
            self.chad_acknowledge_btn.setEnabled(True)
            self.chad_acknowledge_btn.setText("‚úì Got it! (+1 ü™ô)")
    
    def _acknowledge_chad_tip(self) -> None:
        """Acknowledge the daily Chad tip and award 1 coin."""
        from datetime import datetime
        from productivity_tips import get_tip_count
        
        today_str = datetime.now().strftime("%Y-%m-%d")
        
        # Determine if we're using exceptional tips
        try:
            from gamification import get_entitidex_manager
            manager = get_entitidex_manager(self.blocker.adhd_buster)
            is_exceptional = manager.progress.is_exceptional("underdog_008")
        except Exception:
            is_exceptional = False
        
        # Use appropriate keys based on variant
        ack_key = "chad_tip_acknowledged_date_exceptional" if is_exceptional else "chad_tip_acknowledged_date"
        tip_key = "chad_tip_index_exceptional" if is_exceptional else "chad_tip_index"
        
        # Check if already acknowledged today (prevent double rewards)
        last_acknowledged = self.blocker.stats.get(ack_key, "")
        if last_acknowledged == today_str:
            return
        
        # Mark as acknowledged
        self.blocker.stats[ack_key] = today_str
        
        # Increment tip index for next time (cycle back to 0 after all tips shown)
        current_index = self.blocker.stats.get(tip_key, 0)
        total_tips = get_tip_count(is_exceptional)
        next_index = (current_index + 1) % total_tips
        self.blocker.stats[tip_key] = next_index
        
        self.blocker.save_stats()
        
        # Award 1 coin using GameState for reactive UI update
        main_window = self.window()
        game_state = getattr(main_window, 'game_state', None)
        if game_state:
            game_state.add_coins(1)
        else:
            # Fallback if GameState not available
            current_coins = self.blocker.adhd_buster.get("coins", 0)
            self.blocker.adhd_buster["coins"] = current_coins + 1
            self.blocker.save_config()
        
        # Update button state - no dialog, just update text
        self.chad_acknowledge_btn.setEnabled(False)
        self.chad_acknowledge_btn.setText("‚úì +1 ü™ô collected!")

    def _reset_stats(self) -> None:
        if show_question(self, "Reset Stats", "Reset all statistics?") == QtWidgets.QMessageBox.Yes:
            self.blocker.stats = self.blocker._default_stats()
            self.blocker.save_stats()
            self.refresh()


class SettingsTab(QtWidgets.QWidget):
    """Settings tab - password, pomodoro settings, backup/restore, cleanup."""
    
    # Signal to notify parent that dev mode was enabled
    dev_mode_enabled = QtCore.Signal()

    def __init__(self, blocker: BlockerCore, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.blocker = blocker
        self._dev_tap_count = 0
        self._dev_tap_timer = None
        self._build_ui()

    def _build_ui(self) -> None:
        layout = QtWidgets.QVBoxLayout(self)

        # Help button (moves to bottom after read)
        add_tab_help_button(layout, "settings", self)

        scroll = QtWidgets.QScrollArea()
        scroll.setWidgetResizable(True)
        container = QtWidgets.QWidget()
        inner = QtWidgets.QVBoxLayout(container)

        # User Profile Settings
        user_group = QtWidgets.QGroupBox("üë§ User Profile")
        user_layout = QtWidgets.QHBoxLayout(user_group)
        current_user = self.window().blocker.user_dir.name if hasattr(self.window().blocker, 'user_dir') else "Default"
        user_label = QtWidgets.QLabel(f"Current Profile: <b>{current_user}</b>")
        user_layout.addWidget(user_label)
        user_layout.addStretch()
        
        switch_user_btn = QtWidgets.QPushButton("Switch User")
        switch_user_btn.clicked.connect(self._switch_user)
        user_layout.addWidget(switch_user_btn)
        inner.addWidget(user_group)

        # Audio Settings
        audio_group = QtWidgets.QGroupBox("üîä Audio Settings")
        audio_layout = QtWidgets.QFormLayout(audio_group)

        # Get audio manager instance
        from entitidex.celebration_audio import CelebrationAudioManager
        audio_manager = CelebrationAudioManager.get_instance()

        # Sound Volume Slider
        self.sound_slider = QtWidgets.QSlider(QtCore.Qt.Orientation.Horizontal)
        self.sound_slider.setRange(0, 100)
        current_sound_vol = int(audio_manager._sound_volume * 100)
        self.sound_slider.setValue(current_sound_vol)
        self.sound_slider.valueChanged.connect(self._on_sound_volume_changed)
        
        # Add label to show percentage? Maybe later. For now just slider.
        audio_layout.addRow("Sound Effects:", self.sound_slider)

        # Voice Volume Slider
        self.voice_slider = QtWidgets.QSlider(QtCore.Qt.Orientation.Horizontal)
        self.voice_slider.setRange(0, 100)
        current_voice_vol = int(audio_manager._voice_volume * 100)
        self.voice_slider.setValue(current_voice_vol)
        self.voice_slider.valueChanged.connect(self._on_voice_volume_changed)
        audio_layout.addRow("Voice/TTS:", self.voice_slider)

        inner.addWidget(audio_group)

        # Password protection
        pwd_group = QtWidgets.QGroupBox("üîê Password Protection")
        pwd_layout = QtWidgets.QVBoxLayout(pwd_group)
        pwd_layout.addWidget(QtWidgets.QLabel("Set a password to prevent stopping Strict Mode sessions early."))
        self.pwd_status = QtWidgets.QLabel()
        pwd_layout.addWidget(self.pwd_status)
        pwd_btn_layout = QtWidgets.QHBoxLayout()
        set_pwd_btn = QtWidgets.QPushButton("Set Password")
        set_pwd_btn.clicked.connect(self._set_password)
        pwd_btn_layout.addWidget(set_pwd_btn)
        rem_pwd_btn = QtWidgets.QPushButton("Remove Password")
        rem_pwd_btn.clicked.connect(self._remove_password)
        pwd_btn_layout.addWidget(rem_pwd_btn)
        pwd_btn_layout.addStretch()
        pwd_layout.addLayout(pwd_btn_layout)
        inner.addWidget(pwd_group)
        self._update_pwd_status()

        # Mode explanations
        mode_group = QtWidgets.QGroupBox("üìã Session Modes")
        mode_layout = QtWidgets.QVBoxLayout(mode_group)
        mode_info = QtWidgets.QLabel(
            "<b>Normal:</b> Can stop anytime - good for flexibility<br>"
            "<b>Strict üîê:</b> Requires password to stop - prevents impulsive exits<br>"
            "<b>Hardcore üí™:</b> Must solve 2 math problems to stop - maximum commitment!<br>"
            "&nbsp;&nbsp;&nbsp;&nbsp;‚Ä¢ Numbers are displayed as images (no copy-paste)<br>"
            "&nbsp;&nbsp;&nbsp;&nbsp;‚Ä¢ Wrong answer = start over with new problems<br>"
            "<b>Pomodoro üçÖ:</b> 25 min work / 5 min break cycles - for productivity"
        )
        mode_info.setWordWrap(True)
        mode_info.setStyleSheet("padding: 10px; background-color: #2d2d30; color: #e0e0e0; border-radius: 5px; border: 1px solid #3e3e42;")
        mode_layout.addWidget(mode_info)
        inner.addWidget(mode_group)

        # Pomodoro settings
        pomo_group = QtWidgets.QGroupBox("üçÖ Pomodoro Settings")
        pomo_layout = QtWidgets.QFormLayout(pomo_group)
        self.pomo_work_spin = NoScrollSpinBox()
        self.pomo_work_spin.setRange(1, 120)
        self.pomo_work_spin.setValue(self.blocker.pomodoro_work)
        pomo_layout.addRow("Work duration (min):", self.pomo_work_spin)
        self.pomo_break_spin = NoScrollSpinBox()
        self.pomo_break_spin.setRange(1, 60)
        self.pomo_break_spin.setValue(self.blocker.pomodoro_break)
        pomo_layout.addRow("Short break (min):", self.pomo_break_spin)
        self.pomo_long_spin = NoScrollSpinBox()
        self.pomo_long_spin.setRange(1, 60)
        self.pomo_long_spin.setValue(self.blocker.pomodoro_long_break)
        pomo_layout.addRow("Long break (min):", self.pomo_long_spin)
        save_pomo_btn = QtWidgets.QPushButton("Save Pomodoro Settings")
        save_pomo_btn.clicked.connect(self._save_pomodoro)
        pomo_layout.addRow(save_pomo_btn)
        inner.addWidget(pomo_group)

        # Backup/Restore
        backup_group = QtWidgets.QGroupBox("üíæ Backup & Restore")
        backup_layout = QtWidgets.QVBoxLayout(backup_group)
        backup_layout.addWidget(QtWidgets.QLabel("Backup or restore all your data (settings, stats, goals)."))
        backup_btn_layout = QtWidgets.QHBoxLayout()
        create_backup_btn = QtWidgets.QPushButton("üì§ Create Backup")
        create_backup_btn.clicked.connect(self._create_backup)
        backup_btn_layout.addWidget(create_backup_btn)
        restore_backup_btn = QtWidgets.QPushButton("üì• Restore Backup")
        restore_backup_btn.clicked.connect(self._restore_backup)
        backup_btn_layout.addWidget(restore_backup_btn)
        backup_btn_layout.addStretch()
        backup_layout.addLayout(backup_btn_layout)
        
        # Export data (GDPR-compliant full export as ZIP)
        export_layout = QtWidgets.QHBoxLayout()
        export_btn = QtWidgets.QPushButton("üì¶ Export All Data (ZIP)")
        export_btn.setToolTip("Export all your data to a ZIP file for backup or data portability")
        export_btn.clicked.connect(self._export_all_data)
        export_layout.addWidget(export_btn)
        export_layout.addWidget(QtWidgets.QLabel("Complete data export for backup/GDPR"))
        export_layout.addStretch()
        backup_layout.addLayout(export_layout)
        
        inner.addWidget(backup_group)

        # Emergency cleanup
        cleanup_group = QtWidgets.QGroupBox("‚ö†Ô∏è Emergency Cleanup")
        cleanup_layout = QtWidgets.QVBoxLayout(cleanup_group)
        cleanup_layout.addWidget(QtWidgets.QLabel("Use if websites remain blocked after closing the app."))
        cleanup_btn = QtWidgets.QPushButton("üßπ Remove All Blocks & Clean System")
        cleanup_btn.clicked.connect(self._emergency_cleanup)
        cleanup_layout.addWidget(cleanup_btn)
        inner.addWidget(cleanup_group)

        # Voice Settings
        self.voice_group = QtWidgets.QGroupBox("üéôÔ∏è Voice Settings")
        voice_layout = QtWidgets.QVBoxLayout(self.voice_group)
        voice_layout.addWidget(QtWidgets.QLabel("Select a voice for TTS (Eye Routine, Celebration quotes)."))
        
        voice_combo_layout = QtWidgets.QHBoxLayout()
        voice_combo_layout.addWidget(QtWidgets.QLabel("Voice:"))
        self.voice_combo = NoScrollComboBox()
        self.voice_combo.setMinimumWidth(250)
        voice_combo_layout.addWidget(self.voice_combo)
        voice_combo_layout.addStretch()
        voice_layout.addLayout(voice_combo_layout)
        
        # Test voice button
        test_voice_btn = QtWidgets.QPushButton("üîä Test Voice")
        test_voice_btn.setMaximumWidth(150)
        test_voice_btn.clicked.connect(self._test_voice)
        voice_layout.addWidget(test_voice_btn)
        
        inner.addWidget(self.voice_group)
        
        # Populate voice combo after UI is built
        self._populate_voice_combo()

        # Global hotkey
        hotkey_group = QtWidgets.QGroupBox("üß≤ Global Hotkey")
        hotkey_layout = QtWidgets.QVBoxLayout(hotkey_group)
        hotkey_layout.addWidget(QtWidgets.QLabel(
            "Set a key combo to show/hide the window (minimize to tray when visible).\n"
            "Tip: Use at least one modifier (Ctrl/Alt/Shift/Win)."
        ))

        hotkey_row = QtWidgets.QHBoxLayout()
        hotkey_row.addWidget(QtWidgets.QLabel("Hotkey:"))
        self.hotkey_edit = QtWidgets.QKeySequenceEdit()
        self.hotkey_edit.setClearButtonEnabled(True)
        if self.blocker.toggle_hotkey:
            self.hotkey_edit.setKeySequence(QtGui.QKeySequence(self.blocker.toggle_hotkey))
        hotkey_row.addWidget(self.hotkey_edit)

        save_hotkey_btn = QtWidgets.QPushButton("Save Hotkey")
        save_hotkey_btn.clicked.connect(self._save_hotkey)
        hotkey_row.addWidget(save_hotkey_btn)

        clear_hotkey_btn = QtWidgets.QPushButton("Clear")
        clear_hotkey_btn.clicked.connect(self._clear_hotkey)
        hotkey_row.addWidget(clear_hotkey_btn)
        hotkey_row.addStretch()
        hotkey_layout.addLayout(hotkey_row)
        inner.addWidget(hotkey_group)

        # Enforcement Mode Group - Full vs Light
        enforce_group = QtWidgets.QGroupBox("üõ°Ô∏è Enforcement Mode")
        enforce_layout = QtWidgets.QVBoxLayout(enforce_group)
        
        # Current mode status with admin indicator
        self.enforce_status_label = QtWidgets.QLabel()
        self._update_enforcement_status()
        enforce_layout.addWidget(self.enforce_status_label)
        
        enforce_desc = QtWidgets.QLabel(
            "Choose how the app enforces focus sessions:"
        )
        enforce_desc.setWordWrap(True)
        enforce_layout.addWidget(enforce_desc)
        
        # Radio buttons for enforcement mode
        self.enforce_full_radio = QtWidgets.QRadioButton("üîí Full Mode (Recommended)")
        self.enforce_full_radio.setToolTip("Modifies system hosts file to block sites. Requires admin privileges.")
        self.enforce_light_radio = QtWidgets.QRadioButton("üîî Light Mode (No Admin Required)")
        self.enforce_light_radio.setToolTip("Monitors browser and shows notifications. Does not modify system files.")
        
        # Set current selection
        if self.blocker.enforcement_mode == EnforcementMode.LIGHT:
            self.enforce_light_radio.setChecked(True)
        else:
            self.enforce_full_radio.setChecked(True)
        
        self.enforce_full_radio.toggled.connect(self._toggle_enforcement_mode)
        
        enforce_layout.addWidget(self.enforce_full_radio)
        full_desc = QtWidgets.QLabel(
            "   ‚Ä¢ Blocks sites at system level - impossible to bypass\n"
            "   ‚Ä¢ Requires running the app as Administrator\n"
            "   ‚Ä¢ Best for serious focus sessions"
        )
        full_desc.setStyleSheet("color: #9ca3af; margin-left: 20px;")
        enforce_layout.addWidget(full_desc)
        
        enforce_layout.addWidget(self.enforce_light_radio)
        light_desc = QtWidgets.QLabel(
            "   ‚Ä¢ Shows reminder notifications when visiting blocked sites\n"
            "   ‚Ä¢ No admin privileges needed - minimal system impact\n"
            "   ‚Ä¢ Good for building awareness and habits"
        )
        light_desc.setStyleSheet("color: #9ca3af; margin-left: 20px;")
        enforce_layout.addWidget(light_desc)
        
        # Reset permission prompts button
        perm_reset_layout = QtWidgets.QHBoxLayout()
        perm_reset_layout.addSpacing(20)
        reset_perm_btn = QtWidgets.QPushButton("üîÑ Reset Permission Prompts")
        reset_perm_btn.setToolTip("Re-enable all 'Don't ask again' permission dialogs")
        reset_perm_btn.setMaximumWidth(220)
        reset_perm_btn.clicked.connect(self._reset_permission_prompts)
        perm_reset_layout.addWidget(reset_perm_btn)
        perm_reset_layout.addWidget(QtWidgets.QLabel("(Show permission dialogs again)"))
        perm_reset_layout.addStretch()
        enforce_layout.addLayout(perm_reset_layout)
        
        inner.addWidget(enforce_group)

        # System Tray (if available)
        if QtWidgets.QSystemTrayIcon.isSystemTrayAvailable():
            tray_group = QtWidgets.QGroupBox("üñ•Ô∏è System Tray")
            tray_layout = QtWidgets.QVBoxLayout(tray_group)
            self.tray_check = QtWidgets.QCheckBox("Minimize to system tray instead of closing")
            self.tray_check.setChecked(self.blocker.minimize_to_tray)  # Load from config
            self.tray_check.toggled.connect(self._toggle_tray)
            tray_layout.addWidget(self.tray_check)
            tray_layout.addWidget(QtWidgets.QLabel(
                "When enabled, clicking the close button will hide the app to the system tray.\n"
                "Double-click the tray icon to restore the window. Use 'Exit' to fully quit."
            ))
            
            # Startup sound setting
            tray_layout.addSpacing(10)
            self.startup_sound_check = QtWidgets.QCheckBox("üîî Play notification sound on startup")
            self.startup_sound_check.setChecked(self.blocker.startup_sound_enabled)
            self.startup_sound_check.toggled.connect(self._toggle_startup_sound)
            tray_layout.addWidget(self.startup_sound_check)
            
            # Test sound button
            sound_row = QtWidgets.QHBoxLayout()
            test_sound_btn = QtWidgets.QPushButton("üéµ Test Sound")
            test_sound_btn.setMaximumWidth(120)
            test_sound_btn.clicked.connect(self._test_startup_sound)
            sound_row.addWidget(test_sound_btn)
            sound_row.addWidget(QtWidgets.QLabel("Plays a random startup melody"))
            sound_row.addStretch()
            tray_layout.addLayout(sound_row)
            
            inner.addWidget(tray_group)

        # About
        about_group = QtWidgets.QGroupBox("About")
        about_layout = QtWidgets.QVBoxLayout(about_group)
        
        # Clickable version label (tap 7 times to enable Dev mode)
        self._version_label = QtWidgets.QLabel(f"Personal Liberty v{APP_VERSION}")
        self._version_label.setCursor(QtCore.Qt.PointingHandCursor)
        self._version_label.mousePressEvent = self._on_version_tap
        about_layout.addWidget(self._version_label)
        
        about_layout.addWidget(QtWidgets.QLabel("A focus and productivity tool for Windows"))
        
        # Developer info
        dev_label = QtWidgets.QLabel("Developed by <b>Lukasz Kaczmarek</b>")
        dev_label.setTextFormat(QtCore.Qt.RichText)
        about_layout.addWidget(dev_label)
        
        # Feedback/bug report link
        feedback_label = QtWidgets.QLabel(
            'üìß Send feedback / report bugs: '
            '<a href="mailto:lkacz1@gmail.com?subject=Personal Liberty Feedback" style="color: #64B5F6;">lkacz1@gmail.com</a>'
        )
        feedback_label.setTextFormat(QtCore.Qt.RichText)
        feedback_label.setOpenExternalLinks(True)
        feedback_label.setCursor(QtCore.Qt.PointingHandCursor)
        about_layout.addWidget(feedback_label)
        
        # Show dev mode status hint if enabled
        if self.blocker.dev_mode_enabled:
            dev_hint = QtWidgets.QLabel("üõ†Ô∏è Developer mode enabled")
            dev_hint.setStyleSheet("color: #ff9800; font-style: italic;")
            about_layout.addWidget(dev_hint)
        
        inner.addWidget(about_group)

        # Factory Reset - DANGER ZONE
        reset_group = QtWidgets.QGroupBox("üö® Danger Zone")
        reset_group.setStyleSheet("""
            QGroupBox {
                border: 2px solid #e53935;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                color: #e53935;
            }
        """)
        reset_layout = QtWidgets.QVBoxLayout(reset_group)
        reset_warning = QtWidgets.QLabel(
            "‚ö†Ô∏è <b>Factory Reset</b> will permanently delete ALL your data including:\n"
            "‚Ä¢ All statistics and history\n"
            "‚Ä¢ Weight, sleep, activity, and water tracking data\n"
            "‚Ä¢ Hero progress, XP, gear, and story decisions\n"
            "‚Ä¢ All settings and preferences\n\n"
            "<b>This action cannot be undone!</b>"
        )
        reset_warning.setWordWrap(True)
        reset_warning.setStyleSheet("color: #ff8a80; padding: 10px; background-color: #2a1a1a; border-radius: 5px;")
        reset_layout.addWidget(reset_warning)
        reset_btn = QtWidgets.QPushButton("üóëÔ∏è Factory Reset - Delete All Data")
        reset_btn.setStyleSheet("""
            QPushButton {
                background-color: #c62828;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #e53935;
            }
        """)
        reset_btn.clicked.connect(self._factory_reset)
        reset_layout.addWidget(reset_btn)
        inner.addWidget(reset_group)

        inner.addStretch()
        scroll.setWidget(container)
        layout.addWidget(scroll)

    def _update_pwd_status(self) -> None:
        if self.blocker.password_hash:
            self.pwd_status.setText("üîê Password is set")
            self.pwd_status.setStyleSheet("color: green;")
        else:
            self.pwd_status.setText("No password set")
            self.pwd_status.setStyleSheet("color: gray;")

    def _on_sound_volume_changed(self, value: int) -> None:
        from entitidex.celebration_audio import CelebrationAudioManager
        CelebrationAudioManager.get_instance().set_sound_volume(value / 100.0)

    def _on_voice_volume_changed(self, value: int) -> None:
        from entitidex.celebration_audio import CelebrationAudioManager
        CelebrationAudioManager.get_instance().set_voice_volume(value / 100.0)

    def _switch_user(self) -> None:
        """Switch to a different user profile without restarting the app."""
        # Check if a session is running - require stop first
        main_window = self.window()
        if hasattr(main_window, 'timer_tab') and main_window.timer_tab.timer_running:
            show_warning(
                self, 
                "Session Active",
                "A focus session is currently running.\n\n"
                "Please stop the session before switching profiles."
            )
            return
        
        # Check if GameState has pending batch operations
        if hasattr(main_window, 'game_state') and main_window.game_state:
            if getattr(main_window.game_state, '_batch_depth', 0) > 0:
                show_warning(
                    self,
                    "Operation in Progress",
                    "A game operation is currently in progress.\n\n"
                    "Please wait for it to complete before switching profiles."
                )
                return
        
        if show_question(self, "Switch User", 
                        "Are you sure you want to switch profiles?") == QtWidgets.QMessageBox.Yes:
            try:
                from core_logic import APP_DIR
                from user_manager import UserManager
                from user_selection_dialog import UserSelectionDialog
                
                # Save current user's config first
                self.blocker.save_config()
                # Ensure stats are saved to prevent data loss during switch
                self.blocker.save_stats()
                
                # Show user selection dialog
                um = UserManager(APP_DIR)
                selection_dialog = UserSelectionDialog(um, parent=main_window)
                
                if selection_dialog.exec() == QtWidgets.QDialog.Accepted:
                    new_user = selection_dialog.selected_user
                    if new_user and new_user != main_window.username:
                        # Save new user as last user
                        um.save_last_user(new_user)
                        
                        # Reload the main window with new user
                        main_window._reload_user(new_user)
                        
                        show_info(self, "Profile Switched", f"Switched to profile: {new_user}")
                    elif new_user == main_window.username:
                        show_info(self, "Same Profile", "You selected the same profile.")
                        
            except Exception as e:
                show_error(self, "Error", f"Could not switch user: {e}")

    def _set_password(self) -> None:
        pwd, ok = QtWidgets.QInputDialog.getText(self, "Set Password", "Enter new password:", QtWidgets.QLineEdit.Password)
        if not ok or not pwd:
            return
        confirm, ok = QtWidgets.QInputDialog.getText(self, "Confirm", "Confirm password:", QtWidgets.QLineEdit.Password)
        if ok and pwd == confirm:
            self.blocker.set_password(pwd)
            self._update_pwd_status()
            show_info(self, "Password Set", "Your password has been set successfully!")
        else:
            show_warning(self, "Password Mismatch", "The passwords you entered don't match. Please try again.")

    def _remove_password(self) -> None:
        if not self.blocker.password_hash:
            show_info(self, "Info", "No password set")
            return
        pwd, ok = QtWidgets.QInputDialog.getText(self, "Remove Password", "Enter current password:", QtWidgets.QLineEdit.Password)
        if ok and self.blocker.verify_password(pwd or ""):
            self.blocker.set_password(None)
            self._update_pwd_status()
        else:
            show_warning(self, "Incorrect Password", "The password you entered is incorrect.")

    def _save_pomodoro(self) -> None:
        self.blocker.pomodoro_work = self.pomo_work_spin.value()
        self.blocker.pomodoro_break = self.pomo_break_spin.value()
        self.blocker.pomodoro_long_break = self.pomo_long_spin.value()
        self.blocker.save_config()
        show_info(self, "Saved", "Pomodoro settings saved!")

    def _create_backup(self) -> None:
        import json
        from datetime import datetime
        path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Save Backup", "", "JSON Files (*.json)")
        if not path:
            return
        try:
            backup_data = {
                "backup_version": APP_VERSION,
                "backup_date": datetime.now().isoformat(),
                "config": {
                    "blacklist": self.blocker.blacklist,
                    "whitelist": self.blocker.whitelist,
                    "categories_enabled": self.blocker.categories_enabled,
                    "pomodoro_work": self.blocker.pomodoro_work,
                    "pomodoro_break": self.blocker.pomodoro_break,
                    "pomodoro_long_break": self.blocker.pomodoro_long_break,
                    "schedules": self.blocker.schedules,
                    "priorities": self.blocker.priorities,
                    "show_priorities_on_startup": self.blocker.show_priorities_on_startup,
                    "ask_priority_on_session_start": self.blocker.ask_priority_on_session_start,
                    "priority_checkin_enabled": self.blocker.priority_checkin_enabled,
                    "priority_checkin_interval": self.blocker.priority_checkin_interval,
                    "adhd_buster": self.blocker.adhd_buster,
                },
                "stats": self.blocker.stats,
            }
            # Include goals if available
            if FocusGoals and self.blocker.goals_path.exists():
                try:
                    with open(self.blocker.goals_path, "r", encoding="utf-8") as gf:
                        backup_data["goals"] = json.load(gf)
                except Exception:
                    pass
            with open(path, "w", encoding="utf-8") as f:
                json.dump(backup_data, f, indent=2)
            show_info(self, "Backup Complete", "Backup saved successfully!")
        except Exception as e:
            show_error(self, "Backup Failed", str(e))

    def _restore_backup(self) -> None:
        import json
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select Backup", "", "JSON Files (*.json)")
        if not path:
            return
        try:
            with open(path, "r", encoding="utf-8") as f:
                data = json.load(f)
            if "backup_version" not in data:
                show_warning(self, "Invalid", "Not a valid backup file.")
                return
            if show_question(self, "Confirm", "Restore backup? This will replace all current data.") != QtWidgets.QMessageBox.Yes:
                return
            config = data.get("config", {})
            self.blocker.blacklist = config.get("blacklist", self.blocker.blacklist)
            self.blocker.whitelist = config.get("whitelist", self.blocker.whitelist)
            self.blocker.categories_enabled = config.get("categories_enabled", self.blocker.categories_enabled)
            self.blocker.pomodoro_work = config.get("pomodoro_work", self.blocker.pomodoro_work)
            self.blocker.pomodoro_break = config.get("pomodoro_break", self.blocker.pomodoro_break)
            self.blocker.pomodoro_long_break = config.get("pomodoro_long_break", self.blocker.pomodoro_long_break)
            self.blocker.schedules = config.get("schedules", self.blocker.schedules)
            self.blocker.priorities = config.get("priorities", self.blocker.priorities)
            self.blocker.show_priorities_on_startup = config.get("show_priorities_on_startup", self.blocker.show_priorities_on_startup)
            self.blocker.ask_priority_on_session_start = config.get("ask_priority_on_session_start", self.blocker.ask_priority_on_session_start)
            self.blocker.priority_checkin_enabled = config.get("priority_checkin_enabled", self.blocker.priority_checkin_enabled)
            self.blocker.priority_checkin_interval = config.get("priority_checkin_interval", self.blocker.priority_checkin_interval)
            self.blocker.adhd_buster = config.get("adhd_buster", self.blocker.adhd_buster)
            self.blocker.save_config()
            stats = data.get("stats", {})
            self.blocker.stats = {**self.blocker._default_stats(), **stats}
            self.blocker.save_stats()

            # Restore goals if present
            if FocusGoals and "goals" in data:
                try:
                    with open(self.blocker.goals_path, "w", encoding="utf-8") as gf:
                        json.dump(data["goals"], gf, indent=2)
                except Exception:
                    pass

            # Refresh UI
            self.pomo_work_spin.setValue(self.blocker.pomodoro_work)
            self.pomo_break_spin.setValue(self.blocker.pomodoro_break)
            self.pomo_long_spin.setValue(self.blocker.pomodoro_long_break)
            self._update_pwd_status()

            main_win = self.window()
            if hasattr(main_win, "sites_tab"):
                main_win.sites_tab._refresh_lists()
            if hasattr(main_win, "categories_tab"):
                main_win.categories_tab.refresh()
            if hasattr(main_win, "schedule_tab"):
                main_win.schedule_tab._refresh_table()
            if hasattr(main_win, "stats_tab"):
                main_win.stats_tab.refresh()
            if hasattr(main_win, "ai_tab") and AI_AVAILABLE:
                main_win.ai_tab._refresh_data()

            show_info(self, "Restored", "Backup restored successfully!")
        except Exception as e:
            show_error(self, "Restore Failed", str(e))

    def _export_all_data(self) -> None:
        """Export all user data to a ZIP file."""
        from datetime import datetime
        
        # Generate default filename with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        username = self.blocker.username or "Default"
        default_name = f"PersonalLiberty_{username}_{timestamp}.zip"
        
        path, _ = QtWidgets.QFileDialog.getSaveFileName(
            self, 
            "Export All Data", 
            default_name, 
            "ZIP Files (*.zip)"
        )
        if not path:
            return
        
        # Show progress cursor
        self.setCursor(QtCore.Qt.WaitCursor)
        try:
            result = self.blocker.export_all_data(path)
            
            if result["success"]:
                file_count = len(result["files"])
                file_list = result["files"][:5]  # Show first 5
                file_display = "\n‚Ä¢ ".join(file_list)
                more_msg = f"\n‚Ä¢ ... and {file_count - 5} more" if file_count > 5 else ""
                
                show_info(
                    self, 
                    "Export Complete", 
                    f"‚úÖ {result['message']}\n\n"
                    f"Exported files:\n‚Ä¢ {file_display}{more_msg}"
                )
            else:
                show_error(self, "Export Failed", result["message"])
        finally:
            self.setCursor(QtCore.Qt.ArrowCursor)

    def _emergency_cleanup(self) -> None:
        """Emergency cleanup with enhanced confirmation dialog."""
        # Extra warning for strict/hardcore modes
        mode = getattr(self.blocker, 'mode', None)
        if mode in (BlockMode.STRICT, BlockMode.HARDCORE) and self.blocker.is_blocking:
            reply = show_question(
                self, "‚ö†Ô∏è Active Session Detected",
                f"You have an active {mode.upper()} session!\n\n"
                "Emergency cleanup will bypass the protection you set.\n"
                "This defeats the purpose of using a strict mode.\n\n"
                "Are you SURE you want to proceed?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                QtWidgets.QMessageBox.No
            )
            if reply != QtWidgets.QMessageBox.Yes:
                return
        
        # Gather impact data
        impact_data = {
            "items_count": 0,
            "power_lost": 0,
            "progress_percent": 0,
            "coins_refund": 0,
            "items_affected": []
        }
        
        # Calculate impact from inventory
        if GAMIFICATION_AVAILABLE:
            inventory = self.blocker.adhd_buster.get("inventory", [])
            impact_data["items_count"] = len(inventory)
            impact_data["power_lost"] = self.blocker.adhd_buster.get("total_power", 0)
            impact_data["items_affected"] = inventory[:20]  # Show first 20
            
            # Calculate progress percentage
            total_xp = self.blocker.adhd_buster.get("total_xp", 0)
            if total_xp > 0:
                impact_data["progress_percent"] = min(100, int((total_xp / 10000) * 100))
        
        # Show enhanced confirmation dialog
        confirmed = show_emergency_cleanup_dialog("emergency_cleanup", impact_data, self)
        
        if not confirmed:
            return
        
        success, message = self.blocker.emergency_cleanup()
        if success:
            show_info(self, "Cleanup Complete", message)
            # Reset Timer UI
            main_win = self.window()
            if hasattr(main_win, "timer_tab"):
                main_win.timer_tab._force_stop_session()
        else:
            show_error(self, "Cleanup Failed", message)

    def _factory_reset(self) -> None:
        """Factory reset - delete all user data after multiple confirmations."""
        # First confirmation
        reply1 = show_question(
            self, "‚ö†Ô∏è Factory Reset Warning",
            "You are about to DELETE ALL YOUR DATA!\n\n"
            "This includes:\n"
            "‚Ä¢ All statistics and session history\n"
            "‚Ä¢ Weight, sleep, activity, and water tracking\n"
            "‚Ä¢ Hero progress, XP, level, gear, and story\n"
            "‚Ä¢ Blocked sites and categories\n"
            "‚Ä¢ All settings and preferences\n\n"
            "This action CANNOT be undone!\n\n"
            "Are you sure you want to continue?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            QtWidgets.QMessageBox.No
        )
        if reply1 != QtWidgets.QMessageBox.Yes:
            return
        
        # Second confirmation with typing requirement
        confirm_text, ok = QtWidgets.QInputDialog.getText(
            self, "Confirm Factory Reset",
            "To confirm deletion, type 'DELETE' (all caps):",
            QtWidgets.QLineEdit.Normal
        )
        if not ok or confirm_text != "DELETE":
            show_info(self, "Cancelled", "Factory reset was cancelled. Your data is safe.")
            return
        
        # Final warning
        reply3 = show_question(
            self, "üö® FINAL WARNING",
            "THIS IS YOUR LAST CHANCE!\n\n"
            "All your progress will be permanently deleted.\n"
            "There is NO way to recover this data.\n\n"
            "Proceed with factory reset?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            QtWidgets.QMessageBox.No
        )
        if reply3 != QtWidgets.QMessageBox.Yes:
            show_info(self, "Cancelled", "Factory reset was cancelled. Your data is safe.")
            return
        
        # Perform the reset
        try:
            # Get data directory
            data_dir = APP_DIR
            
            # Files to delete
            files_to_delete = [
                "config.json",
                "stats.json",
                "goals.json",
            ]
            
            deleted_count = 0
            for filename in files_to_delete:
                filepath = data_dir / filename
                if filepath.exists():
                    try:
                        filepath.unlink()
                        deleted_count += 1
                    except Exception as e:
                        print(f"Failed to delete {filename}: {e}")
            
            # Reset in-memory state
            self.blocker.blocked_sites = []
            self.blocker.blocked_categories = []
            self.blocker.schedules = []
            self.blocker.password_hash = None
            self.blocker.is_blocking = False
            self.blocker.mode = BlockMode.NORMAL
            self.blocker.stats = {
                "total_sessions": 0,
                "total_focus_time": 0,
                "longest_session": 0,
                "daily_stats": {},
            }
            
            # Reset tracking data
            self.blocker.weight_entries = []
            self.blocker.sleep_entries = []
            self.blocker.activity_entries = []
            self.blocker.water_entries = []
            
            # Reset gamification data
            if GAMIFICATION_AVAILABLE:
                self.blocker.adhd_buster = {
                    "inventory": [],
                    "equipped": {},
                    "total_xp": 0,
                    "coins": 0,
                    "total_power": 0,
                    "current_chapter": 0,
                    "story_decisions": {},
                }
            
            # Reset goals
            self.blocker.goals = {
                "daily_focus_minutes": 120,
                "daily_sessions": 4,
            }
            
            # Save clean state
            self.blocker.save_config()
            self.blocker.save_stats()
            
            show_info(
                self, "Factory Reset Complete",
                f"All data has been deleted ({deleted_count} files removed).\n\n"
                "The application will now restart with a fresh state.\n"
                "Please restart the application."
            )
            
            # Close the application
            main_window = self.window()
            if main_window:
                main_window.close()
                
        except Exception as e:
            show_error(self, "Reset Failed", f"An error occurred during reset:\n{str(e)}")

    def _toggle_tray(self, checked: bool) -> None:
        """Toggle minimize to tray setting and save to config."""
        main_window = self.window()
        if hasattr(main_window, 'minimize_to_tray'):
            main_window.minimize_to_tray = checked
            # Persist the setting
            self.blocker.minimize_to_tray = checked
            self.blocker.save_config()

    def _toggle_startup_sound(self, checked: bool) -> None:
        """Toggle startup sound setting and save to config."""
        self.blocker.startup_sound_enabled = checked
        self.blocker.save_config()

    def _test_startup_sound(self) -> None:
        """Play a test startup sound."""
        try:
            from startup_sounds import play_startup_sound, is_sound_available
            if is_sound_available():
                play_startup_sound()
            else:
                show_info(self, "Sound Unavailable", "Sound playback is not available on this system.")
        except ImportError:
            show_info(self, "Sound Unavailable", "Startup sounds module not found.")

    def _update_enforcement_status(self) -> None:
        """Update the enforcement mode status label with current mode and admin status."""
        is_admin = self._check_admin_status()
        current_mode = self.blocker.enforcement_mode
        
        if current_mode == EnforcementMode.LIGHT:
            mode_text = "üîî <b>Light Mode</b> active ‚Äî notifications only, no system changes"
            status_style = "color: #F59E0B; padding: 8px; background: rgba(245, 158, 11, 0.1); border-radius: 4px;"
        else:
            if is_admin:
                mode_text = "üîí <b>Full Mode</b> active ‚Äî sites blocked at system level ‚úÖ"
                status_style = "color: #10B981; padding: 8px; background: rgba(16, 185, 129, 0.1); border-radius: 4px;"
            else:
                mode_text = (
                    "üîí <b>Full Mode</b> selected but <span style='color: #EF4444;'>NOT running as Admin</span><br>"
                    "&nbsp;&nbsp;&nbsp;&nbsp;‚ö†Ô∏è Blocking will fail! Restart as Administrator or switch to Light Mode."
                )
                status_style = "color: #F59E0B; padding: 8px; background: rgba(239, 68, 68, 0.1); border-radius: 4px;"
        
        self.enforce_status_label.setText(mode_text)
        self.enforce_status_label.setStyleSheet(status_style)
        self.enforce_status_label.setWordWrap(True)

    def _check_admin_status(self) -> bool:
        """Check if running with admin privileges."""
        try:
            import ctypes
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        except Exception:
            return False

    def _toggle_enforcement_mode(self, full_mode_checked: bool) -> None:
        """Toggle between Full and Light enforcement modes."""
        if full_mode_checked:
            self.blocker.enforcement_mode = EnforcementMode.FULL
        else:
            self.blocker.enforcement_mode = EnforcementMode.LIGHT
        self.blocker.save_config()
        
        # Update status label
        self._update_enforcement_status()
        
        # Update the main window's enforcement mode display if needed
        main_window = self.window()
        if hasattr(main_window, '_update_enforcement_mode_display'):
            main_window._update_enforcement_mode_display()

    def _reset_permission_prompts(self) -> None:
        """Reset all 'Don't ask again' permission preferences."""
        if not self.blocker.system_permissions:
            show_info(self, "No Permissions Saved", 
                     "You haven't saved any 'Don't ask again' preferences yet.")
            return
        
        count = len(self.blocker.system_permissions)
        confirm = show_question(
            self, 
            "Reset Permission Prompts?",
            f"This will re-enable {count} permission dialog(s).\n\n"
            "You will be asked for approval again when the app needs to:\n"
            "‚Ä¢ Modify the hosts file (for Full Mode blocking)\n\n"
            "Continue?"
        )
        
        if confirm == QtWidgets.QMessageBox.Yes:
            self.blocker.system_permissions = {}
            self.blocker.save_config()
            show_info(self, "Permissions Reset", 
                     "All permission prompts have been reset.\n"
                     "You will be asked for approval next time the app needs system access.")

    def _save_hotkey(self) -> None:
        """Save and register the global hotkey."""
        seq = self.hotkey_edit.keySequence().toString().strip()
        main_window = self.window()
        if hasattr(main_window, "_apply_hotkey_setting"):
            ok = main_window._apply_hotkey_setting(seq)
            if ok:
                show_info(self, "Saved", "Hotkey saved!")
            else:
                show_warning(self, "Invalid Hotkey", "Please choose a valid key combination with at least one modifier (Ctrl/Alt/Shift/Win).")
        else:
            self.blocker.toggle_hotkey = seq
            self.blocker.save_config()
            show_info(self, "Saved", "Hotkey saved!")

    def _clear_hotkey(self) -> None:
        """Clear the hotkey and unregister it."""
        self.hotkey_edit.setKeySequence(QtGui.QKeySequence())
        main_window = self.window()
        if hasattr(main_window, "_apply_hotkey_setting"):
            main_window._apply_hotkey_setting("")
        self.blocker.toggle_hotkey = ""
        self.blocker.save_config()
        show_info(self, "Cleared", "Hotkey cleared.")

    def _populate_voice_combo(self) -> None:
        """Populate the voice selection combo with available voices."""
        try:
            from eye_protection_tab import GuidanceManager
            guidance = GuidanceManager.get_instance()
            voices = guidance.get_voice_names()
            self.voice_combo.clear()
            
            # If no voices available (Piper not working), hide the group
            if not voices:
                self.voice_group.hide()
                return

            self.voice_combo.addItems(voices)
            # Set current selection
            current = guidance.get_current_voice()
            if current in voices:
                self.voice_combo.setCurrentText(current)
            # Connect after populating to avoid triggering on initial setup
            self.voice_combo.currentTextChanged.connect(self._change_voice)
        except Exception as e:
            print(f"[SettingsTab] Error populating voice combo: {e}")
            self.voice_combo.addItem("Default Voice")

    def _change_voice(self, voice_name: str) -> None:
        """Change the TTS voice."""
        try:
            from eye_protection_tab import GuidanceManager
            guidance = GuidanceManager.get_instance()
            guidance.set_voice(voice_name, save=True)
        except Exception as e:
            print(f"[SettingsTab] Error changing voice: {e}")

    def _test_voice(self) -> None:
        """Test the selected voice with a sample phrase."""
        try:
            from eye_protection_tab import GuidanceManager
            guidance = GuidanceManager.get_instance()
            guidance.say("Hello! This is a voice preview. How do I sound?")
        except Exception as e:
            print(f"[SettingsTab] Error testing voice: {e}")
            show_warning(
                self, "Voice Test Failed",
                f"Could not test voice: {e}"
            )

    def _on_version_tap(self, event) -> None:
        """Handle taps on version label - 7 taps enables Dev mode (Android-style)."""
        if self.blocker.dev_mode_enabled:
            # Already enabled - do nothing special
            return
        
        self._dev_tap_count += 1
        
        # Reset tap counter after 2 seconds of no taps
        if self._dev_tap_timer:
            self._dev_tap_timer.stop()
        self._dev_tap_timer = QtCore.QTimer()
        self._dev_tap_timer.setSingleShot(True)
        self._dev_tap_timer.timeout.connect(self._reset_dev_tap_counter)
        self._dev_tap_timer.start(2000)
        
        remaining = 7 - self._dev_tap_count
        
        if remaining > 0 and remaining <= 3:
            # Show hint when getting close
            self._version_label.setText(f"Personal Liberty v{APP_VERSION}  ({remaining} more taps...)")
        elif remaining <= 0:
            # Developer mode enabled!
            self.blocker.dev_mode_enabled = True
            self.blocker.save_config()
            
            self._version_label.setText(f"Personal Liberty v{APP_VERSION}  üõ†Ô∏è")
            
            # Show confirmation
            styled_info(
                self, "üõ†Ô∏è Developer Mode Enabled",
                "You've unlocked Developer Mode!\n\n"
                "A new 'Dev' tab has been added with testing tools.\n\n"
                "Note: This is intended for development and testing only. "
                "Use with caution!"
            )
            
            # Emit signal to parent to add the Dev tab
            self.dev_mode_enabled.emit()
            self._dev_tap_count = 0

    def _reset_dev_tap_counter(self) -> None:
        """Reset the dev mode tap counter."""
        self._dev_tap_count = 0
        if not self.blocker.dev_mode_enabled:
            self._version_label.setText(f"Personal Liberty v{APP_VERSION}")


class WeightChartWidget(QtWidgets.QWidget):
    """Custom widget that draws a weight progress chart using Qt's built-in painting.
    
    Features:
    - Date-based X-axis (proper time spacing)
    - Gap handling with dashed lines for missing days
    - 7-day moving average trend line (for 7+ entries)
    - Weekly binning with min/max bands (for 30+ entries)
    - Trend direction indicator
    - Context-colored data points (morning, evening, etc.)
    """
    
    # Mode thresholds
    WEEKLY_BIN_THRESHOLD = 30  # Switch to weekly binning after this many entries
    MOVING_AVG_WINDOW = 7     # 7-day moving average
    
    # Context colors for different logging occasions
    CONTEXT_COLORS = {
        "morning": "#FFD700",     # Gold - morning
        "evening": "#9370DB",     # Purple - evening
        "post_workout": "#00CED1", # Cyan - post-workout
        "fasted": "#98FB98",      # Pale green - fasted
        "post_meal": "#FFA07A",   # Light salmon - post-meal
        "": "#6496ff",            # Default blue - no context
    }
    
    def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.weight_data = []  # List of (date_str, weight, context) tuples
        self.goal_weight = None
        self.unit = "kg"
        self.setMinimumHeight(250)
        self.setMinimumWidth(400)
    
    def set_data(self, entries: list, goal: float = None, unit: str = "kg") -> None:
        """Set the weight data to display."""
        # Sort by date and filter valid entries, include context
        valid_entries = [(e["date"], e["weight"], e.get("note", "")) for e in entries 
                        if e.get("date") and e.get("weight")]
        self.weight_data = sorted(valid_entries, key=lambda x: x[0])
        self.goal_weight = goal
        self.unit = unit
        self.update()
    
    def _parse_date(self, date_str: str):
        """Parse date string to datetime object."""
        from datetime import datetime
        try:
            return datetime.strptime(date_str, "%Y-%m-%d")
        except ValueError:
            return None
    
    def _calculate_weekly_bins(self) -> list:
        """Calculate weekly bins with avg, min, max for each week."""
        from datetime import datetime, timedelta
        
        if not self.weight_data:
            return []
        
        bins = []
        first_date = self._parse_date(self.weight_data[0][0])
        last_date = self._parse_date(self.weight_data[-1][0])
        
        if not first_date or not last_date:
            return []
        
        # Group by week
        current_week_start = first_date
        while current_week_start <= last_date:
            week_end = current_week_start + timedelta(days=6)
            
            # Find weights in this week
            week_weights = []
            for date_str, weight, context in self.weight_data:
                d = self._parse_date(date_str)
                if d and current_week_start <= d <= week_end:
                    week_weights.append(weight)
            
            if week_weights:
                bins.append({
                    "date": current_week_start,
                    "avg": sum(week_weights) / len(week_weights),
                    "min": min(week_weights),
                    "max": max(week_weights),
                    "count": len(week_weights),
                })
            
            current_week_start += timedelta(days=7)
        
        return bins
    
    def _calculate_moving_average(self) -> list:
        """Calculate 7-day moving average for each data point."""
        from datetime import datetime, timedelta
        
        if len(self.weight_data) < self.MOVING_AVG_WINDOW:
            return []
        
        ma_data = []
        
        for i, (date_str, weight, context) in enumerate(self.weight_data):
            current_date = self._parse_date(date_str)
            if not current_date:
                continue
            
            # Get weights from past 7 days
            window_start = current_date - timedelta(days=self.MOVING_AVG_WINDOW - 1)
            window_weights = []
            
            for d_str, w, ctx in self.weight_data:
                d = self._parse_date(d_str)
                if d and window_start <= d <= current_date:
                    window_weights.append(w)
            
            if len(window_weights) >= 3:  # Need at least 3 points for meaningful average
                ma_data.append((date_str, sum(window_weights) / len(window_weights)))
        
        return ma_data
    
    def _calculate_trend(self) -> tuple:
        """Calculate overall trend direction and rate.
        
        Returns:
            (direction, rate_per_week, r_squared)
            direction: "down", "up", or "stable"
            rate_per_week: kg change per week
            r_squared: strength of trend (0-1)
        """
        if len(self.weight_data) < 3:
            return ("stable", 0, 0)
        
        from datetime import datetime
        
        # Simple linear regression
        dates = []
        weights = []
        first_date = self._parse_date(self.weight_data[0][0])
        
        for date_str, weight, context in self.weight_data:
            d = self._parse_date(date_str)
            if d and first_date:
                days = (d - first_date).days
                dates.append(days)
                weights.append(weight)
        
        if len(dates) < 3:
            return ("stable", 0, 0)
        
        n = len(dates)
        sum_x = sum(dates)
        sum_y = sum(weights)
        sum_xy = sum(x * y for x, y in zip(dates, weights))
        sum_x2 = sum(x * x for x in dates)
        sum_y2 = sum(y * y for y in weights)
        
        # Slope (rate per day)
        denom = n * sum_x2 - sum_x ** 2
        if denom == 0:
            return ("stable", 0, 0)
        
        slope = (n * sum_xy - sum_x * sum_y) / denom
        
        # R-squared
        mean_y = sum_y / n
        ss_tot = sum((y - mean_y) ** 2 for y in weights)
        
        if ss_tot == 0:
            r_squared = 1.0
        else:
            intercept = (sum_y - slope * sum_x) / n
            ss_res = sum((y - (slope * x + intercept)) ** 2 for x, y in zip(dates, weights))
            r_squared = 1 - (ss_res / ss_tot)
        
        # Rate per week (slope * 7)
        rate_per_week = slope * 7
        
        # Determine direction
        if abs(rate_per_week) < 0.1:  # Less than 100g per week
            direction = "stable"
        elif rate_per_week < 0:
            direction = "down"
        else:
            direction = "up"
        
        return (direction, rate_per_week, max(0, r_squared))
    
    def paintEvent(self, event) -> None:
        """Paint the weight chart."""
        from datetime import datetime, timedelta
        
        painter = QtGui.QPainter(self)
        painter.setRenderHint(QtGui.QPainter.RenderHint.Antialiasing)
        
        rect = self.rect()
        margin_left = 55
        margin_right = 20
        margin_top = 35  # More space for trend indicator
        margin_bottom = 45
        chart_rect = QtCore.QRect(
            margin_left, margin_top, 
            rect.width() - margin_left - margin_right, 
            rect.height() - margin_top - margin_bottom
        )
        
        # Background
        painter.fillRect(rect, QtGui.QColor("#1a1a2e"))
        
        # Draw border
        painter.setPen(QtGui.QPen(QtGui.QColor("#4a4a6a"), 1))
        painter.drawRect(chart_rect)
        
        if len(self.weight_data) < 2:
            # Not enough data
            painter.setPen(QtGui.QColor("#888888"))
            painter.setFont(QtGui.QFont("Segoe UI", 12))
            painter.drawText(chart_rect, QtCore.Qt.AlignmentFlag.AlignCenter, 
                           "Enter at least 2 weight entries\nto see your progress chart")
            return
        
        # Determine if we should use weekly binning
        use_weekly_bins = len(self.weight_data) >= self.WEEKLY_BIN_THRESHOLD
        
        # Calculate date range
        first_date = self._parse_date(self.weight_data[0][0])
        last_date = self._parse_date(self.weight_data[-1][0])
        
        if not first_date or not last_date:
            return
        
        total_days = max(1, (last_date - first_date).days)
        
        # Calculate weight range
        weights = [w for _, w, ctx in self.weight_data]
        min_weight = min(weights)
        max_weight = max(weights)
        
        # Include goal in range if set
        if self.goal_weight:
            min_weight = min(min_weight, self.goal_weight)
            max_weight = max(max_weight, self.goal_weight)
        
        # Add padding to range
        weight_range = max_weight - min_weight
        if weight_range < 1:
            weight_range = 2
        min_weight -= weight_range * 0.1
        max_weight += weight_range * 0.1
        weight_range = max_weight - min_weight
        
        # Helper functions
        def date_to_x(date):
            if isinstance(date, str):
                date = self._parse_date(date)
            if not date:
                return chart_rect.left()
            days_from_start = (date - first_date).days
            return chart_rect.left() + (chart_rect.width() * days_from_start / total_days)
        
        def weight_to_y(weight):
            return chart_rect.top() + chart_rect.height() * (max_weight - weight) / weight_range
        
        # Draw trend indicator at top
        direction, rate, r_sq = self._calculate_trend()
        painter.setFont(QtGui.QFont("Segoe UI", 10))
        if direction == "down":
            trend_color = QtGui.QColor("#00ff88")
            trend_text = f"‚Üì Losing {abs(rate)*1000:.0f}g/week"
        elif direction == "up":
            trend_color = QtGui.QColor("#ff6464")
            trend_text = f"‚Üë Gaining {abs(rate)*1000:.0f}g/week"
        else:
            trend_color = QtGui.QColor("#ffff64")
            trend_text = "‚Üí Stable"
        
        if r_sq > 0.5:
            trend_text += f" (strong trend)"
        elif r_sq > 0.2:
            trend_text += f" (moderate trend)"
        
        painter.setPen(trend_color)
        painter.drawText(margin_left, 20, trend_text)
        
        # Draw grid lines and labels
        painter.setPen(QtGui.QPen(QtGui.QColor("#333355"), 1, QtCore.Qt.PenStyle.DashLine))
        num_lines = 5
        for i in range(num_lines + 1):
            y = chart_rect.top() + (chart_rect.height() * i / num_lines)
            painter.drawLine(chart_rect.left(), int(y), chart_rect.right(), int(y))
            
            # Weight label
            weight_val = max_weight - (weight_range * i / num_lines)
            painter.setPen(QtGui.QColor("#888888"))
            painter.setFont(QtGui.QFont("Segoe UI", 9))
            label = f"{weight_val:.1f}"
            painter.drawText(5, int(y) + 4, label)
            painter.setPen(QtGui.QPen(QtGui.QColor("#333355"), 1, QtCore.Qt.PenStyle.DashLine))
        
        # Draw goal line if set
        if self.goal_weight and min_weight <= self.goal_weight <= max_weight:
            goal_y = weight_to_y(self.goal_weight)
            painter.setPen(QtGui.QPen(QtGui.QColor("#00ff88"), 2, QtCore.Qt.PenStyle.DashLine))
            painter.drawLine(chart_rect.left(), int(goal_y), chart_rect.right(), int(goal_y))
            painter.setPen(QtGui.QColor("#00ff88"))
            goal_display = self.goal_weight * 2.20462 if self.unit == "lbs" else self.goal_weight
            painter.drawText(chart_rect.right() - 60, int(goal_y) - 5, f"Goal: {goal_display:.1f}")
        
        if use_weekly_bins:
            # ===== WEEKLY BINNING MODE =====
            bins = self._calculate_weekly_bins()
            
            if len(bins) >= 2:
                # Draw min/max band
                band_path = QtGui.QPainterPath()
                
                # Top edge (max values)
                first_bin = bins[0]
                band_path.moveTo(date_to_x(first_bin["date"]), weight_to_y(first_bin["max"]))
                for bin_data in bins:
                    x = date_to_x(bin_data["date"])
                    band_path.lineTo(x, weight_to_y(bin_data["max"]))
                
                # Bottom edge (min values, reversed)
                for bin_data in reversed(bins):
                    x = date_to_x(bin_data["date"])
                    band_path.lineTo(x, weight_to_y(bin_data["min"]))
                
                band_path.closeSubpath()
                
                # Fill band
                painter.setBrush(QtGui.QColor(100, 150, 255, 40))
                painter.setPen(QtCore.Qt.PenStyle.NoPen)
                painter.drawPath(band_path)
                
                # Draw average line
                painter.setPen(QtGui.QPen(QtGui.QColor("#6496ff"), 3))
                for i in range(len(bins) - 1):
                    x1 = date_to_x(bins[i]["date"])
                    y1 = weight_to_y(bins[i]["avg"])
                    x2 = date_to_x(bins[i + 1]["date"])
                    y2 = weight_to_y(bins[i + 1]["avg"])
                    painter.drawLine(QtCore.QPointF(x1, y1), QtCore.QPointF(x2, y2))
                
                # Draw weekly points with count indicator
                for bin_data in bins:
                    x = date_to_x(bin_data["date"])
                    y = weight_to_y(bin_data["avg"])
                    
                    # Size based on entry count
                    size = min(8, 4 + bin_data["count"])
                    
                    painter.setBrush(QtGui.QColor("#6496ff"))
                    painter.setPen(QtGui.QPen(QtGui.QColor("#ffffff"), 1))
                    painter.drawEllipse(QtCore.QPointF(x, y), size, size)
                
                # Legend for binned mode
                painter.setPen(QtGui.QColor("#888888"))
                painter.setFont(QtGui.QFont("Segoe UI", 8))
                painter.drawText(chart_rect.right() - 100, chart_rect.top() + 15, 
                               f"Weekly avg (n={len(self.weight_data)})")
        
        else:
            # ===== DAILY MODE =====
            # Build points list with date info and context
            points = []
            prev_date = None
            
            for date_str, weight, context in self.weight_data:
                current_date = self._parse_date(date_str)
                if not current_date:
                    continue
                
                x = date_to_x(current_date)
                y = weight_to_y(weight)
                
                # Check for gap
                gap_days = 0
                if prev_date:
                    gap_days = (current_date - prev_date).days - 1
                
                points.append({
                    "date": current_date,
                    "date_str": date_str,
                    "weight": weight,
                    "context": context,
                    "x": x,
                    "y": y,
                    "gap_before": gap_days,
                })
                
                prev_date = current_date
            
            if len(points) >= 2:
                # Draw gradient fill under line
                path = QtGui.QPainterPath()
                path.moveTo(points[0]["x"], chart_rect.bottom())
                for p in points:
                    path.lineTo(p["x"], p["y"])
                path.lineTo(points[-1]["x"], chart_rect.bottom())
                path.closeSubpath()
                
                gradient = QtGui.QLinearGradient(0, chart_rect.top(), 0, chart_rect.bottom())
                gradient.setColorAt(0, QtGui.QColor(100, 150, 255, 100))
                gradient.setColorAt(1, QtGui.QColor(100, 150, 255, 20))
                painter.fillPath(path, gradient)
                
                # Draw connecting lines (dashed for gaps)
                for i in range(len(points) - 1):
                    p1 = points[i]
                    p2 = points[i + 1]
                    
                    if p2["gap_before"] > 1:
                        # Dashed line for gaps > 1 day
                        painter.setPen(QtGui.QPen(
                            QtGui.QColor("#6496ff"), 2, 
                            QtCore.Qt.PenStyle.DashLine
                        ))
                    else:
                        # Solid line for consecutive/near-consecutive days
                        painter.setPen(QtGui.QPen(QtGui.QColor("#6496ff"), 3))
                    
                    painter.drawLine(
                        QtCore.QPointF(p1["x"], p1["y"]), 
                        QtCore.QPointF(p2["x"], p2["y"])
                    )
                
                # Draw 7-day moving average if enough data
                ma_data = self._calculate_moving_average()
                if len(ma_data) >= 2:
                    painter.setPen(QtGui.QPen(QtGui.QColor("#ffaa00"), 2))
                    for i in range(len(ma_data) - 1):
                        x1 = date_to_x(ma_data[i][0])
                        y1 = weight_to_y(ma_data[i][1])
                        x2 = date_to_x(ma_data[i + 1][0])
                        y2 = weight_to_y(ma_data[i + 1][1])
                        painter.drawLine(QtCore.QPointF(x1, y1), QtCore.QPointF(x2, y2))
                    
                    # MA legend
                    painter.setPen(QtGui.QColor("#ffaa00"))
                    painter.setFont(QtGui.QFont("Segoe UI", 8))
                    painter.drawText(chart_rect.right() - 80, chart_rect.top() + 15, "7-day avg")
            
            # Draw data points with context coloring
            # First, collect unique contexts for legend
            unique_contexts = set(p.get("context", "") for p in points)
            has_multiple_contexts = len(unique_contexts) > 1 or (len(unique_contexts) == 1 and "" not in unique_contexts)
            
            for i, p in enumerate(points):
                # Determine point color based on context
                context = p.get("context", "")
                base_color = QtGui.QColor(self.CONTEXT_COLORS.get(context, self.CONTEXT_COLORS[""]))
                
                # Adjust brightness based on trend (darker for gain, brighter for loss)
                if i > 0:
                    prev_weight = points[i - 1]["weight"]
                    if p["weight"] < prev_weight:
                        # Weight loss - make border green
                        border_color = QtGui.QColor("#00ff88")
                    elif p["weight"] > prev_weight:
                        # Weight gain - make border red
                        border_color = QtGui.QColor("#ff6464")
                    else:
                        # Same - white border
                        border_color = QtGui.QColor("#ffffff")
                else:
                    border_color = QtGui.QColor("#ffffff")
                
                # Hollow point for gap interpolation indicator
                if p["gap_before"] > 2:
                    # Draw gap indicator - small triangle pointing to gap
                    painter.setPen(QtGui.QPen(QtGui.QColor("#888888"), 1))
                    painter.setBrush(QtCore.Qt.BrushStyle.NoBrush)
                else:
                    painter.setBrush(base_color)
                    painter.setPen(QtGui.QPen(border_color, 2))
                
                painter.drawEllipse(QtCore.QPointF(p["x"], p["y"]), 5, 5)
            
            # Draw context legend if multiple contexts exist
            if has_multiple_contexts:
                legend_y = chart_rect.bottom() + 30
                legend_x = chart_rect.left()
                painter.setFont(QtGui.QFont("Segoe UI", 7))
                
                for ctx in sorted(unique_contexts):
                    color = QtGui.QColor(self.CONTEXT_COLORS.get(ctx, self.CONTEXT_COLORS[""]))
                    painter.setBrush(color)
                    painter.setPen(QtGui.QPen(QtGui.QColor("#ffffff"), 1))
                    painter.drawEllipse(QtCore.QPointF(legend_x + 5, legend_y), 4, 4)
                    
                    # Get display name for context
                    if ctx and format_entry_note:
                        ctx_label = format_entry_note(ctx)
                    elif ctx:
                        ctx_label = ctx.replace("_", " ").title()
                    else:
                        ctx_label = "No context"
                    
                    painter.setPen(QtGui.QColor("#aaaaaa"))
                    painter.drawText(int(legend_x) + 12, int(legend_y) + 4, ctx_label)
                    legend_x += 70
        
        # Draw date labels (smart distribution)
        painter.setPen(QtGui.QColor("#888888"))
        painter.setFont(QtGui.QFont("Segoe UI", 8))
        
        if total_days <= 14:
            # Show more dates for short ranges
            date_step = max(1, total_days // 5)
        elif total_days <= 60:
            date_step = 7  # Weekly
        else:
            date_step = 14  # Bi-weekly
        
        current_date = first_date
        while current_date <= last_date:
            x = date_to_x(current_date)
            date_label = current_date.strftime("%m/%d")
            painter.drawText(int(x) - 15, chart_rect.bottom() + 15, date_label)
            current_date += timedelta(days=date_step)
        
        # Always show last date if not too close to previous
        last_x = date_to_x(last_date)
        if last_x - date_to_x(current_date - timedelta(days=date_step)) > 30:
            painter.drawText(int(last_x) - 15, chart_rect.bottom() + 15, 
                           last_date.strftime("%m/%d"))


class WeightTab(QtWidgets.QWidget):
    """Weight tracking tab with chart, BMI, predictions, and gamification rewards."""
    
    def __init__(self, blocker: 'BlockerCore', parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.blocker = blocker
        self._reminder_timer = None
        self._build_ui()
        self._refresh_display()
        self._setup_reminder()
        # Ensure timer is cleaned up when widget is destroyed
        self.destroyed.connect(self._cleanup_timer)
    
    def _cleanup_timer(self) -> None:
        """Stop the reminder timer when the widget is destroyed."""
        if self._reminder_timer is not None:
            self._reminder_timer.stop()
            self._reminder_timer = None
    
    def _build_ui(self) -> None:
        layout = QtWidgets.QVBoxLayout(self)
        layout.setSpacing(10)
        layout.setContentsMargins(15, 15, 15, 15)

        add_tab_help_button(layout, "weight", self)
        
        # Header with insights button
        header_layout = QtWidgets.QHBoxLayout()
        header = QtWidgets.QLabel("‚öñÔ∏è Weight Tracker")
        header.setStyleSheet("font-size: 18px; font-weight: bold; color: #ffffff;")
        header_layout.addWidget(header)
        header_layout.addStretch()
        
        insights_btn = QtWidgets.QPushButton("üìä Weekly Insights")
        insights_btn.clicked.connect(self._show_weekly_insights)
        header_layout.addWidget(insights_btn)
        
        layout.addLayout(header_layout)
        
        # =====================================================================
        # Rodent Tips Section - Shows daily weight control tips when any rodent is collected
        # Requires scientist_009 (White Mouse Archimedes) for translation from "rodent language"
        # =====================================================================
        self.rodent_tips_section = QtWidgets.QFrame()
        self.rodent_tips_section.setStyleSheet("""
            QFrame {
                background-color: rgba(255, 255, 255, 0.04);
                border: 1px solid rgba(139, 115, 85, 0.3);
                border-radius: 8px;
            }
        """)
        rodent_tips_layout = QtWidgets.QHBoxLayout(self.rodent_tips_section)
        rodent_tips_layout.setContentsMargins(8, 6, 8, 6)
        rodent_tips_layout.setSpacing(10)
        
        # Left: Icon (rodent entity icon)
        self.rodent_icon_label = QtWidgets.QLabel()
        self.rodent_icon_label.setFixedSize(40, 40)
        self.rodent_icon_label.setStyleSheet("""
            QLabel {
                background: transparent;
                border: none;
            }
        """)
        rodent_tips_layout.addWidget(self.rodent_icon_label)
        
        # Middle: Title + Tip text (expandable)
        rodent_content_col = QtWidgets.QVBoxLayout()
        rodent_content_col.setSpacing(2)
        
        # Title row with entity name and tip number
        rodent_title_row = QtWidgets.QHBoxLayout()
        self.rodent_section_title = QtWidgets.QLabel("üêÄ Rodent Squad Weight Tips")
        self.rodent_section_title.setStyleSheet("color: #8b7355; font-size: 10px;")
        rodent_title_row.addWidget(self.rodent_section_title)
        
        self.rodent_tip_number = QtWidgets.QLabel("Tip #1 of 100")
        self.rodent_tip_number.setStyleSheet("color: #8b7355; font-size: 10px;")
        self.rodent_tip_number.hide()  # Hidden - tip number not important
        rodent_title_row.addWidget(self.rodent_tip_number)
        rodent_title_row.addStretch()
        rodent_content_col.addLayout(rodent_title_row)
        
        # Tip text (larger, more readable)
        self.rodent_tip_text = QtWidgets.QLabel("Loading tip...")
        self.rodent_tip_text.setTextFormat(QtCore.Qt.RichText)
        self.rodent_tip_text.setStyleSheet("color: #f0e6d2; font-size: 14px;")
        self.rodent_tip_text.setWordWrap(True)
        rodent_content_col.addWidget(self.rodent_tip_text)
        
        # Hidden: tracks if user has the telepathic translator
        self.has_translator = False
        
        rodent_tips_layout.addLayout(rodent_content_col, 1)
        
        # Right: Acknowledge button (compact)
        self.rodent_acknowledge_btn = QtWidgets.QPushButton("üìñ +1ü™ô")
        self.rodent_acknowledge_btn.setFixedWidth(70)
        self.rodent_acknowledge_btn.setStyleSheet("""
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 #8b7355, stop:1 #6b5335);
                color: white;
                font-size: 11px;
                font-weight: bold;
                border-radius: 4px;
                border: 1px solid #5b4325;
                padding: 6px 8px;
            }
            QPushButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 #a68365, stop:1 #8b7355);
            }
            QPushButton:disabled {
                background: #444;
                color: #777;
                border: 1px solid #333;
            }
        """)
        self.rodent_acknowledge_btn.clicked.connect(self._acknowledge_rodent_tip)
        rodent_tips_layout.addWidget(self.rodent_acknowledge_btn)
        
        layout.addWidget(self.rodent_tips_section)
        self.rodent_tips_section.hide()  # Hidden until we check if any rodent is collected
        
        # Entity Perk Section (Rodent Squad) - shows when rat/mouse entities are collected
        # Positioned after tips section, before Log Weight dialog
        self.weight_entity_section = CollapsibleSection("üêÄ Rodent Squad", "weight_entity_section", parent=self)
        self.weight_entity_section.setVisible(False)
        layout.addWidget(self.weight_entity_section)
        
        # Top section: Input and stats side by side
        top_layout = QtWidgets.QHBoxLayout()
        
        # Left: Weight input section
        input_group = QtWidgets.QGroupBox("üìù Log Weight")
        input_layout = QtWidgets.QFormLayout(input_group)
        input_layout.setSpacing(8)
        
        # Weight input
        weight_row = QtWidgets.QHBoxLayout()
        self.weight_input = NoScrollDoubleSpinBox()
        self.weight_input.setRange(20, 500)
        self.weight_input.setDecimals(1)
        self.weight_input.setSingleStep(0.1)
        self.weight_input.setValue(70.0)
        self.weight_input.setSuffix(" kg")
        self.weight_input.setFixedWidth(120)
        weight_row.addWidget(self.weight_input)
        
        # Unit toggle
        self.unit_combo = NoScrollComboBox()
        self.unit_combo.addItems(["kg", "lbs"])
        self.unit_combo.setFixedWidth(60)
        self.unit_combo.currentTextChanged.connect(self._on_unit_changed)
        weight_row.addWidget(self.unit_combo)
        weight_row.addStretch()
        input_layout.addRow("Weight:", weight_row)
        
        # Date input (default to today, max = today to prevent future dates)
        self.date_edit = QtWidgets.QDateEdit()
        self.date_edit.setDate(QtCore.QDate.currentDate())
        self.date_edit.setMaximumDate(QtCore.QDate.currentDate())
        self.date_edit.setCalendarPopup(True)
        self.date_edit.setDisplayFormat("yyyy-MM-dd")
        input_layout.addRow("Date:", self.date_edit)
        
        # Note/Context (tag selection)
        note_row = QtWidgets.QHBoxLayout()
        self.note_combo = NoScrollComboBox()
        self.note_combo.addItem("(none)", "")
        if WEIGHT_ENTRY_TAGS:
            for tag_id, tag_display, tooltip in WEIGHT_ENTRY_TAGS:
                self.note_combo.addItem(tag_display, tag_id)
        self.note_combo.setFixedWidth(150)
        self.note_combo.currentIndexChanged.connect(self._on_context_changed)
        note_row.addWidget(self.note_combo)
        note_row.addStretch()
        input_layout.addRow("Context:", note_row)
        
        # Goal weight with enable checkbox
        goal_row = QtWidgets.QHBoxLayout()
        self.goal_enabled = QtWidgets.QCheckBox()
        self.goal_enabled.setToolTip("Enable/disable goal weight")
        self.goal_enabled.stateChanged.connect(self._on_goal_toggle)
        goal_row.addWidget(self.goal_enabled)
        
        self.goal_input = NoScrollDoubleSpinBox()
        self.goal_input.setRange(1, 500)
        self.goal_input.setDecimals(1)
        self.goal_input.setSingleStep(0.1)
        self.goal_input.setValue(70.0)
        self.goal_input.setFixedWidth(100)
        self.goal_input.setEnabled(False)
        goal_row.addWidget(self.goal_input)
        
        set_goal_btn = QtWidgets.QPushButton("Set")
        set_goal_btn.setFixedWidth(40)
        set_goal_btn.clicked.connect(self._set_goal)
        goal_row.addWidget(set_goal_btn)
        goal_row.addStretch()
        input_layout.addRow("Goal:", goal_row)
        
        # Height input for BMI
        height_row = QtWidgets.QHBoxLayout()
        self.height_input = NoScrollSpinBox()
        self.height_input.setRange(100, 250)
        self.height_input.setValue(170)
        self.height_input.setSuffix(" cm")
        self.height_input.setFixedWidth(80)
        height_row.addWidget(self.height_input)
        
        self.set_height_btn = QtWidgets.QPushButton("Set")
        self.set_height_btn.setFixedWidth(40)
        self.set_height_btn.clicked.connect(self._set_height)
        height_row.addWidget(self.set_height_btn)
        
        self.bmi_label = QtWidgets.QLabel("")
        self.bmi_label.setStyleSheet("font-size: 11px; margin-left: 10px;")
        height_row.addWidget(self.bmi_label)
        
        # Height hint label (shows locked status for adults)
        self.height_hint_label = QtWidgets.QLabel("")
        self.height_hint_label.setStyleSheet("font-size: 10px; color: #888;")
        height_row.addWidget(self.height_hint_label)
        
        height_row.addStretch()
        input_layout.addRow("Height:", height_row)
        
        # Birth date and gender for age/sex-specific BMI norms (display + edit)
        profile_row = QtWidgets.QHBoxLayout()
        
        # Profile display label
        self.profile_display_label = QtWidgets.QLabel("")
        self.profile_display_label.setStyleSheet("font-size: 11px; color: #aaa;")
        profile_row.addWidget(self.profile_display_label)
        
        # Edit profile button
        edit_profile_btn = QtWidgets.QPushButton("‚úèÔ∏è Edit")
        edit_profile_btn.setFixedWidth(60)
        edit_profile_btn.setToolTip("Edit birth date and gender for personalized health norms")
        edit_profile_btn.clicked.connect(self._edit_user_profile)
        profile_row.addWidget(edit_profile_btn)
        
        profile_row.addStretch()
        input_layout.addRow("Profile:", profile_row)
        
        # Log button
        log_btn = QtWidgets.QPushButton("üìä Log Weight")
        log_btn.setStyleSheet("""
            QPushButton {
                background-color: #4a90d9;
                color: white;
                font-weight: bold;
                padding: 8px 16px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background-color: #5aa0e9;
            }
        """)
        log_btn.clicked.connect(self._log_weight)
        input_layout.addRow("", log_btn)
        
        top_layout.addWidget(input_group)
        
        # Right: Stats + Comparisons display
        right_panel = QtWidgets.QVBoxLayout()
        
        # Stats section
        stats_group = QtWidgets.QGroupBox("üìà Statistics")
        stats_layout = QtWidgets.QVBoxLayout(stats_group)
        stats_layout.setSpacing(5)
        
        self.stats_label = QtWidgets.QLabel()
        self.stats_label.setWordWrap(True)
        self.stats_label.setStyleSheet("font-size: 11px; line-height: 1.4;")
        stats_layout.addWidget(self.stats_label)
        
        # Prediction label
        self.prediction_label = QtWidgets.QLabel()
        self.prediction_label.setWordWrap(True)
        self.prediction_label.setStyleSheet("font-size: 11px; margin-top: 5px;")
        stats_layout.addWidget(self.prediction_label)
        
        right_panel.addWidget(stats_group)
        
        # Comparisons section
        compare_group = QtWidgets.QGroupBox("üìÖ Historical")
        compare_layout = QtWidgets.QVBoxLayout(compare_group)
        compare_layout.setSpacing(3)
        
        self.compare_label = QtWidgets.QLabel()
        self.compare_label.setWordWrap(True)
        self.compare_label.setStyleSheet("font-size: 10px; color: #aaaaaa;")
        compare_layout.addWidget(self.compare_label)
        
        right_panel.addWidget(compare_group)
        
        top_layout.addLayout(right_panel)
        layout.addLayout(top_layout)
        
        # Chart section
        chart_group = QtWidgets.QGroupBox("üìâ Progress Chart")
        chart_layout = QtWidgets.QVBoxLayout(chart_group)
        
        self.chart = WeightChartWidget()
        chart_layout.addWidget(self.chart)
        
        layout.addWidget(chart_group, 1)
        
        # Bottom row: Recent entries and settings
        bottom_layout = QtWidgets.QHBoxLayout()
        
        # Recent entries table
        entries_group = QtWidgets.QGroupBox("üìã Recent Entries")
        entries_layout = QtWidgets.QVBoxLayout(entries_group)
        
        self.entries_table = QtWidgets.QTableWidget()
        self.entries_table.setColumnCount(5)
        self.entries_table.setHorizontalHeaderLabels(["Date", "Weight", "Note", "Change", "Del"])
        self.entries_table.horizontalHeader().setStretchLastSection(True)
        self.entries_table.setMaximumHeight(130)
        self.entries_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        entries_layout.addWidget(self.entries_table)
        
        bottom_layout.addWidget(entries_group, 2)
        
        # Reminder settings
        settings_group = QtWidgets.QGroupBox("‚è∞ Reminder")
        settings_layout = QtWidgets.QFormLayout(settings_group)
        settings_layout.setSpacing(5)
        
        self.reminder_enabled = QtWidgets.QCheckBox("Daily reminder")
        self.reminder_enabled.stateChanged.connect(self._on_reminder_toggle)
        settings_layout.addRow(self.reminder_enabled)
        
        self.reminder_time = QtWidgets.QTimeEdit()
        self.reminder_time.setDisplayFormat("HH:mm")
        self.reminder_time.setTime(QtCore.QTime(8, 0))
        self.reminder_time.timeChanged.connect(self._on_reminder_time_changed)
        settings_layout.addRow("Time:", self.reminder_time)
        
        bottom_layout.addWidget(settings_group, 1)
        
        layout.addLayout(bottom_layout)
        
        # Rewards info (collapsed)
        rewards_group = QtWidgets.QGroupBox("üéÅ Rewards Info")
        rewards_layout = QtWidgets.QVBoxLayout(rewards_group)
        rewards_info = QtWidgets.QLabel(
            "<b>Smart Weight Mode:</b> Rewards adapt to YOUR goals!<br>"
            "<i>‚Ä¢ Overweight? Rewards for weight <b>loss</b> ‚Ä¢ Underweight? Rewards for healthy <b>gain</b> ‚Ä¢ Normal? Rewards for <b>stability</b></i><br>"
            "<span style='color:#666;'>Mode auto-detects from BMI (set height) or goal weight (¬±2kg threshold)</span><br>"
            "<table style='font-size:10px; color:#888888; margin-top:5px;'>"
            "<tr><th>Daily Progress</th><th>Common</th><th>Uncommon</th><th>Rare</th><th>Epic</th><th>Legendary</th></tr>"
            "<tr><td>0g (stable)</td><td>75%</td><td>20%</td><td>5%</td><td>-</td><td>-</td></tr>"
            "<tr><td>100g+</td><td>25%</td><td>50%</td><td>20%</td><td>5%</td><td>-</td></tr>"
            "<tr><td>200g+</td><td>5%</td><td>20%</td><td>50%</td><td>20%</td><td>5%</td></tr>"
            "<tr><td>300g+</td><td>-</td><td>5%</td><td>20%</td><td>50%</td><td>25%</td></tr>"
            "<tr><td>400g+</td><td>-</td><td>-</td><td>-</td><td>5%</td><td>95%</td></tr>"
            "<tr><td>500g+</td><td>-</td><td>-</td><td>-</td><td>-</td><td>100%</td></tr>"
            "</table>"
            "<br><b>Weekly:</b> 300g=Epic, 500g=Legendary | <b>Monthly:</b> 1.5kg=Epic, 2kg=Legendary | "
            "<b>Streaks:</b> 7d=Rare, 14d=Epic, 30d+=Legendary<br>"
            "<span style='color:#88cc88;'>‚öñÔ∏è Maintain mode: ¬±100g=Rare, ¬±200g=Uncommon, ¬±500g=Common</span>"
        )
        rewards_info.setWordWrap(True)
        rewards_info.setStyleSheet("color: #888888; font-size: 10px;")
        rewards_layout.addWidget(rewards_info)
        layout.addWidget(rewards_group)
        
        # Initialize settings from saved values
        self._load_settings()
        
        # Update entity perk display
        self._update_weight_entity_perk_display()
        
        # Refresh rodent tips
        self._refresh_rodent_tips()
    
    def _on_goal_toggle(self, state: int) -> None:
        """Handle goal checkbox toggle."""
        enabled = state == QtCore.Qt.CheckState.Checked.value
        self.goal_input.setEnabled(enabled)
        if not enabled:
            self.blocker.weight_goal = None
            self.blocker.save_config()
            self._refresh_display()
    
    def _on_context_changed(self, index: int) -> None:
        """Handle context selection change - update comparisons to show same-context data."""
        self._update_comparisons()
    
    def _on_unit_changed(self, unit: str) -> None:
        """Handle unit change."""
        self.weight_input.setSuffix(f" {unit}")
        self.goal_input.setSuffix(f" {unit}")
        if unit == "lbs":
            self.weight_input.setRange(44, 1100)  # ~20-500 kg in lbs
            self.goal_input.setRange(2.2, 1100)   # ~1-500 kg in lbs
        else:
            self.weight_input.setRange(20, 500)
            self.goal_input.setRange(1, 500)
        self.blocker.weight_unit = unit
        self.blocker.save_config()
        self._refresh_display()
    
    def _set_goal(self) -> None:
        """Set the goal weight."""
        if not self.goal_enabled.isChecked():
            self.blocker.weight_goal = None
            self.blocker.save_config()
            self._refresh_display()
            show_info(self, "Goal Cleared", 
                "Goal weight has been cleared. Check the box and set a value to enable.")
            return
        
        goal = self.goal_input.value()
        unit = self.unit_combo.currentText()
        # Store goal in kg for consistency
        self.blocker.weight_goal = goal / 2.20462 if unit == "lbs" else goal
        self.blocker.save_config()
        self._refresh_display()
        show_info(self, "Goal Set", 
            f"Goal weight set to {goal:.1f} {unit}")
    
    def _log_weight(self) -> None:
        """Log a new weight entry."""
        weight = self.weight_input.value()
        date_str = self.date_edit.date().toString("yyyy-MM-dd")
        unit = self.unit_combo.currentText()
        note = self.note_combo.currentData() or ""
        
        # Convert to kg for storage if needed
        weight_kg = weight / 2.20462 if unit == "lbs" else weight
        
        # Check if entry already exists for this date AND context
        # Multiple entries per day are allowed if they have different contexts
        existing_idx = None
        for i, entry in enumerate(self.blocker.weight_entries):
            if entry.get("date") == date_str and entry.get("note", "") == note:
                existing_idx = i
                break
        
        # For reward calculation, we need entries WITHOUT the current date+context combination
        # This ensures updating an entry compares against historical data only
        entries_for_reward = [e for e in self.blocker.weight_entries 
                              if not (e.get("date") == date_str and e.get("note", "") == note)]
        
        # Check if reward was already given today for THIS context
        # We award once per day per context (so morning/evening each get rewards)
        today_same_context_exists = any(
            e.get("date") == date_str and e.get("note", "") == note 
            for e in self.blocker.weight_entries
        )
        
        # Check for rewards before adding entry (use comprehensive function if available)
        # Skip if gamification mode is disabled (same as focus sessions)
        # Skip if we already have a same-context entry today (already rewarded)
        rewards = None
        if not today_same_context_exists and GAMIFICATION_AVAILABLE and check_all_weight_rewards and is_gamification_enabled(self.blocker.adhd_buster):
            story_id = self.blocker.adhd_buster.get("active_story", "warrior")
            rewards = check_all_weight_rewards(
                entries_for_reward, 
                weight_kg, 
                date_str,
                self.blocker.weight_goal,
                self.blocker.weight_milestones,
                story_id,
                self.blocker.adhd_buster,
                height_cm=self.blocker.weight_height  # Pass height for BMI-based mode
            )
        elif not today_same_context_exists and GAMIFICATION_AVAILABLE and check_weight_entry_rewards and is_gamification_enabled(self.blocker.adhd_buster):
            # Fallback to basic rewards
            story_id = self.blocker.adhd_buster.get("active_story", "warrior")
            rewards = check_weight_entry_rewards(
                entries_for_reward, 
                weight_kg, 
                date_str,
                story_id,
                self.blocker.adhd_buster,
                height_cm=self.blocker.weight_height,  # Pass height for BMI-based mode
                goal_weight=self.blocker.weight_goal   # Pass goal for goal-based mode
            )
        
        # Update or add entry
        new_entry = {"date": date_str, "weight": weight_kg}
        if note:
            new_entry["note"] = note
        
        if existing_idx is not None:
            context_str = format_entry_note(note) if format_entry_note and note else "(no context)"
            reply = show_question(
                self, "Update Entry",
                f"An entry for {date_str} with context {context_str} already exists.\nUpdate it to {weight:.1f} {unit}?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
            )
            if reply != QtWidgets.QMessageBox.Yes:
                return
            self.blocker.weight_entries[existing_idx] = new_entry
        else:
            self.blocker.weight_entries.append(new_entry)
            # Sort by date
            self.blocker.weight_entries.sort(key=lambda x: x.get("date", ""))
            # Prune to last 365 entries to prevent unbounded growth
            if len(self.blocker.weight_entries) > 365:
                self.blocker.weight_entries = self.blocker.weight_entries[-365:]
        
        self.blocker.save_config()
        
        # Award city MATERIALS resource for weight logging:
        # - +1 Materials just for logging weight (daily)
        # - +1 Bonus if body weight is within healthy BMI (18.5-25)
        # - +1 Bonus if weight is trending correctly:
        #   * Above norm (BMI > 25): bonus if weight decreased
        #   * Below norm (BMI < 18.5): bonus if weight increased
        #   * In norm: already got the "in norm" bonus above
        materials_to_add = 0
        if CITY_AVAILABLE:
            try:
                from city import add_city_resource, get_resources
                
                # +1 for logging weight today (always)
                materials_to_add = 1
                materials_breakdown = ["+1 log"]
                
                # Calculate BMI if we have height
                current_bmi = None
                height_m = self.blocker.weight_height / 100.0 if self.blocker.weight_height else 0
                if height_m > 0:
                    current_bmi = weight_kg / (height_m ** 2)
                    
                    # +1 bonus if in healthy BMI range (18.5-25)
                    if 18.5 <= current_bmi <= 25.0:
                        materials_to_add += 1
                        materials_breakdown.append("+1 in norm")
                    else:
                        # Check if weight is trending correctly (need previous entry)
                        sorted_entries = sorted(self.blocker.weight_entries, key=lambda x: x.get("date", ""))
                        if len(sorted_entries) >= 2:
                            prev_weight = sorted_entries[-2].get("weight", 0)
                            weight_change = weight_kg - prev_weight
                            
                            if current_bmi > 25.0 and weight_change < 0:
                                # Above norm and losing weight - good!
                                materials_to_add += 1
                                materials_breakdown.append("+1 losing")
                            elif current_bmi < 18.5 and weight_change > 0:
                                # Below norm and gaining weight - good!
                                materials_to_add += 1
                                materials_breakdown.append("+1 gaining")
                
                if materials_to_add > 0:
                    add_city_resource(self.blocker.adhd_buster, "materials", materials_to_add)
                    
                    # Show city stockpile toast
                    try:
                        resources = get_resources(self.blocker.adhd_buster)
                        total_materials = resources.get("materials", 0)
                        breakdown_str = " ".join(materials_breakdown)
                        show_perk_toast(f"üß± +{materials_to_add} Materials ({breakdown_str}) ‚Üí {total_materials} total", "üèóÔ∏è", self)
                    except Exception:
                        pass
            except Exception:
                pass
        
        # Process rewards
        if rewards and GAMIFICATION_AVAILABLE:
            self._process_rewards(rewards)
        
        self._refresh_display()
    
    def _process_rewards(self, rewards: dict) -> None:
        """Process and show weight loss rewards with lottery animation."""
        items_earned = []
        new_milestone_ids = []
        
        # Collect all earned items - Daily/Weekly/Monthly (use defensive copies)
        # Items will be added to inventory via game_state at the end
        primary_source = None  # Track the primary reward source for lottery display
        if rewards.get("daily_reward"):
            item = rewards["daily_reward"]
            items_earned.append(("Daily", item))
            primary_source = "Daily Weigh-In"
        
        if rewards.get("weekly_reward"):
            item = rewards["weekly_reward"]
            items_earned.append(("Weekly Bonus", item))
            if not primary_source:
                primary_source = "Weekly Progress"
        
        if rewards.get("monthly_reward"):
            item = rewards["monthly_reward"]
            items_earned.append(("Monthly Bonus", item))
            if not primary_source:
                primary_source = "Monthly Progress"
        
        # Streak reward
        if rewards.get("streak_reward"):
            streak_data = rewards["streak_reward"]
            item = streak_data["item"]
            items_earned.append((f"üî• {streak_data['streak_days']}-Day Streak", item))
            new_milestone_ids.append(streak_data["milestone_id"])
            if not primary_source:
                primary_source = f"üî• {streak_data['streak_days']}-Day Streak"
        
        # Milestone rewards
        for milestone in rewards.get("new_milestones", []):
            item = milestone["item"]
            items_earned.append((f"üèÜ {milestone['name']}", item))
            new_milestone_ids.append(milestone["milestone_id"])
            if not primary_source:
                primary_source = f"üèÜ {milestone['name']}"
        
        # Maintenance reward (only if no daily reward to avoid double-rewarding)
        if rewards.get("maintenance_reward") and not rewards.get("daily_reward"):
            maint_data = rewards["maintenance_reward"]
            item = maint_data["item"]
            items_earned.append(("‚öñÔ∏è Maintenance", item))
            if not primary_source:
                primary_source = "‚öñÔ∏è Weight Maintenance"
        
        # Save new milestones
        if new_milestone_ids:
            self.blocker.weight_milestones.extend(new_milestone_ids)
        
        # Generate diary entry (once per day, same as focus sessions)
        diary_entry = None
        if items_earned and GAMIFICATION_AVAILABLE and generate_diary_entry and calculate_character_power:
            today = datetime.now().strftime("%Y-%m-%d")
            diary = self.blocker.adhd_buster.get("diary", [])
            today_entries = [e for e in diary if e.get("date") == today]
            
            if not today_entries:
                power = calculate_character_power(self.blocker.adhd_buster)
                equipped = self.blocker.adhd_buster.get("equipped", {})
                active_story = self.blocker.adhd_buster.get("active_story", "warrior")
                diary_entry = generate_diary_entry(power, session_minutes=0, equipped_items=equipped,
                                                   story_id=active_story)
                if "diary" not in self.blocker.adhd_buster:
                    self.blocker.adhd_buster["diary"] = []
                self.blocker.adhd_buster["diary"].append(diary_entry)
                # Keep only last 100 entries
                if len(self.blocker.adhd_buster["diary"]) > 100:
                    self.blocker.adhd_buster["diary"] = self.blocker.adhd_buster["diary"][-100:]
        
        if items_earned:
            # Extract just the items for the batch award
            just_items = [item for _, item in items_earned]
            
            # Use GameState manager for reactive updates
            main_window = self.window()
            game_state = getattr(main_window, 'game_state', None)
            if not game_state:
                logger.error("GameStateManager not available - cannot award weight rewards")
                return
            
            # Show lottery animation for the primary item (most exciting)
            # Pick the highest rarity item as the primary
            rarity_order = ["Common", "Uncommon", "Rare", "Epic", "Legendary"]
            primary_item = max(just_items, key=lambda x: rarity_order.index(x.get("rarity", "Common")))
            extra_items = [i for i in just_items if i is not primary_item]
            
            # Show lottery animation
            from lottery_animation import WeightLotteryDialog
            lottery_dialog = WeightLotteryDialog(
                item=primary_item,
                reward_source=primary_source or "Weight Tracking",
                extra_items=extra_items,
                parent=self.window()
            )
            lottery_dialog.exec()
            lottery_dialog.hide()  # Explicitly hide before deletion
            lottery_dialog.deleteLater()
            
            # Capture equipped state before award
            equipped_before = dict(self.blocker.adhd_buster.get("equipped", {}))
            
            # Use batch award - handles inventory, auto-equip, save, and signals
            award_result = game_state.award_items_batch(just_items, coins=0, auto_equip=True, source="weight_tracking")
            
            # Get the slots that were actually auto-equipped
            equipped_after = game_state.adhd_buster.get("equipped", {})
            auto_equipped_slots = [item.get("slot") for item in award_result.get("equipped", []) if item.get("slot")]
            
            # Build reward message with rarity colors
            rarity_colors = {
                "Common": "#9e9e9e",
                "Uncommon": "#4caf50", 
                "Rare": "#2196f3",
                "Epic": "#9c27b0",
                "Legendary": "#ff9800"
            }
            msg_parts = []
            for source, item in items_earned:
                rarity = item.get("rarity", "Common")
                name = item.get("name", "Unknown Item")
                color = rarity_colors.get(rarity, "#9e9e9e")
                msg_parts.append(f"<b>{source}:</b> <span style='color:{color}; font-weight:bold;'>[{rarity}]</span> {name}")
            
            # Add loss stats
            stats_parts = []
            if rewards.get("daily_loss_grams") is not None:
                loss = rewards["daily_loss_grams"]
                if loss > 0:
                    stats_parts.append(f"Daily: -{loss:.0f}g")
                elif loss < 0:
                    stats_parts.append(f"Daily: +{abs(loss):.0f}g")
            if rewards.get("weekly_loss_grams") is not None:
                stats_parts.append(f"Weekly: {rewards['weekly_loss_grams']:.0f}g")
            if rewards.get("monthly_loss_grams") is not None:
                stats_parts.append(f"Monthly: {rewards['monthly_loss_grams']/1000:.1f}kg")
            
            # Add streak info
            if rewards.get("current_streak", 0) > 0:
                stats_parts.append(f"Streak: {rewards['current_streak']} days")
            
            # Build extra messages from stats
            extra_msgs = []
            if stats_parts:
                extra_msgs.append(" | ".join(stats_parts))
            for source, item in items_earned:
                extra_msgs.append(f"{source}: {item.get('name', 'Unknown')}")
            
            # Get entity perk contributors for luck/rarity bonuses
            entity_perk_contributors = []
            try:
                from gamification import get_entity_luck_perk_contributors
                luck_perks = get_entity_luck_perk_contributors(self.blocker.adhd_buster)
                entity_perk_contributors = luck_perks.get("contributors", [])
            except Exception:
                pass
            
            # Show ItemRewardDialog with comparison and proper auto-equip tracking
            from styled_dialog import ItemRewardDialog
            dialog = ItemRewardDialog(
                parent=self,
                title="üéâ Weight Rewards!",
                header_emoji="‚öñÔ∏è",
                source_label="Weight Tracking Rewards",
                items_earned=just_items,
                equipped=equipped_before,  # What was equipped before for comparison
                equipped_after=equipped_after,  # Current equipped state
                auto_equipped_slots=auto_equipped_slots,  # Slots that were actually auto-equipped
                game_state=game_state,  # For click-to-equip
                extra_messages=extra_msgs[:3],  # Limit to 3 messages
                entity_perk_contributors=entity_perk_contributors,  # Entity perks that helped
            )
            dialog.exec()
            
            # Show diary entry reveal (same as focus sessions)
            if diary_entry:
                diary_dlg = DiaryEntryRevealDialog(self.blocker, diary_entry, session_minutes=0, parent=self.window())
                diary_dlg.exec()
                diary_dlg.hide()  # Explicitly hide before deletion
                diary_dlg.deleteLater()
            
            # UI updates are handled via GameState signals
        elif rewards.get("messages"):
            # Show info messages even if no rewards
            show_info(
                self, "Weight Logged",
                "\n".join(rewards["messages"])
            )
    
    def _delete_entry(self, date_str: str) -> None:
        """Delete a weight entry."""
        reply = show_question(
            self, "Delete Entry",
            f"Delete the entry for {date_str}?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        )
        if reply == QtWidgets.QMessageBox.Yes:
            self.blocker.weight_entries = [
                e for e in self.blocker.weight_entries if e.get("date") != date_str
            ]
            self.blocker.save_config()
            self._refresh_display()
    
    def _refresh_display(self) -> None:
        """Refresh all display elements (called when switching users)."""
        # Update max date to today (in case app stayed open past midnight)
        self.date_edit.setMaximumDate(QtCore.QDate.currentDate())
        
        # Reload user-specific settings (including weight prefill)
        self._load_settings()
        
        unit = self.blocker.weight_unit
        entries = self.blocker.weight_entries
        
        # Update chart
        self.chart.set_data(entries, self.blocker.weight_goal, unit)
        
        # Update stats
        if get_weight_stats:
            stats = get_weight_stats(entries, unit)
            if stats["current"] is not None and stats["starting"] is not None:
                current_display = stats["current"] * 2.20462 if unit == "lbs" else stats["current"]
                starting_display = stats["starting"] * 2.20462 if unit == "lbs" else stats["starting"]
                
                # Check maintenance status
                maintenance_status = ""
                if self.blocker.weight_goal and stats["current"] is not None:
                    deviation = abs(stats["current"] - self.blocker.weight_goal)
                    if deviation <= 0.5:
                        maintenance_status = "<br><b style='color:#00ff88'>‚öñÔ∏è MAINTENANCE MODE</b> (within ¬±0.5kg of goal)"
                
                # Milestone count
                milestone_count = len(self.blocker.weight_milestones)
                milestone_text = f" | <b>Milestones:</b> {milestone_count}" if milestone_count > 0 else ""
                
                # Streak display with fire emoji for active streaks
                streak = stats['streak_days']
                if streak >= 7:
                    streak_display = f"üî• {streak} days"
                else:
                    streak_display = f"{streak} days"
                
                stats_text = f"""
<b>Current:</b> {current_display:.1f} {unit}<br>
<b>Starting:</b> {starting_display:.1f} {unit}<br>
<b>Total Change:</b> {format_weight_change(stats['total_change'], unit) if format_weight_change else 'N/A'}<br>
<b>7-Day Trend:</b> {format_weight_change(stats['trend_7d'], unit) if format_weight_change else 'N/A'}<br>
<b>30-Day Trend:</b> {format_weight_change(stats['trend_30d'], unit) if format_weight_change else 'N/A'}<br>
<b>Entries:</b> {stats['entries_count']} | <b>Streak:</b> {streak_display}{milestone_text}{maintenance_status}
"""
                self.stats_label.setText(stats_text)
            else:
                self.stats_label.setText("No weight entries yet.\nStart logging to see your stats!")
        else:
            self.stats_label.setText("Statistics unavailable")
        
        # Update entries table
        self.entries_table.setRowCount(0)
        sorted_entries = sorted(entries, key=lambda x: x.get("date", ""), reverse=True)[:10]
        
        for i, entry in enumerate(sorted_entries):
            self.entries_table.insertRow(i)
            
            # Date
            self.entries_table.setItem(i, 0, QtWidgets.QTableWidgetItem(entry.get("date", "")))
            
            # Weight
            weight_kg = entry.get("weight", 0)
            weight_display = weight_kg * 2.20462 if unit == "lbs" else weight_kg
            self.entries_table.setItem(i, 1, QtWidgets.QTableWidgetItem(f"{weight_display:.1f} {unit}"))
            
            # Note (formatted)
            note = entry.get("note", "")
            note_display = format_entry_note(note) if format_entry_note and note else ""
            self.entries_table.setItem(i, 2, QtWidgets.QTableWidgetItem(note_display))
            
            # Change (from previous entry to this entry)
            if i < len(sorted_entries) - 1:
                prev_weight = sorted_entries[i + 1].get("weight", weight_kg)
                # change = current - previous (negative = lost weight, positive = gained)
                change = (weight_kg - prev_weight) * 1000  # in grams
                if unit == "lbs":
                    # Convert grams to kg, then kg to lbs
                    change_lbs = (change / 1000) * 2.20462
                    change_text = f"{change_lbs:+.2f} lbs" if abs(change_lbs) >= 0.05 else "‚Äî"
                else:
                    change_text = f"{change:+.0f}g" if abs(change) >= 10 else "‚Äî"
                
                change_item = QtWidgets.QTableWidgetItem(change_text)
                if change < 0:
                    change_item.setForeground(QtGui.QColor("#00ff88"))  # Green = lost weight
                elif change > 0:
                    change_item.setForeground(QtGui.QColor("#ff6464"))  # Red = gained
                self.entries_table.setItem(i, 3, change_item)
            else:
                self.entries_table.setItem(i, 3, QtWidgets.QTableWidgetItem("‚Äî"))
            
            # Delete button
            delete_btn = QtWidgets.QPushButton("üóë")
            delete_btn.setFixedWidth(30)
            date_str = entry.get("date", "")
            delete_btn.clicked.connect(lambda checked, d=date_str: self._delete_entry(d))
            self.entries_table.setCellWidget(i, 4, delete_btn)
        
        self.entries_table.resizeColumnsToContents()
        
        # Update BMI display
        self._update_bmi_display()
        
        # Update prediction
        self._update_prediction()
        
        # Update historical comparisons
        self._update_comparisons()
    
    def _load_settings(self) -> None:
        """Load saved settings into UI controls."""
        # Unit
        if self.blocker.weight_unit == "lbs":
            self.weight_input.setRange(44, 1100)
            self.weight_input.setSuffix(" lbs")
            self.goal_input.setRange(2.2, 1100)
        else:
            self.weight_input.setRange(20, 500)
            self.weight_input.setSuffix(" kg")
            self.goal_input.setRange(1, 500)
        self.unit_combo.setCurrentText(self.blocker.weight_unit)
        
        # Prefill weight input with user's last weight entry
        entries = self.blocker.weight_entries
        if entries:
            # Sort by date to get most recent entry
            sorted_entries = sorted(entries, key=lambda x: x.get("date", ""), reverse=True)
            last_weight_kg = sorted_entries[0].get("weight", 70.0)
            # Convert to display unit
            if self.blocker.weight_unit == "lbs":
                self.weight_input.setValue(last_weight_kg * 2.20462)
            else:
                self.weight_input.setValue(last_weight_kg)
        else:
            # No entries - use a reasonable default
            if self.blocker.weight_unit == "lbs":
                self.weight_input.setValue(154.0)  # ~70kg
            else:
                self.weight_input.setValue(70.0)
        
        # Goal
        if self.blocker.weight_goal:
            goal_display = self.blocker.weight_goal * 2.20462 if self.blocker.weight_unit == "lbs" else self.blocker.weight_goal
            self.goal_input.setValue(goal_display)
            self.goal_enabled.setChecked(True)
            self.goal_input.setEnabled(True)
        
        # Height
        if self.blocker.weight_height:
            self.height_input.setValue(self.blocker.weight_height)
        
        # User profile display
        self._update_profile_display()
        
        # Reminder
        self.reminder_enabled.setChecked(self.blocker.weight_reminder_enabled)
        if self.blocker.weight_reminder_time:
            try:
                h, m = map(int, self.blocker.weight_reminder_time.split(":"))
                self.reminder_time.setTime(QtCore.QTime(h, m))
            except (ValueError, AttributeError):
                pass
        
        # Update height UI based on age (locked for adults)
        self._update_height_ui_state()
    
    def _update_height_ui_state(self) -> None:
        """Update height input state based on user age.
        
        Children/teens (<18): Height is adjustable (they're still growing)
        Adults (18+): Height is locked after first entry (adults don't grow)
        """
        age = self._get_user_age()
        height_set = self.blocker.weight_height is not None and self.blocker.weight_height > 0
        
        if age is not None and age >= 18 and height_set:
            # Adult with height already set - lock it
            self.height_input.setEnabled(False)
            self.set_height_btn.setEnabled(False)
            self.height_hint_label.setText("(locked - adults don't grow)")
            self.height_hint_label.setToolTip(
                "Height is locked for adults (18+) since it doesn't change.\n"
                "If you made a mistake, you can reset it in Settings."
            )
        elif age is not None and age < 18:
            # Child/teen - keep editable with reminder to update
            self.height_input.setEnabled(True)
            self.set_height_btn.setEnabled(True)
            self.height_hint_label.setText("(update as you grow!)")
            self.height_hint_label.setToolTip(
                "Growing children and teens should update their height regularly\n"
                "for accurate BMI calculations."
            )
        else:
            # No age set or no height yet - keep editable
            self.height_input.setEnabled(True)
            self.set_height_btn.setEnabled(True)
            self.height_hint_label.setText("")
    
    def _set_height(self) -> None:
        """Set the height for BMI calculation."""
        age = self._get_user_age()
        height = self.height_input.value()
        
        # For adults, warn if changing from a previously set height
        if age is not None and age >= 18 and self.blocker.weight_height:
            reply = show_question(
                self, "Confirm Height Change",
                f"You already have a height recorded ({self.blocker.weight_height} cm).\n\n"
                "Since you're an adult (18+), height typically doesn't change.\n"
                "Are you sure you want to update it?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
            )
            if reply != QtWidgets.QMessageBox.Yes:
                return
        
        self.blocker.weight_height = height
        self.blocker.save_config()
        self._update_bmi_display()
        self._update_height_ui_state()
        
        if age is not None and age < 18:
            show_info(self, "Height Updated", 
                     f"Height set to {height} cm.\n\nRemember to update it as you grow!")
        else:
            show_info(self, "Height Set", f"Height set to {height} cm")
    
    def _edit_user_profile(self) -> None:
        """Open the user profile dialog to edit birth date and gender."""
        dialog = UserProfileDialog(self.blocker, self, is_first_run=False)
        if dialog.exec() == QtWidgets.QDialog.Accepted:
            self._update_profile_display()
            self._update_bmi_display()
            self._update_height_ui_state()  # Age may have changed
    
    def _update_profile_display(self) -> None:
        """Update the profile display label with current profile info."""
        age = self._get_user_age()
        gender = self.blocker.user_gender or "?"
        
        if age is not None:
            self.profile_display_label.setText(f"Age: {age}, Sex: {gender}")
        elif self.blocker.user_birth_year:
            self.profile_display_label.setText(f"Born: {self.blocker.user_birth_year}, Sex: {gender}")
        else:
            self.profile_display_label.setText("Not set (using adult defaults)")
    
    def _get_user_age(self) -> int:
        """Calculate user's current age from stored birth date."""
        if not self.blocker.user_birth_year:
            return None
        try:
            from gamification import calculate_age_from_birth
            return calculate_age_from_birth(
                self.blocker.user_birth_year,
                self.blocker.user_birth_month or 1
            )
        except ImportError:
            from datetime import datetime
            today = datetime.now()
            age = today.year - self.blocker.user_birth_year
            if self.blocker.user_birth_month and today.month < self.blocker.user_birth_month:
                age -= 1
            return max(0, age)
    
    def _update_bmi_display(self) -> None:
        """Update the BMI label with current BMI, using age/sex-specific norms."""
        if not self.blocker.weight_height or not self.blocker.weight_entries:
            self.bmi_label.setText("")
            return
        
        # Get latest weight
        sorted_entries = sorted(self.blocker.weight_entries, key=lambda x: x.get("date", ""))
        if not sorted_entries:
            self.bmi_label.setText("")
            return
        
        latest_weight = sorted_entries[-1].get("weight", 0)
        
        if calculate_bmi:
            bmi = calculate_bmi(latest_weight, self.blocker.weight_height)
            if bmi and get_bmi_classification:
                # Get age/sex for age-specific classification
                age = self._get_user_age()
                sex = self.blocker.user_gender
                classification, color = get_bmi_classification(bmi, age, sex)
                
                # Add age context for pediatric classifications
                if age is not None and 2 <= age <= 19:
                    self.bmi_label.setText(f"<b style='color:{color}'>BMI: {bmi:.1f} ({classification})</b> <span style='font-size:9px;'>age {age}</span>")
                else:
                    self.bmi_label.setText(f"<b style='color:{color}'>BMI: {bmi:.1f} ({classification})</b>")
            else:
                self.bmi_label.setText("")
        else:
            self.bmi_label.setText("")
    
    def _update_prediction(self) -> None:
        """Update the goal prediction display."""
        if not self.blocker.weight_goal or not self.blocker.weight_entries:
            self.prediction_label.setText("")
            return
        
        sorted_entries = sorted(self.blocker.weight_entries, key=lambda x: x.get("date", ""))
        if len(sorted_entries) < 3:
            self.prediction_label.setText("<i>Need 3+ entries for prediction</i>")
            return
        
        latest_weight = sorted_entries[-1].get("weight", 0)
        
        if predict_goal_date:
            prediction = predict_goal_date(sorted_entries, self.blocker.weight_goal, latest_weight)
            if prediction:
                status = prediction.get("status", "")
                if status == "achieved":
                    self.prediction_label.setText("<b style='color:#00ff88'>üéØ Goal reached!</b>")
                elif prediction.get("predicted_date"):
                    days = prediction.get("days_remaining", 0)
                    pred_date = prediction["predicted_date"]
                    # Format datetime to string if needed
                    if hasattr(pred_date, 'strftime'):
                        date_str = pred_date.strftime("%b %d, %Y")
                    else:
                        date_str = str(pred_date)
                    if days and days > 0:
                        self.prediction_label.setText(f"üìÖ Estimated goal: <b>{date_str}</b> ({days} days)")
                    else:
                        self.prediction_label.setText(f"üìÖ Estimated goal: <b>{date_str}</b>")
                else:
                    msg = prediction.get("message", "")
                    self.prediction_label.setText(f"<i>{msg}</i>" if msg else "")
            else:
                self.prediction_label.setText("")
        else:
            self.prediction_label.setText("")
    
    def _update_comparisons(self) -> None:
        """Update historical comparison display."""
        if not self.blocker.weight_entries:
            self.compare_label.setText("No data for comparisons")
            return
        
        if get_historical_comparisons:
            # Get current context selection for context-aware comparison
            current_context = self.note_combo.currentData() or ""
            comparisons = get_historical_comparisons(
                self.blocker.weight_entries, 
                current_context=current_context if current_context else None
            )
            if comparisons:
                parts = []
                unit = self.blocker.weight_unit
                
                # Determine if goal is to lose or gain weight
                is_losing_goal = True  # Default: assume weight loss
                if self.blocker.weight_goal and self.blocker.weight_entries:
                    sorted_e = sorted(self.blocker.weight_entries, key=lambda x: x.get("date", ""))
                    if sorted_e:
                        current = sorted_e[-1].get("weight", 0)
                        is_losing_goal = self.blocker.weight_goal < current
                
                for period_key, data in comparisons.items():
                    if data is not None and isinstance(data, dict):
                        label = data.get("label", period_key)
                        change_kg = data.get("change", 0)
                        
                        if unit == "lbs":
                            change_display = change_kg * 2.20462
                            suffix = "lbs"
                        else:
                            change_display = change_kg
                            suffix = "kg"
                        
                        # Color based on goal direction
                        if is_losing_goal:
                            # Losing goal: negative change (lost weight) is good
                            if change_kg < 0:
                                color = "#00ff88"
                            elif change_kg > 0:
                                color = "#ff6464"
                            else:
                                color = "#888888"
                        else:
                            # Gaining goal: positive change (gained weight) is good
                            if change_kg > 0:
                                color = "#00ff88"
                            elif change_kg < 0:
                                color = "#ff6464"
                            else:
                                color = "#888888"
                        
                        sign = "+" if change_kg > 0 else ""
                        parts.append(f"<span style='color:{color}'>{label}: {sign}{change_display:.1f} {suffix}</span>")
                
                if parts:
                    self.compare_label.setText("<br>".join(parts))
                else:
                    self.compare_label.setText("Not enough historical data")
            else:
                self.compare_label.setText("Not enough historical data")
        else:
            self.compare_label.setText("Comparisons unavailable")
    
    def _on_reminder_toggle(self, state: int) -> None:
        """Handle reminder checkbox toggle."""
        enabled = state == QtCore.Qt.CheckState.Checked.value
        self.blocker.weight_reminder_enabled = enabled
        self.blocker.save_config()
        self._setup_reminder()
    
    def _on_reminder_time_changed(self, time: QtCore.QTime) -> None:
        """Handle reminder time change."""
        self.blocker.weight_reminder_time = time.toString("HH:mm")
        self.blocker.save_config()
        self._setup_reminder()
    
    def _setup_reminder(self) -> None:
        """Set up or cancel the reminder timer."""
        if self._reminder_timer:
            self._reminder_timer.stop()
            self._reminder_timer = None
        
        if not self.blocker.weight_reminder_enabled:
            return
        
        # Check every minute
        self._reminder_timer = QtCore.QTimer(self)
        self._reminder_timer.timeout.connect(self._check_reminder)
        self._reminder_timer.start(60000)  # 60 seconds
    
    def _check_reminder(self) -> None:
        """Check if reminder should be shown."""
        if not self.blocker.weight_reminder_enabled:
            return
        
        today = datetime.date.today().isoformat()
        
        # Skip if already reminded today
        if self.blocker.weight_last_reminder_date == today:
            return
        
        # Check if we already have an entry for today
        has_today_entry = any(e.get("date") == today for e in self.blocker.weight_entries)
        if has_today_entry:
            self.blocker.weight_last_reminder_date = today
            self.blocker.save_config()
            return
        
        # Check if it's at or after the reminder time
        current_time = QtCore.QTime.currentTime()
        reminder_time_str = self.blocker.weight_reminder_time or "08:00"
        try:
            h, m = map(int, reminder_time_str.split(":"))
            reminder_time = QtCore.QTime(h, m)
        except (ValueError, AttributeError):
            reminder_time = QtCore.QTime(8, 0)
        
        # Show reminder if current time is at or past reminder time
        if current_time >= reminder_time:
            self.blocker.weight_last_reminder_date = today
            self.blocker.save_config()
            self._show_reminder_notification()
    
    def _show_reminder_notification(self) -> None:
        """Show the weight reminder notification."""
        # Try system tray notification if available and visible
        parent_window = self.window()
        notification_shown = False
        if hasattr(parent_window, 'tray_icon') and parent_window.tray_icon and parent_window.tray_icon.isVisible():
            parent_window.tray_icon.showMessage(
                "‚öñÔ∏è Weight Reminder",
                "Don't forget to log your weight today!",
                QtWidgets.QSystemTrayIcon.MessageIcon.Information,
                5000
            )
            notification_shown = True
        
        # Fallback: show in-app toast (non-blocking, works even if window minimized)
        if not notification_shown:
            show_perk_toast("‚öñÔ∏è Don't forget to log your weight today!", "‚öñÔ∏è", self)
    
    def _update_weight_entity_perk_display(self) -> None:
        """Update the entity perk display using mini-cards like ADHD Buster patrons."""
        try:
            adhd_data = getattr(self.blocker, 'adhd_buster', {})
            if not adhd_data:
                self.weight_entity_section.setVisible(False)
                return
            
            from gamification import get_entity_weight_perks
            weight_perks = get_entity_weight_perks(adhd_data)
            legendary_bonus = weight_perks.get("legendary_bonus", 0)
            contributors = weight_perks.get("contributors", [])
            
            # Hide if no bonus
            if legendary_bonus <= 0 or not contributors:
                self.weight_entity_section.setVisible(False)
                return
            
            # Show section with appropriate title
            self.weight_entity_section.setVisible(True)
            self.weight_entity_section.set_title(f"üêÄ Rodent Squad (+{legendary_bonus}% Legendary)")
            
            # Clear previous content
            self.weight_entity_section.clear_content()
            
            # Try to import entity icon resolver
            try:
                from entitidex_tab import _resolve_entity_svg_path
                from entitidex.entity_pools import get_entity_by_id as get_entity
                from PySide6.QtSvg import QSvgRenderer
                has_svg_support = True
            except ImportError:
                has_svg_support = False
            
            # Create a horizontal flow layout for entity cards
            patrons_container = QtWidgets.QWidget()
            patrons_layout = QtWidgets.QHBoxLayout(patrons_container)
            patrons_layout.setContentsMargins(5, 5, 5, 5)
            patrons_layout.setSpacing(8)
            
            for entity_data in contributors:
                # Create a mini card for each entity
                card = QtWidgets.QFrame()
                is_exceptional = entity_data.get("is_exceptional", False)
                
                # Style cards - match Entity Patrons miniature style
                if is_exceptional:
                    card.setStyleSheet("""
                        QFrame {
                            background-color: #2a2a2a;
                            border: 1px solid #555;
                            border-radius: 6px;
                            padding: 4px;
                        }
                        QFrame:hover {
                            border-color: #666;
                            background-color: #333;
                        }
                    """)
                else:
                    card.setStyleSheet("""
                        QFrame {
                            background-color: #2a2a2a;
                            border: 1px solid #444;
                            border-radius: 6px;
                            padding: 4px;
                        }
                        QFrame:hover {
                            border-color: #7986cb;
                            background-color: #333;
                        }
                    """)
                
                card_layout = QtWidgets.QVBoxLayout(card)
                card_layout.setContentsMargins(8, 6, 8, 6)
                card_layout.setSpacing(4)
                
                # Try to load entity SVG icon
                entity_id = entity_data.get("entity_id", "")
                icon_loaded = False
                
                if has_svg_support and entity_id:
                    try:
                        entity_obj = get_entity(entity_id)
                        if entity_obj:
                            svg_path = _resolve_entity_svg_path(entity_obj, is_exceptional)
                            if svg_path:
                                renderer = QSvgRenderer(svg_path)
                                if renderer.isValid():
                                    # Create pixmap from SVG (40x40 size for mini cards)
                                    icon_size = 40
                                    pixmap = QtGui.QPixmap(icon_size, icon_size)
                                    pixmap.fill(QtCore.Qt.transparent)
                                    painter = QtGui.QPainter(pixmap)
                                    renderer.render(painter)
                                    painter.end()
                                    
                                    icon_lbl = QtWidgets.QLabel()
                                    icon_lbl.setPixmap(pixmap)
                                    icon_lbl.setAlignment(QtCore.Qt.AlignCenter)
                                    icon_lbl.setFixedSize(icon_size, icon_size)
                                    card_layout.addWidget(icon_lbl, alignment=QtCore.Qt.AlignCenter)
                                    icon_loaded = True
                    except Exception:
                        pass  # Fall back to text display
                
                # Entity name with exceptional styling
                name = entity_data.get("name", "Unknown")
                # Truncate long names
                if len(name) > 18:
                    display_name = name[:15] + "..."
                else:
                    display_name = name
                
                if is_exceptional:
                    name_style = "color: #ffd700; font-weight: bold; font-size: 10px;"
                    prefix = "‚≠ê " if not icon_loaded else ""
                else:
                    name_style = "color: #ccc; font-size: 10px;"
                    prefix = ""
                
                name_lbl = QtWidgets.QLabel(f"{prefix}{display_name}")
                name_lbl.setStyleSheet(name_style)
                name_lbl.setAlignment(QtCore.Qt.AlignCenter)
                name_lbl.setToolTip(f"{name}")
                name_lbl.setWordWrap(True)
                card_layout.addWidget(name_lbl)
                
                # Bonus value
                bonus_val = entity_data.get("bonus", 0)
                bonus_lbl = QtWidgets.QLabel(f"<b>+{bonus_val}%</b> üé≤")
                bonus_lbl.setStyleSheet("color: #7986cb; font-size: 12px;")
                bonus_lbl.setAlignment(QtCore.Qt.AlignCenter)
                card_layout.addWidget(bonus_lbl)
                
                patrons_layout.addWidget(card)
            
            patrons_layout.addStretch()
            self.weight_entity_section.add_widget(patrons_container)
            
            # Add a tip
            tip_lbl = QtWidgets.QLabel("üí° Collect more Rodent entities in Entitidex to boost Legendary chance when logging weight!")
            tip_lbl.setStyleSheet("color: #888; font-style: italic; font-size: 10px; padding-top: 4px;")
            self.weight_entity_section.add_widget(tip_lbl)
            
        except Exception as e:
            print(f"[Weight Tab] Error updating entity perk display: {e}")
            self.weight_entity_section.setVisible(False)

    def _refresh_rodent_tips(self) -> None:
        """Refresh the Rodent Squad weight control tips section.
        
        Shows tips when user has any rodent entity collected.
        If user has scientist_009 (White Mouse Archimedes), they can understand
        the tips in human language. Otherwise, tips appear as "rodent language" squeaks.
        """
        from datetime import datetime
        
        # Rodent entity IDs that contribute to weight perks
        RODENT_ENTITY_IDS = ["scholar_001", "underdog_001", "scientist_004", 
                            "wanderer_009", "scientist_009"]
        TRANSLATOR_ENTITY_ID = "scientist_009"  # White Mouse Archimedes
        
        try:
            from gamification import get_entitidex_manager
            from entitidex_tab import _resolve_entity_svg_path
            from entitidex.entity_pools import get_entity_by_id as get_entity
            from weight_control_tips import get_tip_by_index, get_tip_count, has_telepathic_translator
        except ImportError as e:
            # Dependencies not available
            self.rodent_tips_section.setVisible(False)
            return
        
        # Get entitidex manager to check entity collection
        try:
            manager = get_entitidex_manager(self.blocker.adhd_buster)
        except Exception:
            self.rodent_tips_section.setVisible(False)
            return
        
        # Check if user has ANY rodent entity collected
        has_any_rodent = False
        first_rodent_id = None
        first_rodent_exceptional = False
        
        for entity_id in RODENT_ENTITY_IDS:
            has_normal = entity_id in manager.progress.collected_entity_ids
            has_exceptional = manager.progress.is_exceptional(entity_id)
            if has_normal or has_exceptional:
                has_any_rodent = True
                if first_rodent_id is None:
                    first_rodent_id = entity_id
                    first_rodent_exceptional = has_exceptional
                break
        
        if not has_any_rodent:
            # No rodent entities collected - hide section
            self.rodent_tips_section.setVisible(False)
            return
        
        # At least one rodent is collected - show section
        self.rodent_tips_section.setVisible(True)
        
        # Check if user has the telepathic translator (Archimedes)
        self.has_translator = has_telepathic_translator(self.blocker.adhd_buster)
        
        # Update section title and styling based on translator status
        if self.has_translator:
            self.rodent_section_title.setText("üêÅ Rodent Squad Weight Control Tips")
            self.rodent_section_title.setStyleSheet("color: #81c784; font-size: 11px; font-weight: bold;")
            self.rodent_tips_section.setStyleSheet("""
                QFrame {
                    background-color: rgba(255, 255, 255, 0.04);
                    border: 1px solid rgba(102, 187, 106, 0.3);
                    border-radius: 8px;
                }
            """)
        else:
            self.rodent_section_title.setText("üê≠ Rodent Squad Tips (???)")
            self.rodent_section_title.setStyleSheet("color: #c4a35a; font-size: 11px; font-weight: bold;")
            self.rodent_tips_section.setStyleSheet("""
                QFrame {
                    background-color: rgba(255, 255, 255, 0.04);
                    border: 1px solid rgba(139, 115, 85, 0.3);
                    border-radius: 8px;
                }
            """)
        
        # Load first collected rodent's icon
        try:
            if first_rodent_id:
                entity = get_entity(first_rodent_id)
                if entity:
                    svg_path = _resolve_entity_svg_path(entity, first_rodent_exceptional)
                    if svg_path:
                        from PySide6.QtSvg import QSvgRenderer
                        renderer = QSvgRenderer(svg_path)
                        if renderer.isValid():
                            icon_size = 40
                            pixmap = QtGui.QPixmap(icon_size, icon_size)
                            pixmap.fill(QtCore.Qt.transparent)
                            painter = QtGui.QPainter(pixmap)
                            renderer.render(painter)
                            painter.end()
                            self.rodent_icon_label.setPixmap(pixmap)
                            
                            # Update icon style (subtle, no border)
                            self.rodent_icon_label.setStyleSheet("""
                                QLabel {
                                    background: transparent;
                                    border: none;
                                }
                            """)
        except Exception:
            # Fallback - just show text
            self.rodent_icon_label.setText("üê≠")
        
        # Get current tip index (sequential cycling)
        tip_key = "rodent_tip_index_translated" if self.has_translator else "rodent_tip_index_squeaks"
        tip_index = self.blocker.stats.get(tip_key, 0)
        total_tips = get_tip_count(self.has_translator)
        
        # Get the tip at current index
        tip_text, category_emoji = get_tip_by_index(tip_index, self.has_translator)
        
        # Update tip display
        self.rodent_tip_number.setText(f"Tip #{tip_index + 1} of {total_tips}")
        
        if self.has_translator:
            self.rodent_tip_text.setText(f"{category_emoji} {tip_text}")
            self.rodent_tip_text.setStyleSheet("color: #c5e1c5; font-size: 11px;")
        else:
            # Show rodent language with a hint
            self.rodent_tip_text.setText(f"üê≠ {tip_text}<br><br><i style='color:#888;'>üí° Telepathic skills would be necessary to understand the rodent language...</i>")
            self.rodent_tip_text.setStyleSheet("color: #d4c4a4; font-size: 11px;")
        
        # Check if already acknowledged today
        today_str = datetime.now().strftime("%Y-%m-%d")
        ack_key = "rodent_tip_acknowledged_date_translated" if self.has_translator else "rodent_tip_acknowledged_date_squeaks"
        last_acknowledged = self.blocker.stats.get(ack_key, "")
        
        if last_acknowledged == today_str:
            # Already acknowledged today
            self.rodent_acknowledge_btn.setText("‚úì Done")
            self.rodent_acknowledge_btn.setEnabled(False)
        else:
            # Can acknowledge
            self.rodent_acknowledge_btn.setText("üìñ +1ü™ô")
            self.rodent_acknowledge_btn.setEnabled(True)
            
        # Update button styling based on translator status
        if self.has_translator:
            self.rodent_acknowledge_btn.setStyleSheet("""
                QPushButton {
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                        stop:0 #66bb6a, stop:1 #4caf50);
                    color: white;
                    font-size: 11px;
                    font-weight: bold;
                    border-radius: 4px;
                    border: 1px solid #388e3c;
                    padding: 6px 8px;
                }
                QPushButton:hover {
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                        stop:0 #81c784, stop:1 #66bb6a);
                }
                QPushButton:disabled {
                    background: #444;
                    color: #777;
                    border: 1px solid #333;
                }
            """)
        else:
            self.rodent_acknowledge_btn.setStyleSheet("""
                QPushButton {
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                        stop:0 #8b7355, stop:1 #6b5335);
                    color: white;
                    font-size: 11px;
                    font-weight: bold;
                    border-radius: 4px;
                    border: 1px solid #5b4325;
                    padding: 6px 8px;
                }
                QPushButton:hover {
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                        stop:0 #a68365, stop:1 #8b7355);
                }
                QPushButton:disabled {
                    background: #444;
                    color: #777;
                    border: 1px solid #333;
                }
            """)

    def _acknowledge_rodent_tip(self) -> None:
        """Handle acknowledging the rodent tip - award coin and advance to next tip."""
        from datetime import datetime
        from weight_control_tips import get_tip_count
        
        try:
            # Determine if user has translator
            from weight_control_tips import has_telepathic_translator
            has_translator = has_telepathic_translator(self.blocker.adhd_buster)
            
            # Get keys based on translator status
            tip_key = "rodent_tip_index_translated" if has_translator else "rodent_tip_index_squeaks"
            ack_key = "rodent_tip_acknowledged_date_translated" if has_translator else "rodent_tip_acknowledged_date_squeaks"
            
            # Get current index and total
            current_index = self.blocker.stats.get(tip_key, 0)
            total_tips = get_tip_count(has_translator)
            
            # Advance to next tip (with wraparound)
            next_index = (current_index + 1) % total_tips
            self.blocker.stats[tip_key] = next_index
            
            # Record acknowledgment date
            today_str = datetime.now().strftime("%Y-%m-%d")
            self.blocker.stats[ack_key] = today_str
            
            # Award coin using GameState for reactive UI update
            main_window = self.window()
            game_state = getattr(main_window, 'game_state', None)
            if game_state:
                game_state.add_coins(1)
            else:
                # Fallback if GameState not available
                adhd_buster = self.blocker.adhd_buster
                adhd_buster["coins"] = adhd_buster.get("coins", 0) + 1
                self.blocker.save_config()
            
            # Save stats data
            self.blocker.save_stats()
            
            # Update button to show collected
            self.rodent_acknowledge_btn.setText("‚úì Done")
            self.rodent_acknowledge_btn.setEnabled(False)
            
        except Exception as e:
            print(f"[Weight Tab] Error acknowledging rodent tip: {e}")

    def _show_weekly_insights(self) -> None:
        """Show weekly insights in a dialog."""
        if not get_weekly_insights:
            show_info(self, "Weekly Insights", "Insights not available")
            return
        
        # Calculate actual streak from get_weight_stats
        actual_streak = 0
        if get_weight_stats and self.blocker.weight_entries:
            stats = get_weight_stats(self.blocker.weight_entries, self.blocker.weight_unit)
            actual_streak = stats.get("streak_days", 0)
        
        insights = get_weekly_insights(
            self.blocker.weight_entries,
            self.blocker.weight_milestones,
            actual_streak,
            self.blocker.weight_goal
        )
        
        if not insights or not insights.get("has_data"):
            msg = insights.get("message", "Not enough data for insights") if insights else "Not enough data for insights"
            show_info(self, "Weekly Insights", msg)
            return
        
        # Build insights message
        unit = self.blocker.weight_unit
        msg_parts = []
        
        msg_parts.append("<h3>üìä Weekly Summary</h3>")
        
        if insights.get("entries_count") is not None:
            msg_parts.append(f"<b>Entries logged:</b> {insights['entries_count']}")
        
        if insights.get("average") is not None:
            avg = insights["average"]
            if unit == "lbs":
                avg_display = avg * 2.20462
                suffix = "lbs"
            else:
                avg_display = avg
                suffix = "kg"
            msg_parts.append(f"<b>Average weight:</b> {avg_display:.1f} {suffix}")
        
        if insights.get("min") is not None and insights.get("max") is not None:
            min_w = insights["min"]
            max_w = insights["max"]
            if unit == "lbs":
                min_display = min_w * 2.20462
                max_display = max_w * 2.20462
                suffix = "lbs"
            else:
                min_display = min_w
                max_display = max_w
                suffix = "kg"
            msg_parts.append(f"<b>Range:</b> {min_display:.1f} - {max_display:.1f} {suffix}")
        
        if insights.get("change_from_last_week") is not None:
            change = insights["change_from_last_week"]
            if unit == "lbs":
                change_display = change * 2.20462
                suffix = "lbs"
            else:
                change_display = change
                suffix = "kg"
            color = "#00ff88" if change < 0 else "#ff6464" if change > 0 else "#888888"
            sign = "+" if change > 0 else ""
            msg_parts.append(f"<b>vs Last Week:</b> <span style='color:{color}'>{sign}{change_display:.2f} {suffix}</span>")
        
        if insights.get("streak") is not None and insights["streak"] > 0:
            msg_parts.append(f"<b>Streak:</b> üî• {insights['streak']} days")
        
        # Show insights list
        if insights.get("insights"):
            msg_parts.append("<br><b>Highlights:</b>")
            for insight_text in insights["insights"][:5]:  # Limit to 5
                msg_parts.append(f"‚Ä¢ {insight_text}")
        
        show_info(self, "üìä Weekly Insights", "<br>".join(msg_parts))


class ActivityTab(QtWidgets.QWidget):
    """Physical activity tracking tab with gamification rewards."""
    
    def __init__(self, blocker: 'BlockerCore', parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.blocker = blocker
        self._reminder_timer = None
        self._build_ui()
        self._refresh_display()
        self._setup_reminder()
        self.destroyed.connect(self._cleanup_timer)
    
    def _cleanup_timer(self) -> None:
        """Stop the reminder timer when the widget is destroyed."""
        if self._reminder_timer is not None:
            self._reminder_timer.stop()
            self._reminder_timer = None
    
    def _build_ui(self) -> None:
        layout = QtWidgets.QVBoxLayout(self)
        layout.setSpacing(10)
        layout.setContentsMargins(15, 15, 15, 15)
        
        add_tab_help_button(layout, "activity", self)
        
        # Header
        header_layout = QtWidgets.QHBoxLayout()
        header = QtWidgets.QLabel("üèÉ Activity Tracker")
        header.setStyleSheet("font-size: 18px; font-weight: bold; color: #ffffff;")
        header_layout.addWidget(header)
        header_layout.addStretch()
        layout.addLayout(header_layout)
        
        # Entity XP Perk Section - shows entities that boost XP
        # Moved to top for better visibility (friendly name: XP Physical Activists)
        self.activity_entity_section = CollapsibleSection("‚ö° XP Physical Activists", "activity_entity_section", parent=self)
        self.activity_entity_section.setVisible(False)
        layout.addWidget(self.activity_entity_section)
        
        # Update entity perk display
        self._update_activity_entity_perk_display()
        
        # Main content split
        content_layout = QtWidgets.QHBoxLayout()
        
        # Left: Log activity form
        left_panel = QtWidgets.QGroupBox("Log Activity")
        left_layout = QtWidgets.QVBoxLayout(left_panel)
        
        # Date input
        date_layout = QtWidgets.QHBoxLayout()
        date_layout.addWidget(QtWidgets.QLabel("Date:"))
        self.date_edit = QtWidgets.QDateEdit()
        self.date_edit.setCalendarPopup(True)
        self.date_edit.setDate(QtCore.QDate.currentDate())
        self.date_edit.setMaximumDate(QtCore.QDate.currentDate())
        date_layout.addWidget(self.date_edit)
        date_layout.addStretch()
        left_layout.addLayout(date_layout)
        
        # Activity type
        type_layout = QtWidgets.QHBoxLayout()
        type_layout.addWidget(QtWidgets.QLabel("Activity:"))
        self.activity_combo = NoScrollComboBox()
        for activity_id, name, emoji, _ in ACTIVITY_TYPES:
            self.activity_combo.addItem(f"{emoji} {name}", activity_id)
        self.activity_combo.setCurrentIndex(0)  # Walking
        type_layout.addWidget(self.activity_combo)
        left_layout.addLayout(type_layout)
        
        # Duration
        duration_layout = QtWidgets.QHBoxLayout()
        duration_layout.addWidget(QtWidgets.QLabel("Duration:"))
        self.duration_spin = NoScrollSpinBox()
        self.duration_spin.setRange(1, 480)  # 1 min to 8 hours
        self.duration_spin.setValue(30)
        self.duration_spin.setSuffix(" min")
        duration_layout.addWidget(self.duration_spin)
        duration_layout.addStretch()
        left_layout.addLayout(duration_layout)
        
        # Intensity
        intensity_layout = QtWidgets.QHBoxLayout()
        intensity_layout.addWidget(QtWidgets.QLabel("Intensity:"))
        self.intensity_combo = NoScrollComboBox()
        for intensity_id, name, _ in INTENSITY_LEVELS:
            self.intensity_combo.addItem(name, intensity_id)
        self.intensity_combo.setCurrentIndex(1)  # Moderate
        intensity_layout.addWidget(self.intensity_combo)
        intensity_layout.addStretch()
        left_layout.addLayout(intensity_layout)
        
        # Note
        note_layout = QtWidgets.QHBoxLayout()
        note_layout.addWidget(QtWidgets.QLabel("Note:"))
        self.note_input = QtWidgets.QLineEdit()
        self.note_input.setPlaceholderText("Optional note...")
        self.note_input.setMaxLength(100)
        note_layout.addWidget(self.note_input)
        left_layout.addLayout(note_layout)
        
        # Log button
        self.log_btn = QtWidgets.QPushButton("üèÜ Log Activity")
        self.log_btn.setStyleSheet("""
            QPushButton {
                background-color: #4caf50;
                color: white;
                font-size: 14px;
                font-weight: bold;
                padding: 10px;
                border-radius: 5px;
            }
            QPushButton:hover { background-color: #66bb6a; }
        """)
        self.log_btn.clicked.connect(self._log_activity)
        left_layout.addWidget(self.log_btn)
        
        # Quick presets
        presets_label = QtWidgets.QLabel("Quick Presets:")
        presets_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        left_layout.addWidget(presets_label)
        
        presets_layout = QtWidgets.QGridLayout()
        presets = [
            ("üö∂ 10min Walk", "walking", 10, "light"),
            ("üö∂ 30min Walk", "walking", 30, "moderate"),
            ("üèÉ 20min Jog", "jogging", 20, "moderate"),
            ("üèãÔ∏è 45min Gym", "strength", 45, "vigorous"),
            ("üßò 30min Yoga", "yoga", 30, "light"),
            ("üî• 30min HIIT", "hiit", 30, "intense"),
        ]
        for i, (label, activity, duration, intensity) in enumerate(presets):
            btn = QtWidgets.QPushButton(label)
            btn.setStyleSheet("padding: 5px;")
            btn.clicked.connect(lambda _, a=activity, d=duration, i=intensity: self._apply_preset(a, d, i))
            presets_layout.addWidget(btn, i // 2, i % 2)
        left_layout.addLayout(presets_layout)
        
        left_layout.addStretch()
        content_layout.addWidget(left_panel)
        
        # Right: Stats and history
        right_panel = QtWidgets.QGroupBox("Stats & History")
        right_layout = QtWidgets.QVBoxLayout(right_panel)
        
        # Stats display
        self.stats_label = QtWidgets.QLabel()
        self.stats_label.setWordWrap(True)
        self.stats_label.setStyleSheet("font-size: 11px;")
        right_layout.addWidget(self.stats_label)
        
        # History table
        self.entries_table = QtWidgets.QTableWidget()
        self.entries_table.setColumnCount(5)
        self.entries_table.setHorizontalHeaderLabels(["Date", "Activity", "Duration", "Intensity", ""])
        self.entries_table.horizontalHeader().setStretchLastSection(True)
        self.entries_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.entries_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        right_layout.addWidget(self.entries_table)
        
        content_layout.addWidget(right_panel)
        layout.addLayout(content_layout)
        
        # Reminder section at bottom
        reminder_layout = QtWidgets.QHBoxLayout()
        self.reminder_checkbox = QtWidgets.QCheckBox("Daily reminder at:")
        self.reminder_checkbox.setChecked(self.blocker.activity_reminder_enabled)
        self.reminder_checkbox.stateChanged.connect(self._update_reminder_setting)
        reminder_layout.addWidget(self.reminder_checkbox)
        
        self.reminder_time = QtWidgets.QTimeEdit()
        self.reminder_time.setDisplayFormat("HH:mm")
        try:
            h, m = self.blocker.activity_reminder_time.split(":")
            self.reminder_time.setTime(QtCore.QTime(int(h), int(m)))
        except (ValueError, AttributeError):
            self.reminder_time.setTime(QtCore.QTime(18, 0))
        self.reminder_time.timeChanged.connect(self._update_reminder_setting)
        reminder_layout.addWidget(self.reminder_time)
        reminder_layout.addStretch()
        layout.addLayout(reminder_layout)
        
        # Rewards info section
        rewards_group = QtWidgets.QGroupBox("üéÅ Rewards Info")
        rewards_layout = QtWidgets.QVBoxLayout(rewards_group)
        rewards_info = QtWidgets.QLabel(
            "<b>How it works:</b> Log activity (10+ min) to earn 1 item. Rarity based on effective minutes.<br>"
            "<i>Effective min = duration √ó activity multiplier √ó intensity multiplier</i><br>"
            "<i>Example: 30min jog (2.0√ó) at moderate (1.0√ó) = 60 effective min</i><br>"
            "<table style='font-size:10px; color:#888888; margin-top:5px;'>"
            "<tr><th>Eff. Min</th><th>Common</th><th>Uncommon</th><th>Rare</th><th>Epic</th><th>Legendary</th></tr>"
            "<tr><td>&lt;8</td><td colspan='5' style='text-align:center;'>No reward</td></tr>"
            "<tr><td>8+</td><td>75%</td><td>20%</td><td>5%</td><td>-</td><td>-</td></tr>"
            "<tr><td>20+</td><td>25%</td><td>50%</td><td>20%</td><td>5%</td><td>-</td></tr>"
            "<tr><td>40+</td><td>5%</td><td>20%</td><td>50%</td><td>20%</td><td>5%</td></tr>"
            "<tr><td>70+</td><td>-</td><td>5%</td><td>20%</td><td>50%</td><td>25%</td></tr>"
            "<tr><td>100+</td><td>-</td><td>-</td><td>5%</td><td>20%</td><td>75%</td></tr>"
            "<tr><td>120+</td><td>-</td><td>-</td><td>-</td><td>-</td><td>100%</td></tr>"
            "</table>"
            "<br><b>Streaks:</b> 3d=Uncommon, 7d=Rare, 14d=Epic, 30d=Legendary"
        )
        rewards_info.setWordWrap(True)
        rewards_info.setStyleSheet("color: #888888; font-size: 10px;")
        rewards_layout.addWidget(rewards_info)
        layout.addWidget(rewards_group)
    
    def _apply_preset(self, activity: str, duration: int, intensity: str) -> None:
        """Apply a quick preset to the form."""
        # Find activity index
        for i in range(self.activity_combo.count()):
            if self.activity_combo.itemData(i) == activity:
                self.activity_combo.setCurrentIndex(i)
                break
        
        self.duration_spin.setValue(duration)
        
        # Find intensity index
        for i in range(self.intensity_combo.count()):
            if self.intensity_combo.itemData(i) == intensity:
                self.intensity_combo.setCurrentIndex(i)
                break
    
    def _log_activity(self) -> None:
        """Log a new activity entry."""
        date_str = self.date_edit.date().toString("yyyy-MM-dd")
        duration = self.duration_spin.value()
        activity_id = self.activity_combo.currentData()
        intensity_id = self.intensity_combo.currentData()
        note = self.note_input.text().strip()
        
        # Allow logging any activity, but warn if below reward threshold
        if duration < ACTIVITY_MIN_DURATION:
            reply = show_question(
                self, "Short Activity",
                f"Activities under {ACTIVITY_MIN_DURATION} minutes don't earn rewards.\n"
                f"Log anyway for tracking?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
            )
            if reply != QtWidgets.QMessageBox.Yes:
                return
        
        # Get entries WITHOUT current date for reward calculation
        entries_for_reward = [e for e in self.blocker.activity_entries if e.get("date") != date_str]
        
        # Check for rewards
        rewards = None
        effective_mins = 0
        rarity = None
        if GAMIFICATION_AVAILABLE and check_all_activity_rewards and is_gamification_enabled(self.blocker.adhd_buster):
            story_id = self.blocker.adhd_buster.get("active_story", "warrior")
            rewards = check_all_activity_rewards(
                entries_for_reward,
                duration,
                activity_id,
                intensity_id,
                date_str,
                self.blocker.activity_milestones,
                story_id
            )
            
            # Get effective minutes and rarity for lottery animation
            if rewards and rewards.get("reward"):
                effective_mins = rewards.get("effective_minutes", 0)
                rarity = rewards.get("rarity")
        
        # Show lottery animation if we got a reward
        if rarity and effective_mins >= 8:
            from lottery_animation import MergeTwoStageLotteryDialog
            
            # Get entity perk contributors for display during lottery
            entity_perk_contributors = []
            try:
                from gamification import get_entity_luck_perk_contributors
                luck_perks = get_entity_luck_perk_contributors(self.blocker.adhd_buster)
                entity_perk_contributors = luck_perks.get("contributors", [])
            except Exception:
                pass
            
            # Use lottery animation for activity rewards (guaranteed success)
            lottery = MergeTwoStageLotteryDialog(
                success_roll=-1,  # Auto-generate (any roll succeeds with 100% threshold)
                success_threshold=1.0,  # 100% success rate
                tier_upgrade_enabled=False,
                base_rarity=rarity,
                title="üèÉ Activity Reward!",  # Custom title instead of "Lucky Merge"
                parent=self,
                entity_perk_contributors=entity_perk_contributors
            )
            lottery.exec()
            lottery.hide()  # Explicitly hide before deletion
            lottery.deleteLater()  # Ensure dialog is cleaned up
        
        # Create entry
        new_entry = {
            "date": date_str,
            "duration": duration,
            "activity_type": activity_id,
            "intensity": intensity_id,
        }
        if note:
            new_entry["note"] = note
        
        # Check for existing entry on same date
        # User feedback indicates they prefer separate entries (e.g., multiple walks)
        # rather than merging them. So we simply append the new entry.
        self.blocker.activity_entries.append(new_entry)
        self.blocker.activity_entries.sort(key=lambda x: x.get("date", ""), reverse=True)
        
        self.blocker.save_config()
        
        # Award city activity resource based on EFFECTIVE minutes (duration √ó intensity)
        # This rewards more intense and longer activities proportionally
        # Formula: Base +1 per activity, plus +1 per 20 effective minutes
        city_activity_earned = 0
        city_goldmine_coins = 0
        city_construction_progress = None  # Track construction progress for feedback
        if CITY_AVAILABLE:
            try:
                from city import add_city_resource, get_active_construction_info, award_exercise_income
                
                # Calculate effective minutes (factors in both duration and intensity)
                effective_mins = 0
                if rewards and rewards.get("effective_minutes"):
                    effective_mins = rewards["effective_minutes"]
                else:
                    # Fallback: just use raw duration if rewards not available
                    effective_mins = duration
                
                # Base: +1 for logging any activity
                # Bonus: +1 per 20 effective minutes (rewards intensity!)
                base_amount = 1
                effective_bonus = int(effective_mins // 20)
                city_activity_earned = base_amount + effective_bonus
                
                # Check for active construction before adding
                active_before = get_active_construction_info(self.blocker.adhd_buster)
                
                invested = add_city_resource(self.blocker.adhd_buster, "activity", city_activity_earned)
                
                # Track construction progress for feedback to user
                if invested > 0 and active_before:
                    building_name = active_before.get("building_name", "Building")
                    building_id = active_before.get("building_id", "")
                    level = active_before.get("level", 1)
                    progress_after = get_active_construction_info(self.blocker.adhd_buster)
                    new_progress = progress_after.get("effort_progress_percent", 0) if progress_after else 100
                    city_construction_progress = {
                        "building_name": building_name,
                        "building_id": building_id,
                        "level": level,
                        "invested": invested,
                        "progress_percent": new_progress,
                        "completed": progress_after is None  # Construction completed!
                    }
                    logger.info(f"Activity contributed {invested} activity to {building_name} ({new_progress:.0f}% complete)")
                elif active_before and invested == 0:
                    # Building doesn't need activity (requirement is 0)
                    building_name = active_before.get("building_name", "Building")
                    requirements = active_before.get("requirements", {})
                    if requirements.get("activity", 0) == 0:
                        city_construction_progress = {
                            "building_name": building_name,
                            "building_id": active_before.get("building_id", ""),
                            "level": active_before.get("level", 1),
                            "invested": 0,
                            "progress_percent": active_before.get("effort_progress_percent", 0),
                            "completed": False,
                            "not_needed": True
                        }
                
                # Award Goldmine income for exercise (moderate+ intensity)
                goldmine_result = award_exercise_income(
                    self.blocker.adhd_buster,
                    duration,
                    intensity_id,
                    effective_mins,
                    None  # No game_state signal needed
                )
                city_goldmine_coins = goldmine_result.get("coins", 0)
                
                if city_goldmine_coins > 0:
                    logger.info(f"Exercise awarded {city_goldmine_coins} Goldmine coins")
                    
            except Exception as e:
                logger.debug(f"City resource/income error: {e}")
        
        # Award coins for activity (5-20 coins based on effective minutes)
        # This is the base activity coin reward, Goldmine coins are additive
        coins_earned = 0
        if GAMIFICATION_AVAILABLE and is_gamification_enabled(self.blocker.adhd_buster):
            if rewards and rewards.get("effective_minutes"):
                effective_mins = rewards["effective_minutes"]
                # Scale: 30 eff min = 5 coins, 60+ = 10 coins, 120+ = 20 coins
                if effective_mins >= 120:
                    coins_earned = 20
                elif effective_mins >= 60:
                    coins_earned = 10
                elif effective_mins >= 30:
                    coins_earned = 5
                
                # Coins will be awarded in _process_rewards via game_state
        
        # Process rewards (Goldmine coins already awarded directly to adhd_buster, pass for display)
        if rewards and GAMIFICATION_AVAILABLE:
            self._process_rewards(rewards, coins_earned=coins_earned, city_activity_earned=city_activity_earned, city_construction_progress=city_construction_progress, city_goldmine_coins=city_goldmine_coins)
        
        # Update main timeline widget if parent window has it
        if self.parent() and hasattr(self.parent(), 'timeline_widget'):
            try:
                self.parent().timeline_widget.update_data()
            except Exception:
                pass
        
        # Reset form
        self.note_input.clear()
        self._refresh_display()
    
    def _process_rewards(self, rewards: dict, coins_earned: int = 0, city_activity_earned: int = 0, city_construction_progress: dict = None, city_goldmine_coins: int = 0) -> None:
        """Process and show activity rewards."""
        items_earned = []
        new_milestone_ids = []
        
        # Base activity reward - items added via game_state below
        if rewards.get("reward"):
            item = rewards["reward"]
            items_earned.append(("Activity", item))
        
        # Streak reward
        if rewards.get("streak_reward"):
            streak_data = rewards["streak_reward"]
            item = streak_data["item"]
            items_earned.append((f"üî• {streak_data['streak_days']}-Day Streak", item))
            new_milestone_ids.append(streak_data["milestone_id"])
        
        # Milestone rewards
        for milestone in rewards.get("new_milestones", []):
            item = milestone["item"]
            items_earned.append((f"üèÜ {milestone['name']}", item))
            new_milestone_ids.append(milestone["milestone_id"])
        
        # Save new milestones
        if new_milestone_ids:
            self.blocker.activity_milestones.extend(new_milestone_ids)
        
        # Generate diary entry (once per day)
        diary_entry = None
        if items_earned and GAMIFICATION_AVAILABLE and generate_diary_entry and calculate_character_power:
            today = datetime.now().strftime("%Y-%m-%d")
            diary = self.blocker.adhd_buster.get("diary", [])
            today_entries = [e for e in diary if e.get("date") == today]
            
            if not today_entries:
                power = calculate_character_power(self.blocker.adhd_buster)
                equipped = self.blocker.adhd_buster.get("equipped", {})
                active_story = self.blocker.adhd_buster.get("active_story", "warrior")
                diary_entry = generate_diary_entry(power, session_minutes=0, equipped_items=equipped,
                                                   story_id=active_story)
                if "diary" not in self.blocker.adhd_buster:
                    self.blocker.adhd_buster["diary"] = []
                self.blocker.adhd_buster["diary"].append(diary_entry)
                if len(self.blocker.adhd_buster["diary"]) > 100:
                    self.blocker.adhd_buster["diary"] = self.blocker.adhd_buster["diary"][-100:]
        
        if items_earned or coins_earned > 0:
            # Get equipped BEFORE awarding items (for comparison)
            equipped_before = {k: dict(v) if isinstance(v, dict) else v 
                             for k, v in self.blocker.adhd_buster.get("equipped", {}).items()}
            
            # Extract just the items for the batch award
            just_items = [item for _, item in items_earned]
            
            # Use GameState manager for reactive updates
            main_window = self.window()
            game_state = getattr(main_window, 'game_state', None)
            if not game_state:
                logger.error("GameStateManager not available - cannot award activity rewards")
                return
            
            # Use batch award - handles inventory, auto-equip, coins, save, and signals
            award_result = game_state.award_items_batch(just_items, coins=coins_earned, auto_equip=True, source="activity_tracking")
            
            # Get the slots that were actually auto-equipped
            equipped_after = game_state.adhd_buster.get("equipped", {})
            auto_equipped_slots = [item.get("slot") for item in award_result.get("equipped", []) if item.get("slot")]
            
            # Build extra messages
            extra_msgs = []
            if rewards.get("effective_minutes"):
                extra_msgs.append(f"Effective minutes: {rewards['effective_minutes']:.0f}")
            if rewards.get("current_streak", 0) > 0:
                extra_msgs.append(f"Streak: {rewards['current_streak']} days üî•")
            
            # Show city building contribution using stored progress info
            if city_construction_progress:
                building_name = city_construction_progress.get("building_name", "Building")
                invested = city_construction_progress.get("invested", 0)
                progress_pct = city_construction_progress.get("progress_percent", 0)
                completed = city_construction_progress.get("completed", False)
                not_needed = city_construction_progress.get("not_needed", False)
                
                if completed:
                    extra_msgs.append(f"üéâ +{invested} Activity ‚Üí {building_name} COMPLETE!")
                elif not_needed:
                    extra_msgs.append(f"‚ÑπÔ∏è {building_name} doesn't need Activity (use Focus)")
                else:
                    extra_msgs.append(f"üèóÔ∏è +{invested} Activity ‚Üí {building_name} ({progress_pct:.0f}%)")
            # Note: Don't show warning when no construction - it's not actionable info
            
            # Show Goldmine coins if earned (from moderate+ intensity exercise)
            if city_goldmine_coins > 0:
                extra_msgs.append(f"‚õèÔ∏è +{city_goldmine_coins} Goldmine Coins (moderate+ exercise)")
            
            # Get entity perk contributors for luck/rarity bonuses
            entity_perk_contributors = []
            try:
                from gamification import get_entity_luck_perk_contributors
                luck_perks = get_entity_luck_perk_contributors(self.blocker.adhd_buster)
                entity_perk_contributors = luck_perks.get("contributors", [])
            except Exception:
                pass
            
            # Use new ItemRewardDialog with comparison and proper auto-equip tracking
            from styled_dialog import ItemRewardDialog
            dialog = ItemRewardDialog(
                parent=self,
                title="Activity Rewards!",
                header_emoji="üèÜ",
                source_label="Great workout!",
                items_earned=just_items,
                equipped=equipped_before,  # What was equipped before for comparison
                equipped_after=equipped_after,  # Current equipped state
                auto_equipped_slots=auto_equipped_slots,  # Slots that were actually auto-equipped
                game_state=game_state,  # For click-to-equip
                coins_earned=coins_earned,
                extra_messages=extra_msgs,
                entity_perk_contributors=entity_perk_contributors,  # Entity perks that helped
            )
            dialog.exec()
            dialog.hide()  # Explicitly hide before deletion
            dialog.deleteLater()  # Ensure dialog is cleaned up
            
            # üéâ Show building complete celebration if construction just finished
            if city_construction_progress and city_construction_progress.get("completed"):
                try:
                    from city_tab import show_building_complete_dialog
                    building_id = city_construction_progress.get("building_id", "")
                    level = city_construction_progress.get("level", 1)
                    # If level > 1, this was an upgrade, not initial construction
                    is_upgrade = level > 1
                    show_building_complete_dialog(building_id, level, is_upgrade, parent=self.window())
                    # Refresh city tab to show completed building (remove construction overlay)
                    if hasattr(main_window, 'city_tab') and hasattr(main_window.city_tab, '_refresh_city'):
                        main_window.city_tab._refresh_city()
                except Exception as e:
                    logger.debug(f"Could not show building complete dialog: {e}")
            
            # Update coin display
            main_window = self.window()
            if hasattr(main_window, '_update_coin_display'):
                main_window._update_coin_display()
            
            # Show diary entry reveal
            if diary_entry:
                diary_dlg = DiaryEntryRevealDialog(self.blocker, diary_entry, session_minutes=0, parent=self.window())
                diary_dlg.exec()
                diary_dlg.hide()  # Explicitly hide before deletion
                diary_dlg.deleteLater()
            
            # Refresh ADHD Buster tab
            main_window = self.window()
            if hasattr(main_window, 'refresh_adhd_tab'):
                main_window.refresh_adhd_tab()
            
            # Refresh city tab if construction progress changed
            if city_construction_progress and hasattr(main_window, 'city_tab'):
                main_window.city_tab._refresh_city()
        elif rewards.get("messages"):
            show_info(
                self, "Activity Logged",
                "\n".join(rewards["messages"])
            )
    
    def _delete_entry(self, entry_index: int) -> None:
        """Delete an activity entry by index."""
        if entry_index < 0 or entry_index >= len(self.blocker.activity_entries):
            return
        entry = self.blocker.activity_entries[entry_index]
        date_str = entry.get("date", "")
        activity_type = entry.get("activity_type", "")
        reply = show_question(
            self, "Delete Entry",
            f"Delete the {activity_type} entry for {date_str}?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        )
        if reply == QtWidgets.QMessageBox.Yes:
            del self.blocker.activity_entries[entry_index]
            self.blocker.save_config()
            self._refresh_display()
    
    def _refresh_display(self) -> None:
        """Refresh all display elements."""
        self.date_edit.setMaximumDate(QtCore.QDate.currentDate())
        entries = self.blocker.activity_entries
        
        # Update stats
        if get_activity_stats:
            stats = get_activity_stats(entries)
            
            # Get favorite activity name
            fav_name = "None"
            if stats.get("favorite_activity"):
                for aid, name, emoji, _ in ACTIVITY_TYPES:
                    if aid == stats["favorite_activity"]:
                        fav_name = f"{emoji} {name}"
                        break
            
            # Calculate Today's Breakdown
            today_str = datetime.now().strftime("%Y-%m-%d")
            today_totals = {}
            for e in entries:
                if e.get("date") == today_str:
                    aid = e.get("activity_type")
                    today_totals[aid] = today_totals.get(aid, 0) + e.get("duration", 0)
            
            today_html = ""
            if today_totals:
                today_html = "<br><b>Today's Totals:</b><br>"
                sorted_today = sorted(today_totals.items(), key=lambda x: x[1], reverse=True)
                for aid, mins in sorted_today:
                    aname = aid.title()
                    # Try to match with emoji
                    for taid, tname, temoji, _ in ACTIVITY_TYPES:
                        if taid == aid:
                            aname = f"{temoji} {tname}"
                            break
                    today_html += f"{aname}: {mins} min<br>"
            
            stats_html = f"""
<b>üìä Your Activity Stats</b><br><br>
<b>Total Time:</b> {format_activity_duration(stats['total_minutes']) if format_activity_duration else f"{stats['total_minutes']} min"}<br>
<b>Sessions:</b> {stats['total_sessions']}<br>
<b>This Week:</b> {format_activity_duration(stats['this_week_minutes']) if format_activity_duration else f"{stats['this_week_minutes']} min"}<br>
<b>This Month:</b> {format_activity_duration(stats['this_month_minutes']) if format_activity_duration else f"{stats['this_month_minutes']} min"}<br>
<b>Avg Duration:</b> {stats['avg_duration']:.0f} min<br>
<b>Favorite:</b> {fav_name}<br>
<b>Streak:</b> üî• {stats['current_streak']} days<br>
{today_html}
"""
            self.stats_label.setText(stats_html)
        
        # Update history table - create sorted view with original indices
        entries_with_indices = list(enumerate(entries))
        sorted_entries = sorted(entries_with_indices, key=lambda x: x[1].get("date", ""), reverse=True)[:50]
        self.entries_table.setRowCount(len(sorted_entries))
        
        for i, (orig_idx, entry) in enumerate(sorted_entries):
            # Date
            self.entries_table.setItem(i, 0, QtWidgets.QTableWidgetItem(entry.get("date", "")))
            
            # Activity type
            activity_name = entry.get("activity_type", "other")
            for aid, name, emoji, _ in ACTIVITY_TYPES:
                if aid == activity_name:
                    activity_name = f"{emoji} {name}"
                    break
            self.entries_table.setItem(i, 1, QtWidgets.QTableWidgetItem(activity_name))
            
            # Duration
            duration = entry.get("duration", 0)
            self.entries_table.setItem(i, 2, QtWidgets.QTableWidgetItem(f"{duration} min"))
            
            # Intensity
            intensity_name = entry.get("intensity", "moderate")
            for iid, name, _ in INTENSITY_LEVELS:
                if iid == intensity_name:
                    intensity_name = name
                    break
            self.entries_table.setItem(i, 3, QtWidgets.QTableWidgetItem(intensity_name))
            
            # Delete button - pass original index for correct deletion
            del_btn = QtWidgets.QPushButton("üóë")
            del_btn.setMaximumWidth(30)
            del_btn.clicked.connect(
                lambda _, idx=orig_idx: self._delete_entry(idx)
            )
            self.entries_table.setCellWidget(i, 4, del_btn)
        
        self.entries_table.resizeColumnsToContents()
    
    def _setup_reminder(self) -> None:
        """Setup daily reminder timer."""
        if self._reminder_timer:
            self._reminder_timer.stop()
        
        if not self.blocker.activity_reminder_enabled:
            return
        
        self._reminder_timer = QtCore.QTimer(self)
        self._reminder_timer.timeout.connect(self._check_reminder)
        self._reminder_timer.start(60000)  # Check every minute
    
    def _check_reminder(self) -> None:
        """Check if it's time to show reminder."""
        if not self.blocker.activity_reminder_enabled:
            return
        
        from app_utils import get_activity_date
        # Use activity date (5 AM cutoff) for daily tracking
        today = get_activity_date()
        if self.blocker.activity_last_reminder_date == today:
            return
        
        current_time = QtCore.QTime.currentTime()
        try:
            h, m = self.blocker.activity_reminder_time.split(":")
            reminder_time = QtCore.QTime(int(h), int(m))
        except (ValueError, AttributeError):
            return
        
        if current_time >= reminder_time:
            # Check if already logged today
            has_today = any(e.get("date") == today for e in self.blocker.activity_entries)
            if not has_today:
                self.blocker.activity_last_reminder_date = today
                self.blocker.save_config()
                
                # Try system tray notification if available and visible
                parent_window = self.window()
                notification_shown = False
                if hasattr(parent_window, 'tray_icon') and parent_window.tray_icon and parent_window.tray_icon.isVisible():
                    parent_window.tray_icon.showMessage(
                        "üèÉ Activity Reminder",
                        "Time to get moving! Even a 10-minute walk earns rewards.",
                        QtWidgets.QSystemTrayIcon.MessageIcon.Information,
                        5000
                    )
                    notification_shown = True
                
                # Fallback: show in-app toast (non-blocking)
                if not notification_shown:
                    show_perk_toast("üèÉ Time to get moving! Log your activity for rewards.", "üèÉ", self)
    
    def _update_reminder_setting(self) -> None:
        """Update reminder settings."""
        self.blocker.activity_reminder_enabled = self.reminder_checkbox.isChecked()
        self.blocker.activity_reminder_time = self.reminder_time.time().toString("HH:mm")
        self.blocker.save_config()
        self._setup_reminder()

    def _update_activity_entity_perk_display(self) -> None:
        """Update the entity perk display using mini-cards for XP boosters."""
        try:
            adhd_data = getattr(self.blocker, 'adhd_buster', {})
            if not adhd_data:
                self.activity_entity_section.setVisible(False)
                return
            
            from gamification import get_entity_xp_perk_contributors
            xp_perks = get_entity_xp_perk_contributors(adhd_data)
            total_xp_bonus = xp_perks.get("total_xp_bonus", 0)
            contributors = xp_perks.get("contributors", [])
            
            # Hide if no contributors
            if total_xp_bonus <= 0 or not contributors:
                self.activity_entity_section.setVisible(False)
                return
            
            # Show section with appropriate title
            self.activity_entity_section.setVisible(True)
            self.activity_entity_section.set_title(f"‚ö° XP Physical Activists (+{total_xp_bonus}% XP)")
            
            # Clear previous content
            self.activity_entity_section.clear_content()
            
            # Try to import entity icon resolver
            try:
                from entitidex_tab import _resolve_entity_svg_path
                from entitidex.entity_pools import get_entity_by_id as get_entity
                from PySide6.QtSvg import QSvgRenderer
                has_svg_support = True
            except ImportError:
                has_svg_support = False
            
            # Create a horizontal flow layout for entity cards
            patrons_container = QtWidgets.QWidget()
            patrons_layout = QtWidgets.QHBoxLayout(patrons_container)
            patrons_layout.setContentsMargins(5, 5, 5, 5)
            patrons_layout.setSpacing(8)
            
            for entity_data in contributors:
                # Create a mini card for each entity
                card = QtWidgets.QFrame()
                is_exceptional = entity_data.get("is_exceptional", False)
                
                # Style cards - exceptional gets slightly lighter border
                if is_exceptional:
                    card.setStyleSheet("""
                        QFrame {
                            background-color: rgba(255, 215, 0, 0.08);
                            border: 1px solid rgba(255, 215, 0, 0.15);
                            border-radius: 6px;
                            padding: 4px;
                        }
                        QFrame:hover {
                            background-color: rgba(255, 215, 0, 0.15);
                            border: 1px solid rgba(255, 215, 0, 0.3);
                        }
                    """)
                else:
                    card.setStyleSheet("""
                        QFrame {
                            background-color: rgba(255, 255, 255, 0.04);
                            border: 1px solid rgba(255, 255, 255, 0.06);
                            border-radius: 6px;
                            padding: 4px;
                        }
                        QFrame:hover {
                            background-color: rgba(255, 255, 255, 0.08);
                            border: 1px solid rgba(255, 255, 255, 0.15);
                        }
                    """)
                
                card_layout = QtWidgets.QVBoxLayout(card)
                card_layout.setContentsMargins(8, 6, 8, 6)
                card_layout.setSpacing(4)
                
                # Try to load entity SVG icon
                entity_id = entity_data.get("entity_id", "")
                icon_loaded = False
                
                if has_svg_support and entity_id:
                    try:
                        entity_obj = get_entity(entity_id)
                        if entity_obj:
                            svg_path = _resolve_entity_svg_path(entity_obj, is_exceptional)
                            if svg_path:
                                renderer = QSvgRenderer(svg_path)
                                if renderer.isValid():
                                    # Create pixmap from SVG (40x40 size for mini cards)
                                    icon_size = 40
                                    pixmap = QtGui.QPixmap(icon_size, icon_size)
                                    pixmap.fill(QtCore.Qt.transparent)
                                    painter = QtGui.QPainter(pixmap)
                                    renderer.render(painter)
                                    painter.end()
                                    
                                    icon_lbl = QtWidgets.QLabel()
                                    icon_lbl.setPixmap(pixmap)
                                    icon_lbl.setAlignment(QtCore.Qt.AlignCenter)
                                    icon_lbl.setFixedSize(icon_size, icon_size)
                                    card_layout.addWidget(icon_lbl, alignment=QtCore.Qt.AlignCenter)
                                    icon_loaded = True
                    except Exception:
                        pass  # Fall back to text display
                
                # Entity name with exceptional styling
                name = entity_data.get("name", "Unknown")
                # Truncate long names
                if len(name) > 18:
                    display_name = name[:15] + "..."
                else:
                    display_name = name
                
                if is_exceptional:
                    name_style = "color: #ffd700; font-weight: bold; font-size: 10px;"
                    prefix = "‚≠ê " if not icon_loaded else ""
                else:
                    name_style = "color: #ccc; font-size: 10px;"
                    prefix = ""
                
                name_lbl = QtWidgets.QLabel(f"{prefix}{display_name}")
                name_lbl.setStyleSheet(name_style)
                name_lbl.setAlignment(QtCore.Qt.AlignCenter)
                name_lbl.setToolTip(entity_data.get("description", name))
                name_lbl.setWordWrap(True)
                card_layout.addWidget(name_lbl)
                
                # Bonus value
                bonus_val = entity_data.get("value", 0)
                bonus_lbl = QtWidgets.QLabel(f"<b>+{bonus_val}%</b> ‚ö°")
                bonus_lbl.setStyleSheet("color: #4caf50; font-size: 12px;")
                bonus_lbl.setAlignment(QtCore.Qt.AlignCenter)
                card_layout.addWidget(bonus_lbl)
                
                patrons_layout.addWidget(card)
            
            patrons_layout.addStretch()
            self.activity_entity_section.add_widget(patrons_container)
            
            # Add a tip
            tip_lbl = QtWidgets.QLabel("üí° Collect more entities in Entitidex to boost XP gains!")
            tip_lbl.setStyleSheet("color: #888; font-style: italic; font-size: 10px; padding-top: 4px;")
            self.activity_entity_section.add_widget(tip_lbl)
            
        except Exception as e:
            print(f"[Activity Tab] Error updating entity perk display: {e}")
            self.activity_entity_section.setVisible(False)


class SleepTab(QtWidgets.QWidget):
    """Sleep tracking tab with gamification rewards based on scientific recommendations."""
    
    def __init__(self, blocker: 'BlockerCore', parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.blocker = blocker
        self._reminder_timer = None
        self._build_ui()
        self._load_user_profile()  # Load saved profile for age-specific norms
        self._refresh_display()
        self._setup_reminder()
        self.destroyed.connect(self._cleanup_timer)
    
    def _cleanup_timer(self) -> None:
        """Stop the reminder timer when the widget is destroyed."""
        if self._reminder_timer is not None:
            self._reminder_timer.stop()
            self._reminder_timer = None
    
    def showEvent(self, event: QtGui.QShowEvent) -> None:
        """Update the Nighty-Night bonus preview when the tab is shown."""
        super().showEvent(event)
        # Refresh the time and expected reward tier each time tab is opened
        self._update_sleep_now_preview()
    
    def _build_ui(self) -> None:
        layout = QtWidgets.QVBoxLayout(self)
        layout.setSpacing(10)
        layout.setContentsMargins(15, 15, 15, 15)
        
        add_tab_help_button(layout, "sleep", self)
        
        # Header
        header_layout = QtWidgets.QHBoxLayout()
        header = QtWidgets.QLabel("üò¥ Sleep Tracker")
        header.setStyleSheet("font-size: 18px; font-weight: bold; color: #ffffff;")
        header_layout.addWidget(header)
        header_layout.addStretch()
        layout.addLayout(header_layout)
        
        # User Profile display for age-specific sleep norms
        profile_row = QtWidgets.QHBoxLayout()
        profile_row.addWidget(QtWidgets.QLabel("üë§ Profile:"))
        
        # Profile display label
        self.sleep_profile_display = QtWidgets.QLabel("")
        self.sleep_profile_display.setStyleSheet("color: #aaa; font-size: 11px;")
        profile_row.addWidget(self.sleep_profile_display)
        
        # Sleep targets info
        self.sleep_targets_label = QtWidgets.QLabel("")
        self.sleep_targets_label.setStyleSheet("color: #4caf50; font-weight: bold; font-size: 11px;")
        profile_row.addWidget(self.sleep_targets_label)
        
        # Edit profile button
        edit_profile_btn = QtWidgets.QPushButton("‚úèÔ∏è Edit")
        edit_profile_btn.setFixedWidth(60)
        edit_profile_btn.setToolTip("Edit birth date and gender for personalized sleep targets")
        edit_profile_btn.clicked.connect(self._edit_user_profile)
        profile_row.addWidget(edit_profile_btn)
        
        profile_row.addStretch()
        layout.addLayout(profile_row)
        
        # Main content split
        content_layout = QtWidgets.QHBoxLayout()
        
        # Left: Log sleep form
        left_panel = QtWidgets.QGroupBox("Log Sleep")
        left_layout = QtWidgets.QVBoxLayout(left_panel)
        
        # Date input (sleep date = night of)
        date_layout = QtWidgets.QHBoxLayout()
        date_layout.addWidget(QtWidgets.QLabel("Night of:"))
        self.date_edit = QtWidgets.QDateEdit()
        self.date_edit.setCalendarPopup(True)
        # Default to yesterday (logging last night's sleep)
        yesterday = QtCore.QDate.currentDate().addDays(-1)
        self.date_edit.setDate(yesterday)
        self.date_edit.setMaximumDate(QtCore.QDate.currentDate())
        date_layout.addWidget(self.date_edit)
        date_layout.addStretch()
        left_layout.addLayout(date_layout)
        
        # Bedtime
        bed_layout = QtWidgets.QHBoxLayout()
        bed_layout.addWidget(QtWidgets.QLabel("Bedtime:"))
        self.bedtime_edit = QtWidgets.QTimeEdit()
        self.bedtime_edit.setDisplayFormat("HH:mm")
        self.bedtime_edit.setWrapping(True)  # Allow wrapping past midnight
        self.bedtime_edit.setTime(QtCore.QTime(23, 0))
        self.bedtime_edit.timeChanged.connect(self._update_sleep_duration)
        bed_layout.addWidget(self.bedtime_edit)
        bed_hint = QtWidgets.QLabel("(wraps past midnight)")
        bed_hint.setStyleSheet("color: #888; font-size: 11px;")
        bed_layout.addWidget(bed_hint)
        bed_layout.addStretch()
        left_layout.addLayout(bed_layout)
        
        # Wake time
        wake_layout = QtWidgets.QHBoxLayout()
        wake_layout.addWidget(QtWidgets.QLabel("Wake time:"))
        self.wake_edit = QtWidgets.QTimeEdit()
        self.wake_edit.setDisplayFormat("HH:mm")
        self.wake_edit.setWrapping(True)  # Allow wrapping past midnight
        self.wake_edit.setTime(QtCore.QTime(7, 0))
        self.wake_edit.timeChanged.connect(self._update_sleep_duration)
        wake_layout.addWidget(self.wake_edit)
        wake_layout.addStretch()
        left_layout.addLayout(wake_layout)
        
        # Calculated sleep duration
        self.duration_label = QtWidgets.QLabel("üí§ Sleep duration: 8h 0m")
        self.duration_label.setStyleSheet("font-weight: bold; color: #4caf50;")
        left_layout.addWidget(self.duration_label)
        
        # Quality rating
        quality_layout = QtWidgets.QHBoxLayout()
        quality_layout.addWidget(QtWidgets.QLabel("Sleep quality:"))
        self.quality_combo = NoScrollComboBox()
        for quality_id, name, emoji, _ in SLEEP_QUALITY_FACTORS:
            self.quality_combo.addItem(f"{emoji} {name}", quality_id)
        self.quality_combo.setCurrentIndex(1)  # Good
        quality_layout.addWidget(self.quality_combo)
        left_layout.addLayout(quality_layout)
        
        # Disruptions (checkboxes)
        disruptions_group = QtWidgets.QGroupBox("Disruptions (optional)")
        disruptions_layout = QtWidgets.QGridLayout(disruptions_group)
        self.disruption_checks = {}
        for i, (tag_id, name, emoji, _) in enumerate(SLEEP_DISRUPTION_TAGS):
            if tag_id == "none":
                continue  # Skip "none" as it's the default
            cb = QtWidgets.QCheckBox(f"{emoji} {name}")
            cb.setProperty("tag_id", tag_id)
            self.disruption_checks[tag_id] = cb
            disruptions_layout.addWidget(cb, i // 2, i % 2)
        left_layout.addWidget(disruptions_group)
        
        # Note
        note_layout = QtWidgets.QHBoxLayout()
        note_layout.addWidget(QtWidgets.QLabel("Note:"))
        self.note_input = QtWidgets.QLineEdit()
        self.note_input.setPlaceholderText("Optional note (dreams, how you feel...)")
        self.note_input.setMaxLength(150)
        note_layout.addWidget(self.note_input)
        left_layout.addLayout(note_layout)
        
        # Screen-Off Bonus (Nighty-Night Gift)
        screenoff_group = QtWidgets.QGroupBox("üåô Nighty-Night Bonus")
        screenoff_main_layout = QtWidgets.QVBoxLayout(screenoff_group)
        
        # Go to Sleep NOW button - immediate reward
        sleep_now_layout = QtWidgets.QHBoxLayout()
        self.sleep_now_btn = QtWidgets.QPushButton("üõèÔ∏è Go to Sleep NOW!")
        self.sleep_now_btn.setToolTip(
            "Click when going to sleep right now to get an immediate reward!\n"
            "Rewards available 21:00 - 01:00."
        )
        self.sleep_now_btn.setStyleSheet("""
            QPushButton {
                background-color: #1565c0;
                color: white;
                font-size: 13px;
                font-weight: bold;
                padding: 8px 15px;
                border-radius: 5px;
            }
            QPushButton:hover { background-color: #1976d2; }
            QPushButton:disabled { background-color: #455a64; color: #888; }
        """)
        self.sleep_now_btn.clicked.connect(self._go_to_sleep_now)
        sleep_now_layout.addWidget(self.sleep_now_btn)
        self.sleep_now_info = QtWidgets.QLabel()
        self.sleep_now_info.setStyleSheet("color: #888; font-size: 11px;")
        self._update_sleep_now_preview()
        sleep_now_layout.addWidget(self.sleep_now_info)
        sleep_now_layout.addStretch()
        screenoff_main_layout.addLayout(sleep_now_layout)
        
        # Entity Perk Card (Owl Athena) - shows when scholar_002 is collected
        self.sleep_entity_perk_card = QtWidgets.QFrame()
        self.sleep_entity_perk_card.setStyleSheet("""
            QFrame {
                background-color: rgba(255, 255, 255, 0.04);
                border: 1px solid rgba(92, 107, 192, 0.3);
                border-radius: 8px;
            }
        """)
        entity_perk_layout = QtWidgets.QHBoxLayout(self.sleep_entity_perk_card)
        entity_perk_layout.setContentsMargins(8, 4, 8, 4)
        entity_perk_layout.setSpacing(10)
        
        # SVG icon container
        self.sleep_entity_svg_label = QtWidgets.QLabel()
        self.sleep_entity_svg_label.setFixedSize(40, 40)
        self.sleep_entity_svg_label.setStyleSheet("background: transparent;")
        entity_perk_layout.addWidget(self.sleep_entity_svg_label)
        
        # Perk description
        self.sleep_entity_perk_label = QtWidgets.QLabel()
        self.sleep_entity_perk_label.setStyleSheet("""
            font-size: 12px;
            font-weight: bold;
            color: #9fa8da;
            background: transparent;
        """)
        self.sleep_entity_perk_label.setWordWrap(True)
        entity_perk_layout.addWidget(self.sleep_entity_perk_label, 1)
        
        screenoff_main_layout.addWidget(self.sleep_entity_perk_card)
        self.sleep_entity_perk_card.hide()  # Hidden until we check perks
        
        # Update entity perk display
        self._update_sleep_entity_perk_display()
        
        # Separator
        sep_line = QtWidgets.QFrame()
        sep_line.setFrameShape(QtWidgets.QFrame.HLine)
        sep_line.setStyleSheet("color: #444;")
        screenoff_main_layout.addWidget(sep_line)
        
        # Existing screen-off time selector (for logging past sleep)
        screenoff_layout = QtWidgets.QHBoxLayout()
        self.screenoff_checkbox = QtWidgets.QCheckBox("I turned off my screen at:")
        self.screenoff_checkbox.setToolTip("Earn a bonus item for healthy digital habits!\nRewards available 21:00 - 01:00.")
        screenoff_layout.addWidget(self.screenoff_checkbox)
        self.screenoff_time = QtWidgets.QTimeEdit()
        self.screenoff_time.setDisplayFormat("HH:mm")
        self.screenoff_time.setTime(QtCore.QTime(21, 0))
        self.screenoff_time.setEnabled(False)
        self.screenoff_checkbox.stateChanged.connect(
            lambda state: self.screenoff_time.setEnabled(state == QtCore.Qt.CheckState.Checked.value)
        )
        screenoff_layout.addWidget(self.screenoff_time)
        screenoff_layout.addStretch()
        screenoff_main_layout.addLayout(screenoff_layout)
        left_layout.addWidget(screenoff_group)
        
        # Log button
        self.log_btn = QtWidgets.QPushButton("üåô Log Sleep")
        self.log_btn.setStyleSheet("""
            QPushButton {
                background-color: #673ab7;
                color: white;
                font-size: 14px;
                font-weight: bold;
                padding: 10px;
                border-radius: 5px;
            }
            QPushButton:hover { background-color: #7c4dff; }
        """)
        self.log_btn.clicked.connect(self._log_sleep)
        left_layout.addWidget(self.log_btn)
        
        # Quick presets
        presets_label = QtWidgets.QLabel("Quick Presets:")
        presets_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        left_layout.addWidget(presets_label)
        
        presets_layout = QtWidgets.QGridLayout()
        presets = [
            ("üåô Early (21:00-5:00)", "21:00", "05:00"),
            ("üò¥ Standard (23:00-7:00)", "23:00", "07:00"),
            ("ü¶â Night Owl (01:00-9:00)", "01:00", "09:00"),
            ("üåÉ Late Night (02:00-10:00)", "02:00", "10:00"),
        ]
        for i, (label, bed, wake) in enumerate(presets):
            btn = QtWidgets.QPushButton(label)
            btn.setStyleSheet("padding: 5px;")
            btn.clicked.connect(lambda _, b=bed, w=wake: self._apply_preset(b, w))
            presets_layout.addWidget(btn, i // 2, i % 2)
        left_layout.addLayout(presets_layout)
        
        left_layout.addStretch()
        content_layout.addWidget(left_panel)
        
        # Right: Stats, recommendations, and history
        right_panel = QtWidgets.QGroupBox("Stats & Recommendations")
        right_layout = QtWidgets.QVBoxLayout(right_panel)
        
        # Chronotype selector
        chrono_layout = QtWidgets.QHBoxLayout()
        chrono_layout.addWidget(QtWidgets.QLabel("Your chronotype:"))
        self.chronotype_combo = NoScrollComboBox()
        for chrono_id, name, emoji, _, _, desc in SLEEP_CHRONOTYPES:
            self.chronotype_combo.addItem(f"{emoji} {name}", chrono_id)
            self.chronotype_combo.setItemData(
                self.chronotype_combo.count() - 1, desc, QtCore.Qt.ToolTipRole
            )
        # Set current chronotype
        for i in range(self.chronotype_combo.count()):
            if self.chronotype_combo.itemData(i) == self.blocker.sleep_chronotype:
                self.chronotype_combo.setCurrentIndex(i)
                break
        self.chronotype_combo.currentIndexChanged.connect(self._on_chronotype_change)
        chrono_layout.addWidget(self.chronotype_combo)
        right_layout.addLayout(chrono_layout)
        
        # Recommendations display
        self.recommendations_label = QtWidgets.QLabel()
        self.recommendations_label.setWordWrap(True)
        self.recommendations_label.setStyleSheet("background-color: #1e1e2e; padding: 10px; border-radius: 5px;")
        right_layout.addWidget(self.recommendations_label)
        self._update_recommendations()
        
        # Stats display
        self.stats_label = QtWidgets.QLabel()
        self.stats_label.setWordWrap(True)
        self.stats_label.setStyleSheet("background-color: #1e1e2e; padding: 10px; border-radius: 5px;")
        right_layout.addWidget(self.stats_label)
        
        # History list
        history_label = QtWidgets.QLabel("üìã Recent Sleep History:")
        history_label.setStyleSheet("font-weight: bold;")
        right_layout.addWidget(history_label)
        
        self.history_list = QtWidgets.QListWidget()
        self.history_list.setMaximumHeight(200)
        self.history_list.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.history_list.customContextMenuRequested.connect(self._show_context_menu)
        right_layout.addWidget(self.history_list)
        
        # Reminder settings
        reminder_box = QtWidgets.QGroupBox("‚è∞ Bedtime Reminder")
        reminder_layout = QtWidgets.QHBoxLayout(reminder_box)
        self.reminder_checkbox = QtWidgets.QCheckBox("Enable reminder")
        self.reminder_checkbox.setChecked(self.blocker.sleep_reminder_enabled)
        self.reminder_checkbox.stateChanged.connect(self._update_reminder_setting)
        reminder_layout.addWidget(self.reminder_checkbox)
        reminder_layout.addWidget(QtWidgets.QLabel("at"))
        self.reminder_time = QtWidgets.QTimeEdit()
        self.reminder_time.setDisplayFormat("HH:mm")
        try:
            h, m = self.blocker.sleep_reminder_time.split(":")
            self.reminder_time.setTime(QtCore.QTime(int(h), int(m)))
        except (ValueError, AttributeError):
            self.reminder_time.setTime(QtCore.QTime(21, 0))
        self.reminder_time.timeChanged.connect(self._update_reminder_setting)
        reminder_layout.addWidget(self.reminder_time)
        reminder_layout.addStretch()
        right_layout.addWidget(reminder_box)
        
        right_layout.addStretch()
        content_layout.addWidget(right_panel)
        
        layout.addLayout(content_layout)
        
        # Rewards info section
        rewards_group = QtWidgets.QGroupBox("üéÅ Rewards Info")
        rewards_layout = QtWidgets.QVBoxLayout(rewards_group)
        rewards_info = QtWidgets.QLabel(
            "<b>How it works:</b> Log sleep to earn 1 item. Rarity based on your sleep score (0-100).<br>"
            "<i>Score = duration (40%) + bedtime alignment (25%) + quality (25%) + consistency (10%)</i><br>"
            "<table style='font-size:10px; color:#888888; margin-top:5px;'>"
            "<tr><th>Score</th><th>Common</th><th>Uncommon</th><th>Rare</th><th>Epic</th><th>Legendary</th></tr>"
            "<tr><td>&lt;50</td><td colspan='5' style='text-align:center'>No reward</td></tr>"
            "<tr><td>50+</td><td>25%</td><td>50%</td><td>20%</td><td>5%</td><td>-</td></tr>"
            "<tr><td>65+</td><td>5%</td><td>20%</td><td>50%</td><td>20%</td><td>5%</td></tr>"
            "<tr><td>80+</td><td>-</td><td>5%</td><td>20%</td><td>50%</td><td>25%</td></tr>"
            "<tr><td>90+</td><td>-</td><td>-</td><td>5%</td><td>20%</td><td>75%</td></tr>"
            "<tr><td>97+</td><td>-</td><td>-</td><td>-</td><td>-</td><td>100%</td></tr>"
            "</table>"
            "<br><b>üõèÔ∏è Go to Sleep NOW:</b> Immediate reward for going to sleep! (1x per night)<br>"
            "<b>üåô Nighty-Night Bonus:</b> Extra item when logging past sleep with screen-off time.<br>"
            "<table style='font-size:10px; color:#888888; margin-top:3px;'>"
            "<tr><th>Time</th><th>Common</th><th>Uncommon</th><th>Rare</th><th>Epic</th><th>Legendary</th></tr>"
            "<tr><td>21:00-21:30</td><td>-</td><td>-</td><td>-</td><td>-</td><td>100%</td></tr>"
            "<tr><td>21:30-22:30</td><td>-</td><td>-</td><td>5%</td><td>20%</td><td>75%</td></tr>"
            "<tr><td>22:30-23:30</td><td>-</td><td>-</td><td>5%</td><td>50%</td><td>45%</td></tr>"
            "<tr><td>23:30-00:30</td><td>-</td><td>5%</td><td>50%</td><td>25%</td><td>20%</td></tr>"
            "<tr><td>00:30-01:00</td><td>5%</td><td>50%</td><td>25%</td><td>15%</td><td>5%</td></tr>"
            "<tr><td>01:00+</td><td colspan='5' style='text-align:center'>No bonus</td></tr>"
            "</table>"
            "<br><b>Streaks:</b> 3n=Uncommon, 7n=Rare, 14n=Epic, 30n=Legendary (consecutive nights with 7+ hrs)"
        )
        rewards_info.setWordWrap(True)
        rewards_info.setStyleSheet("color: #888888; font-size: 10px;")
        rewards_layout.addWidget(rewards_info)
        layout.addWidget(rewards_group)
        
        self._update_sleep_duration()
    
    def _update_sleep_duration(self) -> None:
        """Update the calculated sleep duration display."""
        bedtime = self.bedtime_edit.time()
        wake_time = self.wake_edit.time()
        
        bed_mins = bedtime.hour() * 60 + bedtime.minute()
        wake_mins = wake_time.hour() * 60 + wake_time.minute()
        
        # Handle overnight sleep
        if wake_mins <= bed_mins:
            duration_mins = (24 * 60 - bed_mins) + wake_mins
        else:
            duration_mins = wake_mins - bed_mins
        
        hours = duration_mins // 60
        mins = duration_mins % 60
        total_hours = hours + mins / 60
        
        # Get age-specific targets
        age = self._get_user_age()
        min_target, max_target = 7, 9  # Default adult targets
        try:
            from gamification import get_sleep_targets_for_age
            if age is not None:
                targets = get_sleep_targets_for_age(age)
                if targets:
                    min_target = targets["min_hours"]
                    max_target = targets["max_hours"]
        except (ImportError, Exception):
            pass
        
        # Color based on duration relative to age-specific targets
        if min_target <= total_hours <= max_target:
            color = "#4caf50"  # Green - optimal
            emoji = "üåü"
        elif min_target - 1 <= total_hours < min_target:
            color = "#ff9800"  # Orange - slightly low
            emoji = "‚ö†Ô∏è"
        elif total_hours > max_target:
            color = "#2196f3"  # Blue - long
            emoji = "üí§"
        else:
            color = "#f44336"  # Red - too short
            emoji = "üò¥"
        
        self.duration_label.setText(f"{emoji} Sleep duration: {hours}h {mins}m")
        self.duration_label.setStyleSheet(f"font-weight: bold; color: {color};")
    
    def _apply_preset(self, bedtime: str, wake_time: str) -> None:
        """Apply a quick preset."""
        try:
            h, m = bedtime.split(":")
            self.bedtime_edit.setTime(QtCore.QTime(int(h), int(m)))
            h, m = wake_time.split(":")
            self.wake_edit.setTime(QtCore.QTime(int(h), int(m)))
        except (ValueError, AttributeError):
            pass  # Invalid preset format, ignore
    
    def _edit_user_profile(self) -> None:
        """Open the user profile dialog to edit birth date and gender."""
        dialog = UserProfileDialog(self.blocker, self, is_first_run=False)
        if dialog.exec() == QtWidgets.QDialog.Accepted:
            self._update_profile_display()
            self._update_sleep_duration()  # Refresh color coding
    
    def _update_profile_display(self) -> None:
        """Update the profile display with current values."""
        age = self._get_user_age()
        gender = self.blocker.user_gender or "?"
        
        if age is not None:
            self.sleep_profile_display.setText(f"Age: {age}, Sex: {gender}")
            self._update_sleep_targets_display(age)
        elif self.blocker.user_birth_year:
            self.sleep_profile_display.setText(f"Born: {self.blocker.user_birth_year}")
            self.sleep_targets_label.setText("Target: 7-9h (adult default)")
        else:
            self.sleep_profile_display.setText("Not set")
            self.sleep_targets_label.setText("Target: 7-9h (adult default)")
    
    def _get_user_age(self) -> Optional[int]:
        """Calculate user's current age from saved birth date."""
        if not self.blocker.user_birth_year or not self.blocker.user_birth_month:
            return None
        try:
            from gamification import calculate_age_from_birth
            return calculate_age_from_birth(
                self.blocker.user_birth_year,
                self.blocker.user_birth_month
            )
        except (ImportError, Exception):
            return None
    
    def _update_sleep_targets_display(self, age: int) -> None:
        """Update the sleep targets label based on age."""
        try:
            from gamification import get_sleep_targets_for_age
            targets = get_sleep_targets_for_age(age)
            if targets:
                min_h = targets["min_hours"]
                opt_h = targets["optimal_hours"]
                max_h = targets["max_hours"]
                self.sleep_targets_label.setText(
                    f"Target: {min_h}-{max_h}h (optimal: {opt_h}h)"
                )
        except (ImportError, Exception):
            pass
    
    def _load_user_profile(self) -> None:
        """Load and display user profile."""
        self._update_profile_display()
    
    def _on_chronotype_change(self) -> None:
        """Handle chronotype selection change."""
        chrono_id = self.chronotype_combo.currentData()
        if chrono_id:
            self.blocker.sleep_chronotype = chrono_id
            self.blocker.save_config()
            self._update_recommendations()
    
    def _update_recommendations(self) -> None:
        """Update the recommendations display based on chronotype."""
        if not get_sleep_recommendation:
            self.recommendations_label.setText("Sleep recommendations unavailable.")
            return
        
        rec = get_sleep_recommendation(self.blocker.sleep_chronotype)
        tips_html = "<br>".join(rec["tips"])
        
        self.recommendations_label.setText(
            f"<b>{rec['emoji']} {rec['chronotype']}</b><br><br>"
            f"üõèÔ∏è Optimal bedtime: {rec['optimal_bedtime']}<br>"
            f"‚òÄÔ∏è Recommended wake: {rec['recommended_wake']}<br>"
            f"‚è∞ Target: {rec['target_hours']}<br><br>"
            f"<b>Tips:</b><br>{tips_html}"
        )
    
    def _update_sleep_now_preview(self) -> None:
        """Update the 'Go to Sleep NOW' preview showing expected reward tier."""
        now = QtCore.QTime.currentTime()
        current_time = now.toString("HH:mm")
        
        if not get_screen_off_bonus_rarity:
            self.sleep_now_info.setText(f"Now: {current_time}")
            return
        
        base_rarity = get_screen_off_bonus_rarity(current_time)
        if base_rarity:
            # Apply entity perk tier bonus for preview
            from gamification import get_entity_sleep_perks, get_boosted_rarity
            sleep_perks = get_entity_sleep_perks(self.blocker.adhd_buster)
            tier_bonus = sleep_perks.get("sleep_tier_bonus", 0)
            
            rarity = base_rarity
            for _ in range(tier_bonus):
                rarity = get_boosted_rarity(rarity)
            
            rarity_colors = {
                "Legendary": "#ffd700",
                "Epic": "#a335ee",
                "Rare": "#0070dd",
                "Uncommon": "#1eff00",
                "Common": "#ffffff",
            }
            color = rarity_colors.get(rarity, "#888")
            
            # Show bonus indicator if tier is boosted
            bonus_text = f" (+{tier_bonus}ü¶â)" if tier_bonus > 0 else ""
            self.sleep_now_info.setText(f"Now: {current_time} ‚Üí <b style='color:{color}'>{rarity}</b>{bonus_text} item!")
            self.sleep_now_btn.setEnabled(True)
        else:
            # Check if it is too early (between 06:00 and 21:00)
            if QtCore.QTime(6, 0) <= now < QtCore.QTime(21, 0):
                msg = "(starts at 21:00)"
            else:
                msg = "(too late for bonus)"
            self.sleep_now_info.setText(f"Now: {current_time} {msg}")
            self.sleep_now_btn.setEnabled(False)
    
    def _update_sleep_entity_perk_display(self) -> None:
        """Update the entity perk display card if Study Owl Athena is collected."""
        try:
            adhd_data = getattr(self.blocker, 'adhd_buster', {})
            if not adhd_data:
                self.sleep_entity_perk_card.hide()
                return
            
            from gamification import get_entity_sleep_perks
            sleep_perks = get_entity_sleep_perks(adhd_data)
            tier_bonus = sleep_perks.get("sleep_tier_bonus", 0)
            
            # Hide if no tier bonus
            if tier_bonus <= 0:
                self.sleep_entity_perk_card.hide()
                return
            
            # Show the perk card
            entity_name = sleep_perks.get("entity_name", "Study Owl Athena")
            is_exceptional = sleep_perks.get("is_exceptional", False)
            description = sleep_perks.get("description", f"+{tier_bonus} Sleep Tier")
            
            perk_text = (
                f"<b>ü¶â {entity_name}</b><br>"
                f"<span style='color:#9fa8da;'>{description}</span>"
            )
            self.sleep_entity_perk_label.setText(perk_text)
            
            # Load and display SVG
            self._load_sleep_entity_svg(is_exceptional)
            
            # Update border color for exceptional
            if is_exceptional:
                self.sleep_entity_perk_card.setStyleSheet("""
                    QFrame {
                        background-color: rgba(255, 255, 255, 0.04);
                        border: 1px solid rgba(186, 104, 200, 0.3);
                        border-radius: 8px;
                    }
                """)
            else:
                self.sleep_entity_perk_card.setStyleSheet("""
                    QFrame {
                        background-color: rgba(255, 255, 255, 0.04);
                        border: 1px solid rgba(92, 107, 192, 0.3);
                        border-radius: 8px;
                    }
                """)
            
            self.sleep_entity_perk_card.show()
            
        except Exception as e:
            print(f"[Sleep Tab] Error updating entity perk display: {e}")
            self.sleep_entity_perk_card.hide()
    
    def _load_sleep_entity_svg(self, is_exceptional: bool) -> None:
        """Load and display the owl entity SVG icon."""
        try:
            from PySide6.QtSvg import QSvgRenderer
            from entitidex_tab import _resolve_entity_svg_path
            from entitidex.entity_pools import get_entity_by_id
            
            entity = get_entity_by_id("scholar_002")
            if not entity:
                return
            
            svg_path = _resolve_entity_svg_path(entity, is_exceptional)
            if not svg_path:
                return
            
            renderer = QSvgRenderer(svg_path)
            if renderer.isValid():
                icon_size = 40
                pixmap = QtGui.QPixmap(icon_size, icon_size)
                pixmap.fill(QtCore.Qt.transparent)
                painter = QtGui.QPainter(pixmap)
                renderer.render(painter)
                painter.end()
                self.sleep_entity_svg_label.setPixmap(pixmap)
                
        except Exception as e:
            print(f"[Sleep Tab] Error loading entity SVG: {e}")

    def _go_to_sleep_now(self) -> None:
        """Handle 'Go to Sleep NOW' button - give immediate reward based on current time."""
        if not GAMIFICATION_AVAILABLE or not is_gamification_enabled(self.blocker.adhd_buster):
            show_info(
                self, "Gamification Disabled",
                "Enable gamification mode to earn rewards!"
            )
            return
        
        if not get_screen_off_bonus_rarity:
            show_warning(
                self, "Feature Unavailable",
                "Sleep tracking module not fully loaded."
            )
            return
        
        # Get current time and calculate reward
        now = QtCore.QTime.currentTime()
        current_time = now.toString("HH:mm")
        base_rarity = get_screen_off_bonus_rarity(current_time)
        
        if not base_rarity:
            show_info(
                self, "Bonus Window Missed",
                "It's outside the Nighty-Night bonus window.\n"
                "Sleep between 21:00 and 01:00 to earn rewards!\n\n"
                "Rewards:\n"
                "‚Ä¢ 21:00 - 21:30: Legendary (Best!)\n"
                "‚Ä¢ 21:30 - 22:30: Legendary/Epic\n"
                "‚Ä¢ 22:30 - 23:30: Epic/Rare\n"
                "‚Ä¢ 23:30 - 00:30: Rare/Uncommon\n"
                "‚Ä¢ 00:30 - 01:00: Uncommon"
            )
            return
        
        # Apply entity perk tier bonus (Study Owl Athena)
        from gamification import get_entity_sleep_perks, get_boosted_rarity
        sleep_perks = get_entity_sleep_perks(self.blocker.adhd_buster)
        tier_bonus = sleep_perks.get("sleep_tier_bonus", 0)
        
        # Boost rarity by tier_bonus levels (capped at Legendary)
        rarity = base_rarity
        for _ in range(tier_bonus):
            rarity = get_boosted_rarity(rarity)
        
        # Check if already used today (based on sleep-now timestamp)
        today = datetime.now().strftime("%Y-%m-%d")
        last_sleep_now = self.blocker.adhd_buster.get("last_sleep_now_date", "")
        if last_sleep_now == today:
            show_info(
                self, "Already Used",
                "You already claimed your Nighty-Night bonus today!\n"
                "Come back tomorrow for another reward."
            )
            return
        
        # Confirmation dialog before claiming bonus
        rarity_emojis = {
            "Legendary": "üåü‚ú®",
            "Epic": "üíé",
            "Rare": "üíô",
            "Uncommon": "üíö",
            "Common": "‚ö™",
        }
        emoji = rarity_emojis.get(rarity, "üéÅ")
        
        # Build bonus info for confirmation
        bonus_info = ""
        if tier_bonus > 0:
            bonus_info = f"\n\nü¶â <i>{sleep_perks.get('entity_name', 'Owl')} boosts your reward by +{tier_bonus} tier!</i>"
        
        reply = show_question(
            self, "üåô Claim Nighty-Night Bonus?",
            f"{emoji} <b>Ready for bed?</b>\n\n"
            f"Claiming your Nighty-Night bonus at {current_time}\n"
            f"will earn you a <b>{rarity}</b> reward!{bonus_info}\n\n"
            f"Are you ready to turn off the screen and sleep?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        )
        
        if reply != QtWidgets.QMessageBox.Yes:
            return
        
        # Generate reward
        active_story = self.blocker.adhd_buster.get("active_story", "warrior")
        item = generate_item(rarity=rarity, story_id=active_story)
        
        # Add source and validate item has all required fields
        item["source"] = "sleep_now_bonus"
        if "obtained_at" not in item:
            item["obtained_at"] = datetime.now().isoformat()
        
        # Update last claim date
        self.blocker.adhd_buster["last_sleep_now_date"] = today
        
        # Use GameState manager for reactive updates if available
        main_window = self.window()
        game_state = getattr(main_window, 'game_state', None)
        if not game_state:
            logger.error("GameStateManager not available - cannot award sleep now bonus")
            return
        
        # Capture equipped state before award
        equipped_before = dict(self.blocker.adhd_buster.get("equipped", {}))
        
        # Use batch award - handles inventory, auto-equip, save, and signals
        award_result = game_state.award_items_batch([item], coins=0, auto_equip=True, source="sleep_now_bonus")
        
        # Get the slots that were actually auto-equipped
        equipped_after = game_state.adhd_buster.get("equipped", {})
        auto_equipped_slots = [i.get("slot") for i in award_result.get("equipped", []) if i.get("slot")]
        
        # Show reward with ItemRewardDialog for comparison
        from styled_dialog import ItemRewardDialog
        dialog = ItemRewardDialog(
            parent=self,
            title="üõèÔ∏è Sweet Dreams!",
            header_emoji="üõèÔ∏è",
            source_label=f"Nighty-Night Bonus at {current_time}",
            items_earned=[item],
            equipped=equipped_before,  # What was equipped before for comparison
            equipped_after=equipped_after,  # Current equipped state
            auto_equipped_slots=auto_equipped_slots,  # Slots that were actually auto-equipped
            game_state=game_state,  # For click-to-equip
            extra_messages=["Now turn off that screen and get some rest! üò¥"]
        )
        dialog.exec()
        
        # Update preview to show it's been used
        self.sleep_now_btn.setEnabled(False)
        self.sleep_now_info.setText(f"‚úì Claimed at {current_time}! Sweet dreams!")
        
        # Refresh Hero tab inventory if available
        if hasattr(self.parent(), 'adhd_tab') and self.parent().adhd_tab:
            self.parent().adhd_tab.refresh_all()

    def _log_sleep(self) -> None:
        """Log a sleep entry and check for rewards."""
        date_str = self.date_edit.date().toString("yyyy-MM-dd")
        bedtime = self.bedtime_edit.time().toString("HH:mm")
        wake_time = self.wake_edit.time().toString("HH:mm")
        quality_id = self.quality_combo.currentData()
        note = self.note_input.text().strip()
        
        # Calculate sleep hours
        bed_mins = self.bedtime_edit.time().hour() * 60 + self.bedtime_edit.time().minute()
        wake_mins = self.wake_edit.time().hour() * 60 + self.wake_edit.time().minute()
        if wake_mins <= bed_mins:
            duration_mins = (24 * 60 - bed_mins) + wake_mins
        else:
            duration_mins = wake_mins - bed_mins
        sleep_hours = duration_mins / 60
        
        # Get disruptions
        disruptions = [tag_id for tag_id, cb in self.disruption_checks.items() if cb.isChecked()]
        if not disruptions:
            disruptions = ["none"]
        
        # Check for existing entry on this date
        existing_idx = -1
        for i, entry in enumerate(self.blocker.sleep_entries):
            if entry.get("date") == date_str:
                existing_idx = i
                break
        
        # Get rewards (skip if gamification mode is disabled)
        entries_for_reward = [e for e in self.blocker.sleep_entries if e.get("date") != date_str]
        reward_info = None
        if check_all_sleep_rewards and GAMIFICATION_AVAILABLE and is_gamification_enabled(self.blocker.adhd_buster):
            active_story = self.blocker.adhd_buster.get("active_story", "warrior")
            user_age = self._get_user_age()  # Get age for age-specific scoring
            reward_info = check_all_sleep_rewards(
                entries_for_reward,
                sleep_hours,
                bedtime,
                wake_time,
                quality_id,
                disruptions,
                date_str,
                self.blocker.sleep_milestones,
                self.blocker.sleep_chronotype,
                story_id=active_story,
                age=user_age,
            )
        
        # Create new entry
        new_entry = {
            "date": date_str,
            "sleep_hours": round(sleep_hours, 2),
            "bedtime": bedtime,
            "wake_time": wake_time,
            "quality": quality_id,
            "disruptions": disruptions,
            "score": reward_info.get("score", 0) if reward_info else 0,
            "note": note,
        }
        
        # Handle existing entry
        if existing_idx >= 0:
            reply = show_question(
                self, "Entry Exists",
                f"You already have a sleep entry for {date_str}.\nReplace it?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
            )
            if reply != QtWidgets.QMessageBox.Yes:
                return
            self.blocker.sleep_entries[existing_idx] = new_entry
        else:
            self.blocker.sleep_entries.append(new_entry)
            self.blocker.sleep_entries.sort(key=lambda x: x.get("date", ""), reverse=True)
            # Prune to last 365 entries to prevent unbounded growth
            if len(self.blocker.sleep_entries) > 365:
                self.blocker.sleep_entries = self.blocker.sleep_entries[:365]
        
        # Track screen-off bonus outside the reward block
        screenoff_bonus_item = None
        items_earned = []
        equipped_before = {}  # Capture equipped state before awarding
        
        # Handle rewards
        if reward_info and GAMIFICATION_AVAILABLE:
            # Capture equipped items BEFORE awarding to show comparison
            adhd_buster = self.blocker.adhd_buster
            equipped = adhd_buster.get("equipped", {})
            for slot, item in equipped.items():
                if item:
                    equipped_before[slot] = item.copy() if isinstance(item, dict) else item
            
            # Base reward - collect items, add to inventory via game_state below
            if reward_info.get("reward"):
                item = reward_info["reward"]
                items_earned.append(item)
            
            # Streak reward
            if reward_info.get("streak_reward"):
                streak_item = reward_info["streak_reward"]["item"]
                items_earned.append(streak_item)
                self.blocker.sleep_milestones.append(reward_info["streak_reward"]["milestone_id"])
            
            # Milestone rewards
            new_milestone_ids = []
            for milestone in reward_info.get("new_milestones", []):
                items_earned.append(milestone["item"])
                new_milestone_ids.append(milestone["milestone_id"])
            
            if new_milestone_ids:
                self.blocker.sleep_milestones.extend(new_milestone_ids)
            
            # Screen-Off (Nighty-Night) bonus reward
            screenoff_bonus_item = None
            if self.screenoff_checkbox.isChecked() and get_screen_off_bonus_rarity:
                screenoff_time = self.screenoff_time.time().toString("HH:mm")
                screenoff_rarity = get_screen_off_bonus_rarity(screenoff_time)
                if screenoff_rarity:
                    active_story = self.blocker.adhd_buster.get("active_story", "warrior")
                    screenoff_bonus_item = generate_item(rarity=screenoff_rarity, story_id=active_story)
                    screenoff_bonus_item["source"] = "nighty_night_bonus"
                    if "obtained_at" not in screenoff_bonus_item:
                        screenoff_bonus_item["obtained_at"] = datetime.now().isoformat()
                    items_earned.append(screenoff_bonus_item)
            
            # Award all items via GameState
            auto_equipped_slots = []
            equipped_after = {}
            if items_earned:
                main_window = self.window()
                game_state = getattr(main_window, 'game_state', None)
                if not game_state:
                    logger.error("GameStateManager not available - cannot award sleep rewards")
                else:
                    # Use batch award - handles inventory, auto-equip, save, and signals
                    award_result = game_state.award_items_batch(items_earned, coins=0, auto_equip=True, source="sleep_tracking")
                    # Get the slots that were actually auto-equipped
                    equipped_after = game_state.adhd_buster.get("equipped", {})
                    auto_equipped_slots = [i.get("slot") for i in award_result.get("equipped", []) if i.get("slot")]
            
            # Sync hero data
            if GAMIFICATION_AVAILABLE:
                sync_hero_data(self.blocker.adhd_buster)
        
        self.blocker.save_config()
        
        # Update main timeline widget if parent window has it
        if self.parent() and hasattr(self.parent(), 'timeline_widget'):
            try:
                self.parent().timeline_widget.update_data()
            except Exception:
                pass
        
        # Show feedback
        score = new_entry.get("score", 0)
        base_msg = f"üåô Sleep logged for {date_str}\n\n"
        base_msg += f"Duration: {format_sleep_duration(sleep_hours) if format_sleep_duration else f'{sleep_hours:.1f}h'}\n"
        base_msg += f"Score: {score}/100\n"
        
        if reward_info:
            for m in reward_info.get("messages", [])[:5]:  # Limit messages
                base_msg += f"\n{m}"
        
        # Show feedback using ItemRewardDialog if items were earned
        if items_earned:
            # Get game state for equip functionality
            main_window = self.window()
            game_state = getattr(main_window, 'game_state', None)
            
            # Show lottery animation for the primary item (most exciting)
            # Pick the highest rarity item as the primary
            rarity_order = ["Common", "Uncommon", "Rare", "Epic", "Legendary"]
            primary_item = max(items_earned, key=lambda x: rarity_order.index(x.get("rarity", "Common")))
            extra_items = [i for i in items_earned if i is not primary_item]
            
            # Show lottery animation first
            from lottery_animation import SleepLotteryDialog
            lottery_dialog = SleepLotteryDialog(
                item=primary_item,
                reward_source="Sleep Logged!",
                extra_items=extra_items,
                parent=self.window()
            )
            lottery_dialog.exec()
            lottery_dialog.hide()  # Explicitly hide before deletion
            lottery_dialog.deleteLater()
            
            from styled_dialog import ItemRewardDialog
            dialog = ItemRewardDialog(
                parent=self,
                title="üò¥ Sleep Logged!",
                source_label=base_msg.replace("\n", "<br>"),
                items_earned=items_earned,
                equipped=equipped_before,  # What was equipped before for comparison
                equipped_after=equipped_after,  # Current equipped state
                auto_equipped_slots=auto_equipped_slots,  # Slots that were actually auto-equipped
                game_state=game_state  # For click-to-equip
            )
            dialog.exec()
            dialog.hide()  # Explicitly hide before deletion
            dialog.deleteLater()
        else:
            # No items earned - use basic styled info dialog
            from styled_dialog import styled_info
            styled_info(self, "üò¥ Sleep Logged!", base_msg)
        
        # Clear form
        self.note_input.clear()
        for cb in self.disruption_checks.values():
            cb.setChecked(False)
        self.screenoff_checkbox.setChecked(False)
        
        self._refresh_display()
    
    def _refresh_display(self) -> None:
        """Refresh stats, history display, and user-specific prefill values (called when switching users)."""
        # Update profile display with current user's data
        self._update_profile_display()
        
        # Prefill bedtime/wake time from user's last sleep entry
        entries = self.blocker.sleep_entries
        if entries:
            # Sort by date to get most recent entry
            sorted_entries = sorted(entries, key=lambda x: x.get("date", ""), reverse=True)
            last_entry = sorted_entries[0]
            
            # Prefill bedtime
            bedtime_str = last_entry.get("bedtime", "23:00")
            try:
                if bedtime_str:
                    h, m = map(int, bedtime_str.split(":"))
                    self.bedtime_edit.setTime(QtCore.QTime(h, m))
            except (ValueError, AttributeError):
                pass
            
            # Prefill wake time (estimate from bedtime + duration if no wake_time stored)
            waketime_str = last_entry.get("wake_time", None)
            if waketime_str:
                try:
                    h, m = map(int, waketime_str.split(":"))
                    self.wake_edit.setTime(QtCore.QTime(h, m))
                except (ValueError, AttributeError):
                    pass
            else:
                # Estimate from duration
                sleep_hours = last_entry.get("sleep_hours", 8.0)
                bedtime = self.bedtime_edit.time()
                wake_mins = (bedtime.hour() * 60 + bedtime.minute() + int(sleep_hours * 60)) % (24 * 60)
                self.wake_edit.setTime(QtCore.QTime(wake_mins // 60, wake_mins % 60))
            
            # Update duration display
            self._update_sleep_duration()
        
        # Update stats
        if get_sleep_stats:
            stats = get_sleep_stats(self.blocker.sleep_entries)
            streak = stats.get("current_streak", 0)
            streak_emoji = "üî•" if streak >= 3 else "üìä"
            
            self.stats_label.setText(
                f"<b>üìä Your Sleep Stats</b><br><br>"
                f"üåô Total nights tracked: {stats.get('total_nights', 0)}<br>"
                f"‚è∞ Average sleep: {stats.get('avg_hours', 0):.1f}h<br>"
                f"üìà This week average: {stats.get('this_week_avg', 0):.1f}h<br>"
                f"üèÜ Best score: {stats.get('best_score', 0):.0f}/100<br>"
                f"‚úÖ Nights on target (7+h): {stats.get('nights_on_target', 0)} "
                f"({stats.get('target_rate', 0):.0f}%)<br>"
                f"{streak_emoji} Current streak: {streak} nights"
            )
        else:
            entries = self.blocker.sleep_entries
            self.stats_label.setText(f"üìä {len(entries)} sleep entries logged")
        
        # Update history
        self.history_list.clear()
        for entry in self.blocker.sleep_entries[:20]:  # Last 20 entries
            date = entry.get("date", "Unknown")
            hours = entry.get("sleep_hours", 0)
            score = entry.get("score", 0)
            quality = entry.get("quality", "unknown")
            
            # Find quality emoji
            quality_emoji = "üò¥"
            for q_id, _, emoji, _ in SLEEP_QUALITY_FACTORS:
                if q_id == quality:
                    quality_emoji = emoji
                    break
            
            # Score color
            if score >= 80:
                score_color = "üü¢"
            elif score >= 60:
                score_color = "üü°"
            else:
                score_color = "üî¥"
            
            text = f"{date}: {hours:.1f}h {quality_emoji} {score_color} {score}pts"
            if entry.get("note"):
                text += f" üìù"
            
            item = QtWidgets.QListWidgetItem(text)
            item.setData(QtCore.Qt.UserRole, entry)
            self.history_list.addItem(item)
    
    def _show_context_menu(self, pos: QtCore.QPoint) -> None:
        """Show context menu for history items."""
        item = self.history_list.itemAt(pos)
        if not item:
            return
        
        entry_index = self.history_list.row(item)
        menu = QtWidgets.QMenu(self)
        
        view_action = menu.addAction("üìã View Details")
        delete_action = menu.addAction("üóëÔ∏è Delete Entry")
        
        action = menu.exec(self.history_list.mapToGlobal(pos))
        
        if action == view_action:
            self._view_entry_details(entry_index)
        elif action == delete_action:
            self._delete_entry(entry_index)
    
    def _view_entry_details(self, entry_index: int) -> None:
        """Show details for a sleep entry."""
        if entry_index < 0 or entry_index >= len(self.blocker.sleep_entries):
            return
        entry = self.blocker.sleep_entries[entry_index]
        
        disruptions = entry.get("disruptions", [])
        disruption_text = ""
        for d in disruptions:
            for tag_id, name, emoji, _ in SLEEP_DISRUPTION_TAGS:
                if tag_id == d:
                    disruption_text += f"  {emoji} {name}\n"
                    break
        if not disruption_text:
            disruption_text = "  None\n"
        
        details = (
            f"üìÖ Date: {entry.get('date', 'Unknown')}\n"
            f"üõèÔ∏è Bedtime: {entry.get('bedtime', 'Unknown')}\n"
            f"‚òÄÔ∏è Wake time: {entry.get('wake_time', 'Unknown')}\n"
            f"‚è∞ Duration: {entry.get('sleep_hours', 0):.1f} hours\n"
            f"‚≠ê Quality: {entry.get('quality', 'Unknown')}\n"
            f"üìä Score: {entry.get('score', 0)}/100\n"
            f"\nüìã Disruptions:\n{disruption_text}"
        )
        if entry.get("note"):
            details += f"\nüìù Note: {entry['note']}"
        
        show_info(self, "Sleep Entry Details", details)
    
    def _delete_entry(self, entry_index: int) -> None:
        """Delete a sleep entry."""
        if entry_index < 0 or entry_index >= len(self.blocker.sleep_entries):
            return
        entry = self.blocker.sleep_entries[entry_index]
        
        reply = show_question(
            self, "Delete Entry",
            f"Delete sleep entry for {entry.get('date', 'Unknown')}?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        )
        
        if reply == QtWidgets.QMessageBox.Yes:
            del self.blocker.sleep_entries[entry_index]
            self.blocker.save_config()
            self._refresh_display()
            
            # Update main timeline widget if parent window has it
            if self.parent() and hasattr(self.parent(), 'timeline_widget'):
                try:
                    self.parent().timeline_widget.update_data()
                except Exception:
                    pass
    
    def _setup_reminder(self) -> None:
        """Setup bedtime reminder timer."""
        if self._reminder_timer is not None:
            self._reminder_timer.stop()
        
        if not self.blocker.sleep_reminder_enabled:
            return
        
        self._reminder_timer = QtCore.QTimer(self)
        self._reminder_timer.timeout.connect(self._check_reminder)
        self._reminder_timer.start(60000)  # Check every minute
    
    def _check_reminder(self) -> None:
        """Check if it's time to show bedtime reminder."""
        if not self.blocker.sleep_reminder_enabled:
            return
        
        today = datetime.now().strftime("%Y-%m-%d")
        if self.blocker.sleep_last_reminder_date == today:
            return
        
        current_time = QtCore.QTime.currentTime()
        try:
            h, m = self.blocker.sleep_reminder_time.split(":")
            reminder_time = QtCore.QTime(int(h), int(m))
        except (ValueError, AttributeError):
            return
        
        if current_time >= reminder_time:
            self.blocker.sleep_last_reminder_date = today
            self.blocker.save_config()
            
            # Get personalized recommendation
            if get_sleep_recommendation:
                rec = get_sleep_recommendation(self.blocker.sleep_chronotype)
                bedtime_rec = rec['optimal_bedtime']
            else:
                bedtime_rec = "before midnight"
            
            # Try system tray notification if available and visible
            parent_window = self.window()
            notification_shown = False
            if hasattr(parent_window, 'tray_icon') and parent_window.tray_icon and parent_window.tray_icon.isVisible():
                parent_window.tray_icon.showMessage(
                    "üåô Bedtime Reminder",
                    f"Time to wind down! Optimal bedtime: {bedtime_rec}",
                    QtWidgets.QSystemTrayIcon.MessageIcon.Information,
                    5000
                )
                notification_shown = True
            
            # Fallback: show in-app toast (non-blocking)
            if not notification_shown:
                show_perk_toast(f"üåô Time to wind down! Optimal bedtime: {bedtime_rec}", "üåô", self)
    
    def _update_reminder_setting(self) -> None:
        """Update reminder settings."""
        self.blocker.sleep_reminder_enabled = self.reminder_checkbox.isChecked()
        self.blocker.sleep_reminder_time = self.reminder_time.time().toString("HH:mm")
        self.blocker.save_config()
        self._setup_reminder()


class AITab(QtWidgets.QWidget):
    """AI insights tab - productivity coach, achievements, goals, challenges."""

    def __init__(self, blocker: BlockerCore, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.blocker = blocker
        # Initialize AI/gamification components
        self.analyzer = ProductivityAnalyzer(blocker.stats_path) if ProductivityAnalyzer else None
        self.gamification = GamificationEngine(blocker.stats_path) if GamificationEngine else None
        self.focus_goals = FocusGoals(blocker.goals_path, blocker.stats_path) if FocusGoals else None
        self._build_ui()

    def reload_components(self, blocker: BlockerCore) -> None:
        """Reload AI components with new blocker paths (used when switching users)."""
        self.blocker = blocker
        self.analyzer = ProductivityAnalyzer(blocker.stats_path) if ProductivityAnalyzer else None
        self.gamification = GamificationEngine(blocker.stats_path) if GamificationEngine else None
        self.focus_goals = FocusGoals(blocker.goals_path, blocker.stats_path) if FocusGoals else None
        # Clear cached insights
        if hasattr(self, 'insights_text'):
            self.insights_text.clear()

    def _build_ui(self) -> None:
        layout = QtWidgets.QVBoxLayout(self)
        add_tab_help_button(layout, "ai", self)

        scroll = QtWidgets.QScrollArea()
        scroll.setWidgetResizable(True)
        container = QtWidgets.QWidget()
        inner = QtWidgets.QVBoxLayout(container)

        # AI Status
        status_group = QtWidgets.QGroupBox("ü§ñ AI Status")
        status_layout = QtWidgets.QVBoxLayout(status_group)
        if AI_AVAILABLE:
            status_layout.addWidget(QtWidgets.QLabel("‚úÖ AI features available"))
        else:
            status_layout.addWidget(QtWidgets.QLabel("‚ö†Ô∏è AI not available - install with: pip install -r requirements_ai.txt"))
        inner.addWidget(status_group)

        # Productivity Insights
        insights_group = QtWidgets.QGroupBox("üí° Productivity Insights")
        insights_layout = QtWidgets.QVBoxLayout(insights_group)
        self.insights_text = QtWidgets.QTextEdit()
        self.insights_text.setReadOnly(True)
        self.insights_text.setMaximumHeight(150)
        insights_layout.addWidget(self.insights_text)
        refresh_btn = QtWidgets.QPushButton("üîÑ Get AI Insights")
        refresh_btn.clicked.connect(self._get_insights)
        refresh_btn.setEnabled(AI_AVAILABLE)
        insights_layout.addWidget(refresh_btn)
        inner.addWidget(insights_group)

        # Achievements
        achievements_group = QtWidgets.QGroupBox("üèÜ Achievements & Challenges")
        achievements_layout = QtWidgets.QVBoxLayout(achievements_group)
        
        # Intro label challenging the user
        self.achievements_intro = QtWidgets.QLabel()
        self.achievements_intro.setWordWrap(True)
        self.achievements_intro.setStyleSheet("font-weight: bold; color: #2196F3; padding: 5px;")
        achievements_layout.addWidget(self.achievements_intro)
        
        # Unlocked trophies section
        unlocked_label = QtWidgets.QLabel("‚úÖ Trophies Earned:")
        unlocked_label.setStyleSheet("font-weight: bold; margin-top: 5px;")
        achievements_layout.addWidget(unlocked_label)
        self.unlocked_achievements_list = QtWidgets.QListWidget()
        self.unlocked_achievements_list.setMaximumHeight(80)
        self.unlocked_achievements_list.setStyleSheet("background-color: #E8F5E9; color: #1b5e20;")
        achievements_layout.addWidget(self.unlocked_achievements_list)
        
        # Active challenges section
        challenges_label = QtWidgets.QLabel("üéØ Your Next Challenges ‚Äî Can You Complete Them?")
        challenges_label.setStyleSheet("font-weight: bold; margin-top: 10px; color: #FF5722;")
        achievements_layout.addWidget(challenges_label)
        self.achievements_list = QtWidgets.QListWidget()
        self.achievements_list.setMaximumHeight(150)
        self.achievements_list.setStyleSheet("background-color: #FFF3E0; color: #5d4037;")
        achievements_layout.addWidget(self.achievements_list)
        
        inner.addWidget(achievements_group)

        # Daily Challenge
        challenge_group = QtWidgets.QGroupBox("üéØ Daily Challenge")
        challenge_layout = QtWidgets.QVBoxLayout(challenge_group)
        self.challenge_label = QtWidgets.QLabel()
        challenge_layout.addWidget(self.challenge_label)
        self.challenge_progress = QtWidgets.QProgressBar()
        self.challenge_progress.setMaximum(100)
        challenge_layout.addWidget(self.challenge_progress)
        new_challenge_btn = QtWidgets.QPushButton("üé≤ New Challenge")
        new_challenge_btn.clicked.connect(self._new_challenge)
        challenge_layout.addWidget(new_challenge_btn)
        inner.addWidget(challenge_group)

        # Goals
        goals_group = QtWidgets.QGroupBox("üìã Goals")
        goals_layout = QtWidgets.QVBoxLayout(goals_group)
        self.goals_list = QtWidgets.QListWidget()
        self.goals_list.setMaximumHeight(120)
        goals_layout.addWidget(self.goals_list)
        goals_btn_layout = QtWidgets.QHBoxLayout()
        add_goal_btn = QtWidgets.QPushButton("‚ûï Add Goal")
        add_goal_btn.clicked.connect(self._add_goal)
        goals_btn_layout.addWidget(add_goal_btn)
        rem_goal_btn = QtWidgets.QPushButton("‚úì Complete Goal")
        rem_goal_btn.clicked.connect(self._complete_goal)
        goals_btn_layout.addWidget(rem_goal_btn)
        goals_btn_layout.addStretch()
        goals_layout.addLayout(goals_btn_layout)
        inner.addWidget(goals_group)

        # AI-powered statistics
        stats_group = QtWidgets.QGroupBox("üìà AI-Powered Statistics")
        stats_layout = QtWidgets.QVBoxLayout(stats_group)
        self.ai_stats_text = QtWidgets.QTextEdit()
        self.ai_stats_text.setReadOnly(True)
        self.ai_stats_text.setMaximumHeight(180)
        stats_layout.addWidget(self.ai_stats_text)
        inner.addWidget(stats_group)

        inner.addStretch()
        scroll.setWidget(container)
        layout.addWidget(scroll)

        self._refresh_data()

    def _refresh_data(self) -> None:
        # Achievements - split into unlocked trophies and active challenges
        self.achievements_list.clear()
        self.unlocked_achievements_list.clear()
        
        if self.gamification:
            progress = self.gamification.check_achievements()
            achievements_def = self.gamification.get_achievements()
            
            unlocked_count = 0
            locked_items = []
            
            for ach_id, data in achievements_def.items():
                prog = progress.get(ach_id, {"current": 0, "target": 1, "unlocked": False})
                pct = min(100, int((prog["current"] / prog["target"]) * 100)) if prog["target"] else 0
                
                if prog.get("unlocked"):
                    # Unlocked achievement - show as trophy
                    unlocked_count += 1
                    item = QtWidgets.QListWidgetItem(f"{data['icon']} {data['name']} ‚Äî COMPLETE! üéâ")
                    item.setToolTip(f"‚úÖ {data['name']}\n{data.get('description', '')}\nYou did it!")
                    self.unlocked_achievements_list.addItem(item)
                else:
                    # Locked achievement - show as challenge with encouraging text
                    current_val = prog["current"]
                    target_val = prog["target"]
                    
                    # Clamp display values to meaningful ranges
                    display_current = min(current_val, target_val)
                    remaining = max(0, target_val - current_val)
                    
                    challenge_text = f"{data['icon']} {data['name']}: {data.get('description', '')} ‚Äî {display_current}/{target_val} ({remaining} to go!)"
                    locked_items.append((pct, challenge_text, data))
            
            # Sort challenges by progress (closest to completion first)
            locked_items.sort(key=lambda x: -x[0])
            
            for pct, challenge_text, data in locked_items:
                item = QtWidgets.QListWidgetItem(challenge_text)
                # Add motivational tooltip
                if pct >= 75:
                    tip = f"üî• SO CLOSE! You're {pct}% there!\n{data.get('description', '')}"
                elif pct >= 50:
                    tip = f"üí™ Halfway there! Keep pushing!\n{data.get('description', '')}"
                elif pct >= 25:
                    tip = f"üìà Good progress! Don't stop now!\n{data.get('description', '')}"
                else:
                    tip = f"üöÄ Challenge yourself: {data.get('description', '')}"
                item.setToolTip(tip)
                self.achievements_list.addItem(item)
            
            # Update intro label with personalized challenge
            total = len(achievements_def)
            if unlocked_count == 0:
                intro = "üéÆ You haven't unlocked any achievements yet! Complete focus sessions to earn your first trophy!"
            elif unlocked_count == total:
                intro = "üèÜ LEGENDARY! You've unlocked ALL achievements! You are a focus master!"
            elif unlocked_count >= total * 0.75:
                intro = f"üî• Almost there! {unlocked_count}/{total} achievements unlocked. Can you get them all?"
            else:
                intro = f"üí™ {unlocked_count}/{total} trophies earned! Take on the challenges below to unlock more!"
            self.achievements_intro.setText(intro)
            
            # Show message if no unlocked achievements
            if unlocked_count == 0:
                self.unlocked_achievements_list.addItem("No trophies yet ‚Äî complete your first focus session!")
        else:
            self.achievements_intro.setText("üîß AI module not installed")
            self.achievements_list.addItem("Install requirements_ai.txt to unlock achievements and challenges!")

        # Challenge
        if self.gamification:
            challenge = self.gamification.get_daily_challenge()
            current = challenge.get("progress", {}).get("current", 0)
            target = challenge.get("progress", {}).get("target", 1)
            pct = min(100, int((current / target) * 100)) if target else 0
            self.challenge_label.setText(f"{challenge.get('title', 'Daily Challenge')}: {challenge.get('description', '')}")
            self.challenge_progress.setValue(pct)
            self.challenge_progress.setFormat(f"{current}/{target} ({pct}%)")
        else:
            self.challenge_label.setText("Install AI dependencies to enable challenges.")
            self.challenge_progress.setValue(0)

        # Goals
        self.goals_list.clear()
        if self.focus_goals:
            try:
                self.focus_goals.update_progress()
                for goal in self.focus_goals.get_active_goals():
                    pct = 0
                    target = goal.get("target", 1)
                    progress_val = goal.get("progress", 0)
                    pct = min(100, int((progress_val / target) * 100)) if target else 0
                    self.goals_list.addItem(
                        f"üéØ {goal.get('title', 'Goal')} ‚Äî {pct}% ({progress_val/3600:.1f}h/{target/3600:.1f}h)"
                    )
            except Exception:
                pass

        # AI stats
        stats_lines: List[str] = []
        if self.analyzer:
            try:
                optimal = self.analyzer.predict_optimal_session_length()
                patterns = self.analyzer.get_distraction_patterns()
                stats_lines.append(f"Optimal session length: {optimal} min")
                stats_lines.append(f"Weekday vs weekend: {patterns.get('weekday_vs_weekend', 'balanced')}")
                stats_lines.append(f"Consistency: {patterns.get('consistency', 'n/a')}")
            except Exception:
                stats_lines.append("AI stats unavailable (error reading data).")
        else:
            stats_lines.append("Install AI requirements to view statistics.")
        self.ai_stats_text.setPlainText("\n".join(stats_lines))

    def _get_insights(self) -> None:
        if not AI_AVAILABLE:
            self.insights_text.setPlainText("AI not available")
            return

        # Prefer local analyzer if available
        if self.analyzer:
            try:
                insights = self.analyzer.generate_insights()
                recs = self.analyzer.get_recommendations()
                lines = []
                for ins in insights:
                    lines.append(f"{ins.get('title', 'Insight')}: {ins.get('message', '')}")
                lines.append("\nRecommendations:")
                for rec in recs:
                    lines.append(f"‚Ä¢ {rec.get('suggestion', '')} ({rec.get('reason', '')})")
                self.insights_text.setPlainText("\n".join(lines))
                return
            except Exception:
                pass
        
        # Legacy ProductivityAI fallback removed as we don't aim for backward compatibility
        self.insights_text.setPlainText("AI Insights unavailable.")

    def _new_challenge(self) -> None:
        if self.gamification:
            # Refresh daily challenge from AI engine
            challenge = self.gamification.get_daily_challenge()
            self._refresh_data()
        else:
            show_warning(self, "Feature Unavailable", "Gamification Engine is not loaded.")

    def _add_goal(self) -> None:
        goal, ok = QtWidgets.QInputDialog.getText(self, "Add Goal", "Enter your goal:")
        if ok and goal.strip():
            if self.focus_goals:
                try:
                    # Default to weekly 5h target for new AI goal
                    self.focus_goals.add_goal(goal.strip(), "weekly", target=5 * 3600)
                except Exception:
                    show_warning(self, "Error", "Failed to add goal via FocusGoals.")
            else:
                 show_warning(self, "Feature Unavailable", "FocusGoals module not loaded.")
            self._refresh_data()

    def _complete_goal(self) -> None:
        item = self.goals_list.currentItem()
        if not item:
            show_warning(self, "No Goal Selected", "Please select a goal from the list first.")
            return

        # Use FocusGoals exclusively
        if self.focus_goals:
            try:
                row = self.goals_list.currentRow()
                active = self.focus_goals.get_active_goals()
                if 0 <= row < len(active):
                    goal_id = active[row]["id"]
                    self.focus_goals.complete_goal(goal_id)
                    show_info(self, "Goal Completed!", "üéâ Goal marked as complete!")
                    self._refresh_data()
            except Exception:
                show_warning(self, "Error", "Failed to update goal status.")
        else:
             show_warning(self, "Feature Unavailable", "FocusGoals module not loaded.")


# ============================================================================
# Collapsible Section Widget
# ============================================================================

class CollapsibleSection(QtWidgets.QWidget):
    """A collapsible section widget with a toggle button header."""
    
    collapsed_changed = QtCore.Signal(str, bool)  # section_id, is_collapsed
    
    def __init__(self, title: str, section_id: str, parent=None, collapsed: bool = False):
        super().__init__(parent)
        self.section_id = section_id
        self._collapsed = collapsed
        
        self.main_layout = QtWidgets.QVBoxLayout(self)
        self.main_layout.setContentsMargins(0, 0, 0, 0)
        self.main_layout.setSpacing(0)
        
        # Header button
        self.toggle_btn = QtWidgets.QPushButton()
        self.toggle_btn.setCheckable(True)
        self.toggle_btn.setChecked(not collapsed)
        self.toggle_btn.clicked.connect(self._on_toggle)
        self.toggle_btn.setCursor(QtCore.Qt.PointingHandCursor)
        self._update_header(title)
        self.toggle_btn.setStyleSheet("""
            QPushButton {
                background: rgba(255,255,255,0.05);
                border: none;
                border-radius: 4px;
                padding: 6px 10px;
                text-align: left;
                font-weight: bold;
                color: #ccc;
            }
            QPushButton:hover {
                background: rgba(255,255,255,0.1);
            }
            QPushButton:checked {
                color: #fff;
            }
        """)
        self.main_layout.addWidget(self.toggle_btn)
        
        # Content container
        self.content_widget = QtWidgets.QWidget()
        self.content_layout = QtWidgets.QVBoxLayout(self.content_widget)
        self.content_layout.setContentsMargins(0, 4, 0, 4)
        self.content_layout.setSpacing(4)
        self.main_layout.addWidget(self.content_widget)
        
        # Set initial state
        self.content_widget.setVisible(not collapsed)
        self._title = title
    
    def _update_header(self, title: str):
        arrow = "‚ñº" if not self._collapsed else "‚ñ∂"
        self.toggle_btn.setText(f"{arrow} {title}")
    
    def _on_toggle(self):
        self._collapsed = not self.toggle_btn.isChecked()
        self.content_widget.setVisible(not self._collapsed)
        self._update_header(self._title)
        self.collapsed_changed.emit(self.section_id, self._collapsed)
    
    def set_title(self, title: str):
        self._title = title
        self._update_header(title)
    
    def add_widget(self, widget: QtWidgets.QWidget):
        self.content_layout.addWidget(widget)
    
    def clear_content(self):
        while self.content_layout.count():
            child = self.content_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
    
    def set_collapsed(self, collapsed: bool):
        self._collapsed = collapsed
        self.toggle_btn.setChecked(not collapsed)
        self.content_widget.setVisible(not collapsed)
        self._update_header(self._title)
    
    def is_collapsed(self) -> bool:
        return self._collapsed


# ============================================================================
# ADHD Buster Gamification Dialogs (Qt Implementation)
# ============================================================================

class CharacterCanvas(QtWidgets.QWidget):
    """Qt widget for rendering the ADHD Buster character with equipped gear."""

    # Canonical drawing dimensions - all drawing code uses these coordinates
    BASE_W = 180
    BASE_H = 220

    TIER_COLORS = {
        "pathetic": "#bdbdbd", "modest": "#a5d6a7", "decent": "#81c784",
        "heroic": "#64b5f6", "epic": "#ba68c8", "legendary": "#ffb74d", "godlike": "#ffd54f"
    }

    TIER_GLOW = {
        "pathetic": None, "modest": None, "decent": "#c8e6c9",
        "heroic": "#bbdefb", "epic": "#e1bee7", "legendary": "#ffe0b2", "godlike": "#fff9c4"
    }
    
    TIER_OUTLINE = {
        "pathetic": "#888", "modest": "#6b9b6d", "decent": "#5a9a5c",
        "heroic": "#4a90c4", "epic": "#8a4a9c", "legendary": "#c98a3a", "godlike": "#d4a82a"
    }
    
    TIER_PARTICLES = {
        "pathetic": None, "modest": None, "decent": None,
        "heroic": ("#64b5f6", 4), "epic": ("#e040fb", 6), 
        "legendary": ("#ffd700", 8), "godlike": ("#fff9c4", 12)
    }

    def __init__(self, equipped: dict, power: int, width: int = 180, height: int = 220,
                 parent: Optional[QtWidgets.QWidget] = None, story_theme: str = "warrior") -> None:
        super().__init__(parent)
        self.equipped = equipped
        self.power = power
        self.story_theme = story_theme  # warrior, scholar, wanderer, underdog
        # Set minimum size but allow expansion (for splitter resizing)
        self.setMinimumSize(120, 145)  # Minimum readable size
        # Use size policy that maintains aspect ratio when resizing
        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        if GAMIFICATION_AVAILABLE:
            self.tier = get_diary_power_tier(power)
        else:
            self.tier = "pathetic" if power < 50 else "modest" if power < 150 else "decent"
        # Generate stable particle positions based on power (deterministic)
        import random
        rng = random.Random(power)
        self._particles = [(rng.randint(-50, 50), rng.randint(-60, 60), rng.randint(2, 5)) 
                           for _ in range(15)]

    def hasHeightForWidth(self) -> bool:
        """Enable aspect ratio preservation."""
        return True

    def heightForWidth(self, width: int) -> int:
        """Maintain canonical aspect ratio (180:220 = 0.818:1)."""
        return int(width * self.BASE_H / self.BASE_W)

    def sizeHint(self) -> QtCore.QSize:
        """Return preferred size based on canonical dimensions."""
        return QtCore.QSize(self.BASE_W, self.BASE_H)

    def resizeEvent(self, event) -> None:
        """Maintain aspect ratio on resize."""
        super().resizeEvent(event)
        # Force aspect ratio by adjusting height based on width
        new_width = event.size().width()
        ideal_height = self.heightForWidth(new_width)
        if event.size().height() != ideal_height:
            # Only adjust if significantly different to avoid infinite loops
            if abs(event.size().height() - ideal_height) > 5:
                self.setFixedHeight(ideal_height)

    def paintEvent(self, event) -> None:
        """Dispatch to theme-specific drawing method."""
        painter = QtGui.QPainter(self)
        try:
            # Apply scaling to map canonical coords (BASE_W x BASE_H) to actual widget size
            sx = self.width() / self.BASE_W if self.BASE_W else 1
            sy = self.height() / self.BASE_H if self.BASE_H else 1
            painter.scale(sx, sy)
            self.render_content(painter)
        finally:
            painter.end()

    def render_content(self, painter: QtGui.QPainter) -> None:
        """Render the character using the provided painter.
        
        Draws using canonical coordinates (BASE_W x BASE_H = 180x220).
        Caller is responsible for any scaling/translation needed.
        """
        painter.save()
        try:
            # Reset critical painter state to prevent damage from stale settings
            painter.setOpacity(1.0)
            painter.setCompositionMode(QtGui.QPainter.CompositionMode.CompositionMode_SourceOver)
            painter.setClipping(False)
            
            if self.story_theme == "scholar":
                self._draw_scholar_character(painter)
            elif self.story_theme == "wanderer":
                self._draw_wanderer_character(painter)
            elif self.story_theme == "underdog":
                self._draw_underdog_character(painter)
            elif self.story_theme == "scientist":
                self._draw_scientist_character(painter)
            else:
                self._draw_warrior_character(painter)
        finally:
            painter.restore()

    def _draw_warrior_character(self, painter: QtGui.QPainter) -> None:
        """Draw the classic fantasy warrior character."""
        # painter = QtGui.QPainter(self)  # Uses passed painter
        painter.setRenderHint(QtGui.QPainter.Antialiasing)

        # Use canonical dimensions for drawing (scaling handled by caller)
        w, h = self.BASE_W, self.BASE_H
        cx, cy = w // 2, h // 2 + 5

        # Background with radial gradient for depth
        bg_gradient = QtGui.QRadialGradient(cx, cy - 20, max(w, h) * 0.8)
        bg_gradient.setColorAt(0, QtGui.QColor("#404050"))
        bg_gradient.setColorAt(0.5, QtGui.QColor("#2d2d3d"))
        bg_gradient.setColorAt(1, QtGui.QColor("#1a1a2a"))
        painter.fillRect(0, 0, w, h, bg_gradient)
        
        # Floor with gradient
        floor_gradient = QtGui.QLinearGradient(cx - 40, cy + 70, cx + 40, cy + 85)
        floor_gradient.setColorAt(0, QtGui.QColor(0, 0, 0, 30))
        floor_gradient.setColorAt(0.5, QtGui.QColor(0, 0, 0, 80))
        floor_gradient.setColorAt(1, QtGui.QColor(0, 0, 0, 30))
        painter.setBrush(floor_gradient)
        painter.setPen(QtCore.Qt.NoPen)
        painter.drawEllipse(cx - 40, cy + 68, 80, 18)

        body_color = QtGui.QColor(self.TIER_COLORS.get(self.tier, "#bdbdbd"))
        body_outline = QtGui.QColor(self.TIER_OUTLINE.get(self.tier, "#888"))
        glow = self.TIER_GLOW.get(self.tier)

        def darken(color: str, amount: int = 130) -> QtGui.QColor:
            c = QtGui.QColor(color)
            return c.darker(amount)
        
        def lighten(color: str, amount: int = 130) -> QtGui.QColor:
            c = QtGui.QColor(color)
            return c.lighter(amount)

        # Glow aura for high tiers (multiple layers)
        if glow:
            glow_color = QtGui.QColor(glow)
            # Outer glow
            painter.setBrush(QtCore.Qt.NoBrush)
            for i, opacity in enumerate([0.1, 0.15, 0.25, 0.35]):
                painter.setOpacity(opacity)
                size = 140 - i * 15
                painter.setPen(QtGui.QPen(glow_color, 3))
                painter.drawEllipse(cx - size//2, cy - 70, size, int(size * 1.2))
            painter.setOpacity(1.0)
            # Inner glow fill
            painter.setBrush(glow_color)
            painter.setPen(QtCore.Qt.NoPen)
            painter.setOpacity(0.25)
            painter.drawEllipse(cx - 50, cy - 60, 100, 130)
            painter.setOpacity(1.0)
        
        # Particle effects for high tiers
        particles = self.TIER_PARTICLES.get(self.tier)
        if particles:
            p_color, p_count = particles
            painter.setBrush(QtGui.QColor(p_color))
            painter.setPen(QtCore.Qt.NoPen)
            for i, (px, py, ps) in enumerate(self._particles[:p_count]):
                painter.setOpacity(0.4 + (i % 3) * 0.2)
                painter.drawEllipse(cx + px, cy + py, ps, ps)
            painter.setOpacity(1.0)

        # === CLOAK (behind body) ===
        cloak = self.equipped.get("Cloak")
        if cloak:
            cc = QtGui.QColor(cloak.get("color", "#666"))
            # Flowing cloak shape with curves
            path = QtGui.QPainterPath()
            path.moveTo(cx - 22, cy - 28)
            path.lineTo(cx + 22, cy - 28)
            path.cubicTo(cx + 35, cy, cx + 40, cy + 35, cx + 35, cy + 68)
            path.quadTo(cx + 20, cy + 72, cx, cy + 70)
            path.quadTo(cx - 20, cy + 72, cx - 35, cy + 68)
            path.cubicTo(cx - 40, cy + 35, cx - 35, cy, cx - 22, cy - 28)
            # Cloak gradient for depth
            cloak_gradient = QtGui.QLinearGradient(cx - 35, cy, cx + 35, cy)
            cloak_gradient.setColorAt(0, darken(cloak.get("color", "#666"), 140))
            cloak_gradient.setColorAt(0.3, cc)
            cloak_gradient.setColorAt(0.7, cc)
            cloak_gradient.setColorAt(1, darken(cloak.get("color", "#666"), 120))
            painter.setBrush(cloak_gradient)
            painter.setPen(QtGui.QPen(darken(cloak.get("color", "#666"), 150), 2))
            painter.drawPath(path)
            # Cloak folds
            painter.setPen(QtGui.QPen(darken(cloak.get("color", "#666"), 160), 1))
            painter.drawLine(cx - 15, cy - 20, cx - 20, cy + 60)
            painter.drawLine(cx + 15, cy - 20, cx + 20, cy + 60)
            painter.drawLine(cx, cy - 15, cx, cy + 65)
            # Cloak clasp at neck
            painter.setBrush(QtGui.QColor("#b8860b"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#8b6914"), 1))
            painter.drawEllipse(cx - 5, cy - 30, 10, 8)

        # === LEGS with shading ===
        # Left leg gradient
        leg_grad_l = QtGui.QLinearGradient(cx - 18, cy + 22, cx - 5, cy + 22)
        leg_grad_l.setColorAt(0, body_color.darker(120))
        leg_grad_l.setColorAt(0.5, body_color)
        leg_grad_l.setColorAt(1, body_color.darker(110))
        painter.setBrush(leg_grad_l)
        painter.setPen(QtGui.QPen(body_outline, 2))
        leg_path_l = QtGui.QPainterPath()
        leg_path_l.moveTo(cx - 18, cy + 22)
        leg_path_l.lineTo(cx - 4, cy + 22)
        leg_path_l.quadTo(cx - 3, cy + 40, cx - 5, cy + 55)
        leg_path_l.lineTo(cx - 18, cy + 55)
        leg_path_l.quadTo(cx - 19, cy + 40, cx - 18, cy + 22)
        painter.drawPath(leg_path_l)
        # Right leg gradient
        leg_grad_r = QtGui.QLinearGradient(cx + 4, cy + 22, cx + 18, cy + 22)
        leg_grad_r.setColorAt(0, body_color.darker(110))
        leg_grad_r.setColorAt(0.5, body_color)
        leg_grad_r.setColorAt(1, body_color.darker(120))
        painter.setBrush(leg_grad_r)
        leg_path_r = QtGui.QPainterPath()
        leg_path_r.moveTo(cx + 4, cy + 22)
        leg_path_r.lineTo(cx + 18, cy + 22)
        leg_path_r.quadTo(cx + 19, cy + 40, cx + 18, cy + 55)
        leg_path_r.lineTo(cx + 5, cy + 55)
        leg_path_r.quadTo(cx + 3, cy + 40, cx + 4, cy + 22)
        painter.drawPath(leg_path_r)

        # === BOOTS ===
        boots = self.equipped.get("Boots")
        if boots:
            bc = QtGui.QColor(boots.get("color", "#666"))
            # Boot gradient for 3D effect
            boot_grad = QtGui.QLinearGradient(0, cy + 52, 0, cy + 74)
            boot_grad.setColorAt(0, bc.lighter(110))
            boot_grad.setColorAt(0.5, bc)
            boot_grad.setColorAt(1, bc.darker(120))
            painter.setBrush(boot_grad)
            painter.setPen(QtGui.QPen(bc.darker(140), 2))
            # Left boot with curved toe
            left_boot = QtGui.QPainterPath()
            left_boot.moveTo(cx - 20, cy + 52)
            left_boot.lineTo(cx - 2, cy + 52)
            left_boot.lineTo(cx - 2, cy + 68)
            left_boot.quadTo(cx - 5, cy + 75, cx - 14, cy + 75)
            left_boot.quadTo(cx - 22, cy + 75, cx - 22, cy + 68)
            left_boot.lineTo(cx - 20, cy + 52)
            painter.drawPath(left_boot)
            # Right boot
            right_boot = QtGui.QPainterPath()
            right_boot.moveTo(cx + 2, cy + 52)
            right_boot.lineTo(cx + 20, cy + 52)
            right_boot.lineTo(cx + 22, cy + 68)
            right_boot.quadTo(cx + 22, cy + 75, cx + 14, cy + 75)
            right_boot.quadTo(cx + 5, cy + 75, cx + 2, cy + 68)
            right_boot.lineTo(cx + 2, cy + 52)
            painter.drawPath(right_boot)
            # Boot cuffs
            painter.setBrush(bc.darker(115))
            painter.drawRect(cx - 21, cy + 52, 20, 6)
            painter.drawRect(cx + 1, cy + 52, 20, 6)
            # Boot buckles
            painter.setBrush(QtGui.QColor("#b8860b"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#8b6914"), 1))
            painter.drawRect(cx - 14, cy + 60, 6, 4)
            painter.drawRect(cx + 8, cy + 60, 6, 4)
            # Boot shine
            painter.setPen(QtGui.QPen(bc.lighter(140), 1))
            painter.drawLine(cx - 16, cy + 56, cx - 8, cy + 56)
            painter.drawLine(cx + 6, cy + 56, cx + 14, cy + 56)
        else:
            # Bare feet with toes
            painter.setBrush(QtGui.QColor("#e6b980"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#c9a066"), 1))
            # Left foot
            painter.drawRoundedRect(cx - 18, cy + 55, 14, 18, 4, 4)
            # Right foot
            painter.drawRoundedRect(cx + 4, cy + 55, 14, 18, 4, 4)
            # Toes
            painter.setBrush(QtGui.QColor("#dba870"))
            for i in range(3):
                painter.drawEllipse(cx - 17 + i * 4, cy + 70, 3, 4)
                painter.drawEllipse(cx + 5 + i * 4, cy + 70, 3, 4)

        # === ARMS with muscle shading ===
        # Left arm gradient
        arm_grad_l = QtGui.QLinearGradient(cx - 42, cy - 5, cx - 28, cy - 5)
        arm_grad_l.setColorAt(0, body_color.darker(125))
        arm_grad_l.setColorAt(0.4, body_color)
        arm_grad_l.setColorAt(1, body_color.darker(110))
        painter.setBrush(arm_grad_l)
        painter.setPen(QtGui.QPen(body_outline, 2))
        arm_path_l = QtGui.QPainterPath()
        arm_path_l.moveTo(cx - 28, cy - 24)
        arm_path_l.quadTo(cx - 36, cy - 26, cx - 40, cy - 20)
        arm_path_l.quadTo(cx - 45, cy, cx - 44, cy + 18)
        arm_path_l.lineTo(cx - 28, cy + 15)
        arm_path_l.quadTo(cx - 27, cy - 5, cx - 28, cy - 24)
        painter.drawPath(arm_path_l)
        # Right arm
        arm_grad_r = QtGui.QLinearGradient(cx + 28, cy - 5, cx + 42, cy - 5)
        arm_grad_r.setColorAt(0, body_color.darker(110))
        arm_grad_r.setColorAt(0.6, body_color)
        arm_grad_r.setColorAt(1, body_color.darker(125))
        painter.setBrush(arm_grad_r)
        arm_path_r = QtGui.QPainterPath()
        arm_path_r.moveTo(cx + 28, cy - 24)
        arm_path_r.quadTo(cx + 36, cy - 26, cx + 40, cy - 20)
        arm_path_r.quadTo(cx + 45, cy, cx + 44, cy + 18)
        arm_path_r.lineTo(cx + 28, cy + 15)
        arm_path_r.quadTo(cx + 27, cy - 5, cx + 28, cy - 24)
        painter.drawPath(arm_path_r)

        # === GAUNTLETS ===
        gaunt = self.equipped.get("Gauntlets")
        if gaunt:
            gc = QtGui.QColor(gaunt.get("color", "#666"))
            # Gauntlet gradient
            gaunt_grad = QtGui.QLinearGradient(0, cy + 8, 0, cy + 30)
            gaunt_grad.setColorAt(0, gc.lighter(115))
            gaunt_grad.setColorAt(0.5, gc)
            gaunt_grad.setColorAt(1, gc.darker(120))
            painter.setBrush(gaunt_grad)
            painter.setPen(QtGui.QPen(gc.darker(140), 2))
            # Left gauntlet with armor plates
            painter.drawRoundedRect(cx - 48, cy + 6, 24, 26, 5, 5)
            # Armor plate lines
            painter.setPen(QtGui.QPen(gc.darker(150), 1))
            painter.drawLine(cx - 46, cy + 12, cx - 26, cy + 12)
            painter.drawLine(cx - 46, cy + 18, cx - 26, cy + 18)
            # Knuckle spikes for epic+ tiers
            if self.tier in ["epic", "legendary", "godlike"]:
                painter.setBrush(gc.darker(130))
                painter.setPen(QtGui.QPen(gc.darker(150), 1))
                for i in range(3):
                    spike = QtGui.QPainterPath()
                    spike.moveTo(cx - 44 + i * 7, cy + 24)
                    spike.lineTo(cx - 41 + i * 7, cy + 32)
                    spike.lineTo(cx - 38 + i * 7, cy + 24)
                    painter.drawPath(spike)
            # Right gauntlet
            painter.setBrush(gaunt_grad)
            painter.setPen(QtGui.QPen(gc.darker(140), 2))
            painter.drawRoundedRect(cx + 24, cy + 6, 24, 26, 5, 5)
            painter.setPen(QtGui.QPen(gc.darker(150), 1))
            painter.drawLine(cx + 26, cy + 12, cx + 46, cy + 12)
            painter.drawLine(cx + 26, cy + 18, cx + 46, cy + 18)
            if self.tier in ["epic", "legendary", "godlike"]:
                painter.setBrush(gc.darker(130))
                for i in range(3):
                    spike = QtGui.QPainterPath()
                    spike.moveTo(cx + 26 + i * 7, cy + 24)
                    spike.lineTo(cx + 29 + i * 7, cy + 32)
                    spike.lineTo(cx + 32 + i * 7, cy + 24)
                    painter.drawPath(spike)
        else:
            # Detailed hands
            painter.setBrush(QtGui.QColor("#ffcc80"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#e6a84d"), 1))
            # Left hand
            painter.drawEllipse(cx - 46, cy + 12, 16, 16)
            # Fingers
            painter.setBrush(QtGui.QColor("#f5c07a"))
            for i in range(4):
                painter.drawEllipse(cx - 46 + i * 4, cy + 24, 3, 6)
            # Right hand
            painter.setBrush(QtGui.QColor("#ffcc80"))
            painter.drawEllipse(cx + 30, cy + 12, 16, 16)
            painter.setBrush(QtGui.QColor("#f5c07a"))
            for i in range(4):
                painter.drawEllipse(cx + 31 + i * 4, cy + 24, 3, 6)

        # === TORSO with shading ===
        torso_grad = QtGui.QLinearGradient(cx - 25, cy, cx + 25, cy)
        torso_grad.setColorAt(0, body_color.darker(115))
        torso_grad.setColorAt(0.3, body_color)
        torso_grad.setColorAt(0.7, body_color)
        torso_grad.setColorAt(1, body_color.darker(115))
        painter.setBrush(torso_grad)
        painter.setPen(QtGui.QPen(body_outline, 2))
        torso_path = QtGui.QPainterPath()
        torso_path.moveTo(cx - 26, cy - 28)
        torso_path.quadTo(cx - 28, cy - 5, cx - 23, cy + 25)
        torso_path.lineTo(cx + 23, cy + 25)
        torso_path.quadTo(cx + 28, cy - 5, cx + 26, cy - 28)
        torso_path.closeSubpath()
        painter.drawPath(torso_path)

        # === CHESTPLATE ===
        chest = self.equipped.get("Chestplate")
        if chest:
            cc = QtGui.QColor(chest.get("color", "#666"))
            # Chestplate gradient for metallic look
            chest_grad = QtGui.QLinearGradient(cx - 22, cy, cx + 22, cy)
            chest_grad.setColorAt(0, cc.darker(130))
            chest_grad.setColorAt(0.2, cc.lighter(110))
            chest_grad.setColorAt(0.5, cc)
            chest_grad.setColorAt(0.8, cc.lighter(110))
            chest_grad.setColorAt(1, cc.darker(130))
            painter.setBrush(chest_grad)
            painter.setPen(QtGui.QPen(cc.darker(140), 2))
            # Main plate with curves
            chest_path = QtGui.QPainterPath()
            chest_path.moveTo(cx - 23, cy - 26)
            chest_path.quadTo(cx, cy - 30, cx + 23, cy - 26)
            chest_path.quadTo(cx + 25, cy, cx + 20, cy + 20)
            chest_path.lineTo(cx - 20, cy + 20)
            chest_path.quadTo(cx - 25, cy, cx - 23, cy - 26)
            painter.drawPath(chest_path)
            # Chest muscle definition lines
            painter.setPen(QtGui.QPen(cc.darker(140), 1))
            painter.drawArc(cx - 15, cy - 18, 14, 12, 30 * 16, 120 * 16)
            painter.drawArc(cx + 1, cy - 18, 14, 12, 30 * 16, 120 * 16)
            # Abs definition for high tiers
            if self.tier in ["heroic", "epic", "legendary", "godlike"]:
                painter.drawLine(cx, cy - 5, cx, cy + 15)
                painter.drawLine(cx - 12, cy, cx + 12, cy)
                painter.drawLine(cx - 10, cy + 10, cx + 10, cy + 10)
            # Shoulder pads with rivets
            painter.setBrush(cc.darker(110))
            painter.setPen(QtGui.QPen(cc.darker(145), 1))
            # Left shoulder
            shoulder_l = QtGui.QPainterPath()
            shoulder_l.moveTo(cx - 26, cy - 26)
            shoulder_l.quadTo(cx - 35, cy - 28, cx - 38, cy - 20)
            shoulder_l.lineTo(cx - 28, cy - 18)
            shoulder_l.closeSubpath()
            painter.drawPath(shoulder_l)
            # Right shoulder
            shoulder_r = QtGui.QPainterPath()
            shoulder_r.moveTo(cx + 26, cy - 26)
            shoulder_r.quadTo(cx + 35, cy - 28, cx + 38, cy - 20)
            shoulder_r.lineTo(cx + 28, cy - 18)
            shoulder_r.closeSubpath()
            painter.drawPath(shoulder_r)
            # Rivets on shoulders
            painter.setBrush(cc.lighter(130))
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx - 32, cy - 24, 4, 4)
            painter.drawEllipse(cx + 28, cy - 24, 4, 4)
            # Center emblem (gem or symbol)
            emblem_grad = QtGui.QRadialGradient(cx, cy - 12, 8)
            emblem_grad.setColorAt(0, QtGui.QColor("#fff"))
            emblem_grad.setColorAt(0.3, cc.lighter(150))
            emblem_grad.setColorAt(1, cc.lighter(120))
            painter.setBrush(emblem_grad)
            painter.setPen(QtGui.QPen(cc.darker(130), 1))
            painter.drawEllipse(cx - 6, cy - 18, 12, 12)
        else:
            # Tunic/shirt details
            painter.setPen(QtGui.QPen(body_outline, 1))
            painter.drawLine(cx, cy - 25, cx, cy + 18)
            # Collar
            painter.drawLine(cx - 10, cy - 26, cx, cy - 20)
            painter.drawLine(cx + 10, cy - 26, cx, cy - 20)
        
        # === BELT (always visible) ===
        belt_color = QtGui.QColor("#5d4037") if not chest else chest.get("color", "#666")
        belt_c = QtGui.QColor(belt_color) if isinstance(belt_color, str) else belt_color
        painter.setBrush(belt_c.darker(140) if chest else QtGui.QColor("#4e342e"))
        painter.setPen(QtGui.QPen(QtGui.QColor("#3e2723"), 1))
        painter.drawRect(cx - 21, cy + 18, 42, 7)
        # Belt buckle
        painter.setBrush(QtGui.QColor("#b8860b"))
        painter.setPen(QtGui.QPen(QtGui.QColor("#8b6914"), 1))
        painter.drawRect(cx - 5, cy + 17, 10, 9)
        # Buckle detail
        painter.setPen(QtGui.QPen(QtGui.QColor("#daa520"), 1))
        painter.drawRect(cx - 3, cy + 19, 6, 5)

        # === HEAD ===
        # Neck with shading
        neck_grad = QtGui.QLinearGradient(cx - 8, cy - 35, cx + 8, cy - 35)
        neck_grad.setColorAt(0, QtGui.QColor("#e6b980"))
        neck_grad.setColorAt(0.5, QtGui.QColor("#ffcc80"))
        neck_grad.setColorAt(1, QtGui.QColor("#e6b980"))
        painter.setBrush(neck_grad)
        painter.setPen(QtGui.QPen(QtGui.QColor("#d4943a"), 1))
        painter.drawRect(cx - 9, cy - 36, 18, 12)
        
        # Head shape with better gradient
        head_gradient = QtGui.QRadialGradient(cx - 5, cy - 55, 30)
        head_gradient.setColorAt(0, QtGui.QColor("#ffe8c8"))
        head_gradient.setColorAt(0.5, QtGui.QColor("#ffcc80"))
        head_gradient.setColorAt(0.8, QtGui.QColor("#e6a84d"))
        head_gradient.setColorAt(1, QtGui.QColor("#d4943a"))
        painter.setBrush(head_gradient)
        painter.setPen(QtGui.QPen(QtGui.QColor("#c9843a"), 2))
        # Slightly more defined head shape
        head_path = QtGui.QPainterPath()
        head_path.moveTo(cx - 2, cy - 32)
        head_path.quadTo(cx - 22, cy - 35, cx - 22, cy - 52)
        head_path.quadTo(cx - 22, cy - 72, cx, cy - 72)
        head_path.quadTo(cx + 22, cy - 72, cx + 22, cy - 52)
        head_path.quadTo(cx + 22, cy - 35, cx + 2, cy - 32)
        head_path.closeSubpath()
        painter.drawPath(head_path)

        # === HELMET (if equipped) ===
        helm = self.equipped.get("Helmet")
        if helm:
            hc = QtGui.QColor(helm.get("color", "#666"))
            # Helmet gradient for metallic
            helm_grad = QtGui.QLinearGradient(cx - 24, cy - 70, cx + 24, cy - 70)
            helm_grad.setColorAt(0, hc.darker(130))
            helm_grad.setColorAt(0.3, hc.lighter(115))
            helm_grad.setColorAt(0.5, hc)
            helm_grad.setColorAt(0.7, hc.lighter(115))
            helm_grad.setColorAt(1, hc.darker(130))
            painter.setBrush(helm_grad)
            painter.setPen(QtGui.QPen(hc.darker(140), 2))
            # Helmet dome with better shape
            helm_path = QtGui.QPainterPath()
            helm_path.moveTo(cx - 24, cy - 52)
            helm_path.quadTo(cx - 26, cy - 75, cx, cy - 80)
            helm_path.quadTo(cx + 26, cy - 75, cx + 24, cy - 52)
            helm_path.closeSubpath()
            painter.drawPath(helm_path)
            # Helmet rim/visor band
            painter.setBrush(hc.darker(115))
            painter.drawRect(cx - 24, cy - 56, 48, 10)
            # Center crest/ridge
            painter.setPen(QtGui.QPen(hc.darker(150), 3))
            painter.drawLine(cx, cy - 80, cx, cy - 48)
            # Side details
            painter.setPen(QtGui.QPen(hc.darker(140), 1))
            painter.drawLine(cx - 12, cy - 70, cx - 12, cy - 52)
            painter.drawLine(cx + 12, cy - 70, cx + 12, cy - 52)
            # Visor slit (eyes area)
            painter.setPen(QtGui.QPen(QtGui.QColor("#1a1a1a"), 3))
            painter.drawLine(cx - 14, cy - 52, cx + 14, cy - 52)
            # Helmet shine
            painter.setPen(QtGui.QPen(hc.lighter(150), 1))
            painter.drawLine(cx - 10, cy - 72, cx - 5, cy - 65)
            # Cheek guards
            painter.setBrush(hc.darker(110))
            painter.setPen(QtGui.QPen(hc.darker(140), 1))
            painter.drawRect(cx - 24, cy - 48, 8, 12)
            painter.drawRect(cx + 16, cy - 48, 8, 12)
            # Plume for epic+ tiers
            if self.tier in ["epic", "legendary", "godlike"]:
                plume_color = QtGui.QColor("#c62828") if self.tier == "epic" else QtGui.QColor("#ffd700")
                painter.setBrush(plume_color)
                painter.setPen(QtGui.QPen(plume_color.darker(130), 1))
                plume = QtGui.QPainterPath()
                plume.moveTo(cx - 3, cy - 80)
                plume.quadTo(cx - 8, cy - 95, cx, cy - 100)
                plume.quadTo(cx + 8, cy - 95, cx + 3, cy - 80)
                painter.drawPath(plume)
        else:
            # Hair on top of head (not covering forehead)
            hair_color = QtGui.QColor("#5d4037")
            hair_grad = QtGui.QRadialGradient(cx, cy - 68, 22)
            hair_grad.setColorAt(0, hair_color.lighter(120))
            hair_grad.setColorAt(0.6, hair_color)
            hair_grad.setColorAt(1, hair_color.darker(130))
            painter.setBrush(hair_grad)
            painter.setPen(QtCore.Qt.NoPen)
            # Hair volume - sits on top, doesn't cover forehead
            hair_path = QtGui.QPainterPath()
            hair_path.moveTo(cx - 20, cy - 60)  # Start at sides above ears
            hair_path.quadTo(cx - 24, cy - 68, cx - 18, cy - 74)  # Left side curve up
            hair_path.quadTo(cx - 8, cy - 80, cx, cy - 79)  # Top left to center peak
            hair_path.quadTo(cx + 8, cy - 80, cx + 18, cy - 74)  # Top right
            hair_path.quadTo(cx + 24, cy - 68, cx + 20, cy - 60)  # Right side down
            hair_path.closeSubpath()
            painter.drawPath(hair_path)
            # Hair texture lines on top
            painter.setPen(QtGui.QPen(QtGui.QColor("#4e342e"), 1))
            painter.drawLine(cx - 12, cy - 72, cx - 10, cy - 64)
            painter.drawLine(cx - 5, cy - 76, cx - 4, cy - 66)
            painter.drawLine(cx, cy - 78, cx, cy - 68)
            painter.drawLine(cx + 5, cy - 76, cx + 4, cy - 66)
            painter.drawLine(cx + 12, cy - 72, cx + 10, cy - 64)
            # Side hair tufts (above ears)
            painter.setBrush(hair_color)
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx - 23, cy - 62, 6, 8)
            painter.drawEllipse(cx + 17, cy - 62, 6, 8)

        # === FACE (if no helmet visor) ===
        if not helm:
            # Eyebrows with expression
            painter.setPen(QtGui.QPen(QtGui.QColor("#4e342e"), 2))
            if self.tier in ["legendary", "godlike"]:
                # Confident raised brows
                painter.drawLine(cx - 13, cy - 60, cx - 5, cy - 58)
                painter.drawLine(cx + 5, cy - 58, cx + 13, cy - 60)
            elif self.tier in ["epic", "heroic"]:
                # Slightly furrowed determined
                painter.drawLine(cx - 13, cy - 58, cx - 5, cy - 59)
                painter.drawLine(cx + 5, cy - 59, cx + 13, cy - 58)
            else:
                # Normal
                painter.drawLine(cx - 12, cy - 58, cx - 5, cy - 57)
                painter.drawLine(cx + 5, cy - 57, cx + 12, cy - 58)
            
            # Eyes with more detail
            # Eye sockets (slight shadow)
            painter.setBrush(QtGui.QColor("#e8c090"))
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx - 13, cy - 56, 12, 10)
            painter.drawEllipse(cx + 1, cy - 56, 12, 10)
            # Eye whites
            painter.setBrush(QtGui.QColor("#fff"))
            painter.drawEllipse(cx - 12, cy - 55, 10, 9)
            painter.drawEllipse(cx + 2, cy - 55, 10, 9)
            # Iris (colored based on tier)
            iris_colors = {
                "pathetic": "#6b5b4f", "modest": "#5d7a5d", "decent": "#4a7a4a",
                "heroic": "#4a6a9a", "epic": "#7a4a8a", "legendary": "#8a6a2a", "godlike": "#9a7a1a"
            }
            iris_color = QtGui.QColor(iris_colors.get(self.tier, "#5a5a5a"))
            painter.setBrush(iris_color)
            painter.drawEllipse(cx - 9, cy - 53, 6, 6)
            painter.drawEllipse(cx + 4, cy - 53, 6, 6)
            # Pupils
            painter.setBrush(QtGui.QColor("#1a1a1a"))
            painter.drawEllipse(cx - 7, cy - 51, 3, 3)
            painter.drawEllipse(cx + 6, cy - 51, 3, 3)
            # Eye shine (multiple highlights)
            painter.setBrush(QtGui.QColor("#fff"))
            painter.drawEllipse(cx - 8, cy - 52, 2, 2)
            painter.drawEllipse(cx + 5, cy - 52, 2, 2)
            # Small secondary shine
            painter.setOpacity(0.6)
            painter.drawEllipse(cx - 5, cy - 49, 1, 1)
            painter.drawEllipse(cx + 8, cy - 49, 1, 1)
            painter.setOpacity(1.0)
            # Eyelashes (subtle)
            painter.setPen(QtGui.QPen(QtGui.QColor("#4e342e"), 1))
            painter.drawLine(cx - 12, cy - 54, cx - 14, cy - 55)
            painter.drawLine(cx + 12, cy - 54, cx + 14, cy - 55)

            # Nose with shadow
            painter.setPen(QtGui.QPen(QtGui.QColor("#d4943a"), 1))
            # Nose bridge
            painter.drawLine(cx, cy - 50, cx - 1, cy - 44)
            # Nostril hints
            painter.drawArc(cx - 4, cy - 44, 4, 3, 180 * 16, 180 * 16)
            painter.drawArc(cx, cy - 44, 4, 3, 180 * 16, 180 * 16)

            # Mouth/expression based on tier
            painter.setPen(QtGui.QPen(QtGui.QColor("#a05a3a"), 2))
            if self.tier in ["legendary", "godlike"]:
                # Big confident smile with teeth hint - moved up
                painter.drawArc(cx - 10, cy - 46, 20, 12, 200 * 16, 140 * 16)
                # Teeth
                painter.setPen(QtCore.Qt.NoPen)
                painter.setBrush(QtGui.QColor("#fff"))
                painter.drawRect(cx - 6, cy - 40, 12, 3)
            elif self.tier in ["epic", "heroic"]:
                # Confident smirk - moved up
                painter.drawArc(cx - 9, cy - 44, 18, 8, 210 * 16, 120 * 16)
            elif self.tier in ["decent", "modest"]:
                # Slight smile - moved up
                painter.drawArc(cx - 7, cy - 42, 14, 5, 220 * 16, 100 * 16)
            else:
                # Neutral/determined line - moved up
                painter.drawLine(cx - 6, cy - 40, cx + 6, cy - 40)
            
            # Cheek blush for high tiers
            if self.tier in ["legendary", "godlike"]:
                painter.setBrush(QtGui.QColor(255, 150, 150, 40))
                painter.setPen(QtCore.Qt.NoPen)
                painter.drawEllipse(cx - 18, cy - 48, 8, 5)
                painter.drawEllipse(cx + 10, cy - 48, 8, 5)

            # Ears - small and subtle, partially hidden by hair
            painter.setBrush(QtGui.QColor("#ffcc80"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#d4943a"), 1))
            # Left ear - small oval peeking out
            painter.drawEllipse(cx - 24, cy - 52, 5, 9)
            # Right ear
            painter.drawEllipse(cx + 19, cy - 52, 5, 9)
            # Inner ear shadow
            painter.setBrush(QtGui.QColor("#e6b070"))
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx - 23, cy - 50, 3, 5)
            painter.drawEllipse(cx + 20, cy - 50, 3, 5)

        # === AMULET ===
        amulet = self.equipped.get("Amulet")
        if amulet:
            ac = QtGui.QColor(amulet.get("color", "#666"))
            # Chain with links
            painter.setPen(QtGui.QPen(QtGui.QColor("#daa520"), 2))
            # Draw chain as small connected circles
            for i in range(4):
                painter.drawEllipse(cx - 12 + i * 3, cy - 28 + i * 2, 3, 3)
                painter.drawEllipse(cx + 9 - i * 3, cy - 28 + i * 2, 3, 3)
            # Amulet setting/frame
            painter.setBrush(QtGui.QColor("#b8860b"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#8b6914"), 2))
            # Ornate frame
            frame_path = QtGui.QPainterPath()
            frame_path.moveTo(cx, cy - 24)
            frame_path.lineTo(cx + 10, cy - 14)
            frame_path.lineTo(cx + 8, cy - 2)
            frame_path.lineTo(cx, cy + 2)
            frame_path.lineTo(cx - 8, cy - 2)
            frame_path.lineTo(cx - 10, cy - 14)
            frame_path.closeSubpath()
            painter.drawPath(frame_path)
            # Gem with gradient
            gem_grad = QtGui.QRadialGradient(cx - 2, cy - 14, 10)
            gem_grad.setColorAt(0, ac.lighter(150))
            gem_grad.setColorAt(0.5, ac)
            gem_grad.setColorAt(1, ac.darker(130))
            painter.setBrush(gem_grad)
            painter.setPen(QtGui.QPen(ac.darker(140), 1))
            # Inner gem
            gem_path = QtGui.QPainterPath()
            gem_path.moveTo(cx, cy - 20)
            gem_path.lineTo(cx + 7, cy - 12)
            gem_path.lineTo(cx + 5, cy - 2)
            gem_path.lineTo(cx, cy)
            gem_path.lineTo(cx - 5, cy - 2)
            gem_path.lineTo(cx - 7, cy - 12)
            gem_path.closeSubpath()
            painter.drawPath(gem_path)
            # Gem shine/sparkle
            painter.setBrush(QtGui.QColor(255, 255, 255, 180))
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx - 4, cy - 18, 5, 5)
            # Small sparkle
            painter.setBrush(QtGui.QColor(255, 255, 255, 120))
            painter.drawEllipse(cx + 2, cy - 8, 2, 2)
            # Magical glow for high tiers
            if self.tier in ["epic", "legendary", "godlike"]:
                painter.setOpacity(0.3)
                painter.setBrush(ac.lighter(130))
                painter.drawEllipse(cx - 12, cy - 22, 24, 28)
                painter.setOpacity(1.0)

        # === WEAPON ===
        weap = self.equipped.get("Weapon")
        if weap:
            wc = QtGui.QColor(weap.get("color", "#666"))
            # Sword handle with wrapping
            handle_grad = QtGui.QLinearGradient(cx - 56, cy, cx - 48, cy)
            handle_grad.setColorAt(0, QtGui.QColor("#4e342e"))
            handle_grad.setColorAt(0.5, QtGui.QColor("#6d4c41"))
            handle_grad.setColorAt(1, QtGui.QColor("#4e342e"))
            painter.setBrush(handle_grad)
            painter.setPen(QtGui.QPen(QtGui.QColor("#3e2723"), 1))
            painter.drawRoundedRect(cx - 56, cy - 2, 8, 38, 2, 2)
            # Handle leather wrap
            painter.setPen(QtGui.QPen(QtGui.QColor("#5d4037"), 2))
            for i in range(6):
                painter.drawLine(cx - 56, cy + 2 + i * 6, cx - 48, cy + 5 + i * 6)
            # Pommel (bottom)
            painter.setBrush(QtGui.QColor("#b8860b"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#8b6914"), 1))
            painter.drawEllipse(cx - 56, cy + 32, 8, 8)
            # Crossguard with curves
            guard_path = QtGui.QPainterPath()
            guard_path.moveTo(cx - 62, cy - 4)
            guard_path.quadTo(cx - 64, cy - 8, cx - 60, cy - 10)
            guard_path.lineTo(cx - 44, cy - 10)
            guard_path.quadTo(cx - 40, cy - 8, cx - 42, cy - 4)
            guard_path.lineTo(cx - 44, cy)
            guard_path.lineTo(cx - 60, cy)
            guard_path.closeSubpath()
            guard_grad = QtGui.QLinearGradient(cx - 62, cy - 10, cx - 42, cy - 10)
            guard_grad.setColorAt(0, QtGui.QColor("#c9a227"))
            guard_grad.setColorAt(0.5, QtGui.QColor("#daa520"))
            guard_grad.setColorAt(1, QtGui.QColor("#c9a227"))
            painter.setBrush(guard_grad)
            painter.setPen(QtGui.QPen(QtGui.QColor("#8b6914"), 1))
            painter.drawPath(guard_path)
            # Blade with gradient
            blade_grad = QtGui.QLinearGradient(cx - 58, cy - 10, cx - 46, cy - 10)
            blade_grad.setColorAt(0, wc.darker(120))
            blade_grad.setColorAt(0.3, wc.lighter(130))
            blade_grad.setColorAt(0.5, wc)
            blade_grad.setColorAt(0.7, wc.lighter(130))
            blade_grad.setColorAt(1, wc.darker(120))
            blade_path = QtGui.QPainterPath()
            blade_path.moveTo(cx - 58, cy - 10)
            blade_path.lineTo(cx - 46, cy - 10)
            blade_path.lineTo(cx - 52, cy - 60)
            blade_path.closeSubpath()
            painter.setBrush(blade_grad)
            painter.setPen(QtGui.QPen(wc.darker(140), 2))
            painter.drawPath(blade_path)
            # Blade edge highlight
            painter.setPen(QtGui.QPen(wc.lighter(160), 1))
            painter.drawLine(cx - 52, cy - 15, cx - 52, cy - 55)
            # Fuller (blood groove)
            painter.setPen(QtGui.QPen(wc.darker(140), 1))
            painter.drawLine(cx - 54, cy - 15, cx - 53, cy - 45)
            # Blade shine spots
            painter.setBrush(QtGui.QColor(255, 255, 255, 100))
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx - 55, cy - 25, 4, 8)
            # Magical glow for legendary+
            if self.tier in ["legendary", "godlike"]:
                painter.setOpacity(0.3)
                painter.setBrush(wc.lighter(150))
                painter.drawEllipse(cx - 60, cy - 55, 20, 50)
                painter.setOpacity(1.0)

        # === SHIELD ===
        shield = self.equipped.get("Shield")
        if shield:
            sc = QtGui.QColor(shield.get("color", "#666"))
            # Shield gradient for 3D effect
            shield_grad = QtGui.QRadialGradient(cx + 45, cy + 5, 30)
            shield_grad.setColorAt(0, sc.lighter(120))
            shield_grad.setColorAt(0.5, sc)
            shield_grad.setColorAt(1, sc.darker(130))
            # Shield body (heater/kite shape)
            shield_path = QtGui.QPainterPath()
            shield_path.moveTo(cx + 50, cy - 22)
            shield_path.quadTo(cx + 72, cy - 18, cx + 70, cy + 8)
            shield_path.quadTo(cx + 68, cy + 28, cx + 50, cy + 40)
            shield_path.quadTo(cx + 32, cy + 28, cx + 30, cy + 8)
            shield_path.quadTo(cx + 28, cy - 18, cx + 50, cy - 22)
            painter.setBrush(shield_grad)
            painter.setPen(QtGui.QPen(sc.darker(150), 3))
            painter.drawPath(shield_path)
            # Shield rim (metallic border)
            painter.setBrush(QtCore.Qt.NoBrush)
            painter.setPen(QtGui.QPen(sc.darker(130), 4))
            painter.drawPath(shield_path)
            # Inner rim highlight
            painter.setPen(QtGui.QPen(sc.lighter(130), 1))
            inner_path = QtGui.QPainterPath()
            inner_path.moveTo(cx + 50, cy - 18)
            inner_path.quadTo(cx + 66, cy - 14, cx + 64, cy + 6)
            inner_path.quadTo(cx + 62, cy + 24, cx + 50, cy + 34)
            inner_path.quadTo(cx + 38, cy + 24, cx + 36, cy + 6)
            inner_path.quadTo(cx + 34, cy - 14, cx + 50, cy - 18)
            painter.drawPath(inner_path)
            # Shield emblem (stylized cross/pattern)
            painter.setPen(QtGui.QPen(sc.lighter(140), 3))
            painter.drawLine(cx + 50, cy - 12, cx + 50, cy + 28)
            painter.drawLine(cx + 38, cy + 8, cx + 62, cy + 8)
            # Decorative corners
            painter.setPen(QtGui.QPen(sc.lighter(130), 2))
            painter.drawLine(cx + 40, cy - 5, cx + 45, cy)
            painter.drawLine(cx + 60, cy - 5, cx + 55, cy)
            painter.drawLine(cx + 40, cy + 20, cx + 45, cy + 15)
            painter.drawLine(cx + 60, cy + 20, cx + 55, cy + 15)
            # Shield boss (center dome)
            boss_grad = QtGui.QRadialGradient(cx + 48, cy + 6, 10)
            boss_grad.setColorAt(0, sc.lighter(140))
            boss_grad.setColorAt(0.5, sc.darker(110))
            boss_grad.setColorAt(1, sc.darker(140))
            painter.setBrush(boss_grad)
            painter.setPen(QtGui.QPen(sc.darker(150), 1))
            painter.drawEllipse(cx + 43, cy + 1, 14, 14)
            # Boss highlight
            painter.setBrush(QtGui.QColor(255, 255, 255, 80))
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx + 45, cy + 3, 5, 5)
            # Rivets around edge
            painter.setBrush(sc.darker(140))
            painter.setPen(QtGui.QPen(sc.darker(160), 1))
            rivet_positions = [(cx + 50, cy - 16), (cx + 62, cy - 8), (cx + 66, cy + 8),
                              (cx + 60, cy + 26), (cx + 50, cy + 34), (cx + 40, cy + 26),
                              (cx + 34, cy + 8), (cx + 38, cy - 8)]
            for rx, ry in rivet_positions:
                painter.drawEllipse(rx - 2, ry - 2, 4, 4)

        # === POWER LABEL ===
        # Background for label
        label_rect = QtCore.QRect(0, h - 28, w, 25)
        painter.fillRect(label_rect, QtGui.QColor(0, 0, 0, 100))
        
        # Power text color based on tier (no glow loop - causes double-text artifacts)
        if self.tier in ["legendary", "godlike"]:
            painter.setPen(QtGui.QColor("#ffd700"))
        elif self.tier in ["epic"]:
            painter.setPen(QtGui.QColor("#e040fb"))
        elif self.tier in ["heroic"]:
            painter.setPen(QtGui.QColor("#42a5f5"))
        else:
            painter.setPen(QtGui.QColor("#fff"))
        
        # Draw single clean power text
        painter.setFont(QtGui.QFont("Segoe UI", 11, QtGui.QFont.Bold))
        painter.drawText(label_rect, QtCore.Qt.AlignCenter, f"‚öî {self.power}")

    def _draw_scholar_character(self, painter: QtGui.QPainter) -> None:
        """Draw the academic/scholar themed character."""
        # painter = QtGui.QPainter(self)  # Uses passed painter
        painter.setRenderHint(QtGui.QPainter.Antialiasing)

        # Use canonical dimensions for drawing (scaling handled by caller)
        w, h = self.BASE_W, self.BASE_H
        cx, cy = w // 2, h // 2 + 5

        # Background with warm library gradient
        bg_gradient = QtGui.QRadialGradient(cx, cy - 20, max(w, h) * 0.8)
        bg_gradient.setColorAt(0, QtGui.QColor("#3d3529"))
        bg_gradient.setColorAt(0.5, QtGui.QColor("#2a2419"))
        bg_gradient.setColorAt(1, QtGui.QColor("#1a170f"))
        painter.fillRect(0, 0, w, h, bg_gradient)
        
        # Floor/desk shadow
        floor_gradient = QtGui.QLinearGradient(cx - 40, cy + 70, cx + 40, cy + 85)
        floor_gradient.setColorAt(0, QtGui.QColor(0, 0, 0, 30))
        floor_gradient.setColorAt(0.5, QtGui.QColor(0, 0, 0, 80))
        floor_gradient.setColorAt(1, QtGui.QColor(0, 0, 0, 30))
        painter.setBrush(floor_gradient)
        painter.setPen(QtCore.Qt.NoPen)
        painter.drawEllipse(cx - 40, cy + 68, 80, 18)

        body_color = QtGui.QColor(self.TIER_COLORS.get(self.tier, "#bdbdbd"))
        body_outline = QtGui.QColor(self.TIER_OUTLINE.get(self.tier, "#888"))
        glow = self.TIER_GLOW.get(self.tier)

        def darken(color: str, amount: int = 130) -> QtGui.QColor:
            c = QtGui.QColor(color)
            return c.darker(amount)
        
        def lighten(color: str, amount: int = 130) -> QtGui.QColor:
            c = QtGui.QColor(color)
            return c.lighter(amount)

        # Knowledge aura for high tiers (book/scroll particles)
        if glow:
            glow_color = QtGui.QColor(glow)
            painter.setBrush(QtCore.Qt.NoBrush)
            for i, opacity in enumerate([0.1, 0.15, 0.25, 0.35]):
                painter.setOpacity(opacity)
                size = 140 - i * 15
                painter.setPen(QtGui.QPen(glow_color, 3))
                painter.drawEllipse(cx - size//2, cy - 70, size, int(size * 1.2))
            painter.setOpacity(1.0)
            painter.setBrush(glow_color)
            painter.setPen(QtCore.Qt.NoPen)
            painter.setOpacity(0.25)
            painter.drawEllipse(cx - 50, cy - 60, 100, 130)
            painter.setOpacity(1.0)
        
        # Floating knowledge particles (quills, stars, runes)
        particles = self.TIER_PARTICLES.get(self.tier)
        if particles:
            p_color, p_count = particles
            painter.setBrush(QtGui.QColor(p_color))
            painter.setPen(QtCore.Qt.NoPen)
            for i, (px, py, ps) in enumerate(self._particles[:p_count]):
                painter.setOpacity(0.4 + (i % 3) * 0.2)
                # Draw small book/star shapes instead of circles
                if i % 2 == 0:
                    painter.drawRect(cx + px, cy + py, ps + 2, ps)  # Small book
                else:
                    painter.drawEllipse(cx + px, cy + py, ps, ps)  # Star
            painter.setOpacity(1.0)

        # === CLOAK/MANTLE (Academic Robe back) ===
        cloak = self.equipped.get("Cloak")
        if cloak:
            cc = QtGui.QColor(cloak.get("color", "#4a0080"))
            path = QtGui.QPainterPath()
            path.moveTo(cx - 24, cy - 28)
            path.lineTo(cx + 24, cy - 28)
            path.cubicTo(cx + 36, cy, cx + 38, cy + 40, cx + 32, cy + 72)
            path.quadTo(cx + 15, cy + 75, cx, cy + 73)
            path.quadTo(cx - 15, cy + 75, cx - 32, cy + 72)
            path.cubicTo(cx - 38, cy + 40, cx - 36, cy, cx - 24, cy - 28)
            cloak_gradient = QtGui.QLinearGradient(cx - 35, cy, cx + 35, cy)
            cloak_gradient.setColorAt(0, darken(cloak.get("color", "#4a0080"), 140))
            cloak_gradient.setColorAt(0.3, cc)
            cloak_gradient.setColorAt(0.7, cc)
            cloak_gradient.setColorAt(1, darken(cloak.get("color", "#4a0080"), 120))
            painter.setBrush(cloak_gradient)
            painter.setPen(QtGui.QPen(darken(cloak.get("color", "#4a0080"), 150), 2))
            painter.drawPath(path)
            # Robe folds
            painter.setPen(QtGui.QPen(darken(cloak.get("color", "#4a0080"), 160), 1))
            painter.drawLine(cx - 15, cy - 20, cx - 18, cy + 65)
            painter.drawLine(cx + 15, cy - 20, cx + 18, cy + 65)
            painter.drawLine(cx, cy - 15, cx, cy + 68)
            # Academic hood/collar
            painter.setBrush(QtGui.QColor("#f5f5dc"))  # Cream colored lining
            painter.setPen(QtGui.QPen(QtGui.QColor("#d4c8a0"), 1))
            hood_path = QtGui.QPainterPath()
            hood_path.moveTo(cx - 20, cy - 28)
            hood_path.quadTo(cx - 22, cy - 20, cx - 18, cy - 15)
            hood_path.lineTo(cx + 18, cy - 15)
            hood_path.quadTo(cx + 22, cy - 20, cx + 20, cy - 28)
            painter.drawPath(hood_path)

        # === LEGS (hidden by robe, just shoes visible) ===
        # Robe covers most of legs, draw minimal legs
        robe_grad = QtGui.QLinearGradient(cx - 25, cy + 25, cx + 25, cy + 25)
        chestplate = self.equipped.get("Chestplate")
        if chestplate and isinstance(chestplate, dict):
            robe_color = QtGui.QColor(chestplate.get("color", "#1a1a4a"))
        else:
            robe_color = QtGui.QColor("#1a1a4a")
        robe_grad.setColorAt(0, robe_color.darker(120))
        robe_grad.setColorAt(0.5, robe_color)
        robe_grad.setColorAt(1, robe_color.darker(120))
        painter.setBrush(robe_grad)
        painter.setPen(QtGui.QPen(robe_color.darker(150), 2))
        # Long robe bottom
        robe_path = QtGui.QPainterPath()
        robe_path.moveTo(cx - 23, cy + 20)
        robe_path.lineTo(cx + 23, cy + 20)
        robe_path.lineTo(cx + 28, cy + 65)
        robe_path.quadTo(cx, cy + 68, cx - 28, cy + 65)
        robe_path.closeSubpath()
        painter.drawPath(robe_path)

        # === BOOTS/FOOTWEAR (Scholar's shoes/slippers) ===
        boots = self.equipped.get("Boots")
        if boots:
            bc = QtGui.QColor(boots.get("color", "#4a3728"))
            boot_grad = QtGui.QLinearGradient(0, cy + 60, 0, cy + 75)
            boot_grad.setColorAt(0, bc.lighter(110))
            boot_grad.setColorAt(0.5, bc)
            boot_grad.setColorAt(1, bc.darker(120))
            painter.setBrush(boot_grad)
            painter.setPen(QtGui.QPen(bc.darker(140), 2))
            # Left shoe (oxford style)
            left_shoe = QtGui.QPainterPath()
            left_shoe.moveTo(cx - 18, cy + 60)
            left_shoe.lineTo(cx - 4, cy + 60)
            left_shoe.quadTo(cx - 2, cy + 68, cx - 6, cy + 72)
            left_shoe.quadTo(cx - 14, cy + 74, cx - 18, cy + 70)
            left_shoe.closeSubpath()
            painter.drawPath(left_shoe)
            # Right shoe
            right_shoe = QtGui.QPainterPath()
            right_shoe.moveTo(cx + 4, cy + 60)
            right_shoe.lineTo(cx + 18, cy + 60)
            right_shoe.lineTo(cx + 18, cy + 70)
            right_shoe.quadTo(cx + 14, cy + 74, cx + 6, cy + 72)
            right_shoe.quadTo(cx + 2, cy + 68, cx + 4, cy + 60)
            painter.drawPath(right_shoe)
            # Shoe laces
            painter.setPen(QtGui.QPen(bc.darker(150), 1))
            painter.drawLine(cx - 14, cy + 62, cx - 8, cy + 62)
            painter.drawLine(cx + 8, cy + 62, cx + 14, cy + 62)
        else:
            # Simple slippers
            painter.setBrush(QtGui.QColor("#5d4037"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#4e342e"), 1))
            painter.drawRoundedRect(cx - 16, cy + 62, 12, 10, 3, 3)
            painter.drawRoundedRect(cx + 4, cy + 62, 12, 10, 3, 3)

        # === ARMS (Robe sleeves) ===
        arm_color = robe_color if self.equipped.get("Chestplate") else QtGui.QColor("#1a1a4a")
        arm_grad_l = QtGui.QLinearGradient(cx - 42, cy - 5, cx - 28, cy - 5)
        arm_grad_l.setColorAt(0, arm_color.darker(125))
        arm_grad_l.setColorAt(0.4, arm_color)
        arm_grad_l.setColorAt(1, arm_color.darker(110))
        painter.setBrush(arm_grad_l)
        painter.setPen(QtGui.QPen(arm_color.darker(150), 2))
        # Wide robe sleeves
        arm_path_l = QtGui.QPainterPath()
        arm_path_l.moveTo(cx - 26, cy - 24)
        arm_path_l.quadTo(cx - 34, cy - 26, cx - 40, cy - 18)
        arm_path_l.quadTo(cx - 48, cy + 5, cx - 48, cy + 22)
        arm_path_l.lineTo(cx - 30, cy + 18)
        arm_path_l.quadTo(cx - 28, cy - 5, cx - 26, cy - 24)
        painter.drawPath(arm_path_l)
        # Right sleeve
        arm_grad_r = QtGui.QLinearGradient(cx + 28, cy - 5, cx + 42, cy - 5)
        arm_grad_r.setColorAt(0, arm_color.darker(110))
        arm_grad_r.setColorAt(0.6, arm_color)
        arm_grad_r.setColorAt(1, arm_color.darker(125))
        painter.setBrush(arm_grad_r)
        arm_path_r = QtGui.QPainterPath()
        arm_path_r.moveTo(cx + 26, cy - 24)
        arm_path_r.quadTo(cx + 34, cy - 26, cx + 40, cy - 18)
        arm_path_r.quadTo(cx + 48, cy + 5, cx + 48, cy + 22)
        arm_path_r.lineTo(cx + 30, cy + 18)
        arm_path_r.quadTo(cx + 28, cy - 5, cx + 26, cy - 24)
        painter.drawPath(arm_path_r)

        # === GAUNTLETS (Writing Gloves / Ink-stained Gloves) ===
        gaunt = self.equipped.get("Gauntlets")
        if gaunt:
            gc = QtGui.QColor(gaunt.get("color", "#f5f5dc"))
            gaunt_grad = QtGui.QLinearGradient(0, cy + 10, 0, cy + 28)
            gaunt_grad.setColorAt(0, gc.lighter(115))
            gaunt_grad.setColorAt(0.5, gc)
            gaunt_grad.setColorAt(1, gc.darker(110))
            painter.setBrush(gaunt_grad)
            painter.setPen(QtGui.QPen(gc.darker(130), 1))
            # Left glove - elegant writing glove
            painter.drawRoundedRect(cx - 48, cy + 12, 20, 20, 4, 4)
            # Ink stains for high tiers
            if self.tier in ["heroic", "epic", "legendary", "godlike"]:
                painter.setBrush(QtGui.QColor("#1a237e"))
                painter.setPen(QtCore.Qt.NoPen)
                painter.drawEllipse(cx - 44, cy + 18, 4, 4)
                painter.drawEllipse(cx - 38, cy + 22, 3, 3)
            # Right glove
            painter.setBrush(gaunt_grad)
            painter.setPen(QtGui.QPen(gc.darker(130), 1))
            painter.drawRoundedRect(cx + 28, cy + 12, 20, 20, 4, 4)
            if self.tier in ["heroic", "epic", "legendary", "godlike"]:
                painter.setBrush(QtGui.QColor("#1a237e"))
                painter.setPen(QtCore.Qt.NoPen)
                painter.drawEllipse(cx + 40, cy + 16, 3, 4)
        else:
            # Bare hands
            painter.setBrush(QtGui.QColor("#ffcc80"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#e6a84d"), 1))
            painter.drawEllipse(cx - 46, cy + 14, 14, 14)
            painter.drawEllipse(cx + 32, cy + 14, 14, 14)
            # Fingers
            painter.setBrush(QtGui.QColor("#f5c07a"))
            for i in range(4):
                painter.drawEllipse(cx - 46 + i * 3, cy + 25, 3, 5)
                painter.drawEllipse(cx + 32 + i * 3, cy + 25, 3, 5)

        # === TORSO/ROBE ===
        torso_grad = QtGui.QLinearGradient(cx - 25, cy, cx + 25, cy)
        torso_grad.setColorAt(0, robe_color.darker(115))
        torso_grad.setColorAt(0.3, robe_color)
        torso_grad.setColorAt(0.7, robe_color)
        torso_grad.setColorAt(1, robe_color.darker(115))
        painter.setBrush(torso_grad)
        painter.setPen(QtGui.QPen(robe_color.darker(150), 2))
        torso_path = QtGui.QPainterPath()
        torso_path.moveTo(cx - 26, cy - 28)
        torso_path.quadTo(cx - 28, cy - 5, cx - 23, cy + 25)
        torso_path.lineTo(cx + 23, cy + 25)
        torso_path.quadTo(cx + 28, cy - 5, cx + 26, cy - 28)
        torso_path.closeSubpath()
        painter.drawPath(torso_path)

        # === CHESTPLATE (Academic Vest/Cardigan) ===
        chest = self.equipped.get("Chestplate")
        if chest:
            cc = QtGui.QColor(chest.get("color", "#2d2d5a"))
            chest_grad = QtGui.QLinearGradient(cx - 20, cy, cx + 20, cy)
            chest_grad.setColorAt(0, cc.darker(120))
            chest_grad.setColorAt(0.3, cc)
            chest_grad.setColorAt(0.7, cc)
            chest_grad.setColorAt(1, cc.darker(120))
            painter.setBrush(chest_grad)
            painter.setPen(QtGui.QPen(cc.darker(140), 2))
            # Vest/cardigan shape
            vest_path = QtGui.QPainterPath()
            vest_path.moveTo(cx - 22, cy - 26)
            vest_path.lineTo(cx + 22, cy - 26)
            vest_path.lineTo(cx + 18, cy + 18)
            vest_path.lineTo(cx - 18, cy + 18)
            vest_path.closeSubpath()
            painter.drawPath(vest_path)
            # Center buttons
            painter.setBrush(QtGui.QColor("#b8860b"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#8b6914"), 1))
            for i in range(4):
                painter.drawEllipse(cx - 2, cy - 20 + i * 10, 4, 4)
            # Lapels
            painter.setPen(QtGui.QPen(cc.darker(150), 2))
            painter.drawLine(cx - 8, cy - 24, cx - 12, cy + 10)
            painter.drawLine(cx + 8, cy - 24, cx + 12, cy + 10)
            # Pocket with handkerchief for high tiers
            if self.tier in ["epic", "legendary", "godlike"]:
                painter.setBrush(QtGui.QColor("#fff"))
                painter.setPen(QtGui.QPen(QtGui.QColor("#ddd"), 1))
                pocket_path = QtGui.QPainterPath()
                pocket_path.moveTo(cx + 8, cy - 8)
                pocket_path.lineTo(cx + 16, cy - 10)
                pocket_path.lineTo(cx + 14, cy - 2)
                pocket_path.lineTo(cx + 10, cy)
                pocket_path.closeSubpath()
                painter.drawPath(pocket_path)
        else:
            # Simple robe lines
            painter.setPen(QtGui.QPen(robe_color.darker(140), 1))
            painter.drawLine(cx, cy - 25, cx, cy + 18)
            painter.drawLine(cx - 10, cy - 26, cx, cy - 20)
            painter.drawLine(cx + 10, cy - 26, cx, cy - 20)

        # === NECK ===
        neck_grad = QtGui.QLinearGradient(cx - 8, cy - 35, cx + 8, cy - 35)
        neck_grad.setColorAt(0, QtGui.QColor("#e6b980"))
        neck_grad.setColorAt(0.5, QtGui.QColor("#ffcc80"))
        neck_grad.setColorAt(1, QtGui.QColor("#e6b980"))
        painter.setBrush(neck_grad)
        painter.setPen(QtGui.QPen(QtGui.QColor("#d4943a"), 1))
        painter.drawRect(cx - 9, cy - 36, 18, 12)

        # === HEAD ===
        head_gradient = QtGui.QRadialGradient(cx - 5, cy - 55, 30)
        head_gradient.setColorAt(0, QtGui.QColor("#ffe8c8"))
        head_gradient.setColorAt(0.5, QtGui.QColor("#ffcc80"))
        head_gradient.setColorAt(0.8, QtGui.QColor("#e6a84d"))
        head_gradient.setColorAt(1, QtGui.QColor("#d4943a"))
        painter.setBrush(head_gradient)
        painter.setPen(QtGui.QPen(QtGui.QColor("#c9843a"), 2))
        head_path = QtGui.QPainterPath()
        head_path.moveTo(cx - 2, cy - 32)
        head_path.quadTo(cx - 22, cy - 35, cx - 22, cy - 52)
        head_path.quadTo(cx - 22, cy - 72, cx, cy - 72)
        head_path.quadTo(cx + 22, cy - 72, cx + 22, cy - 52)
        head_path.quadTo(cx + 22, cy - 35, cx + 2, cy - 32)
        head_path.closeSubpath()
        painter.drawPath(head_path)

        # === HELMET (Thinking Cap / Mortarboard / Glasses) ===
        helm = self.equipped.get("Helmet")
        if helm:
            hc = QtGui.QColor(helm.get("color", "#1a1a4a"))
            # Mortarboard cap
            # Cap base
            painter.setBrush(hc)
            painter.setPen(QtGui.QPen(hc.darker(140), 2))
            painter.drawEllipse(cx - 18, cy - 70, 36, 12)
            # Flat top board
            board_path = QtGui.QPainterPath()
            board_path.moveTo(cx - 24, cy - 78)
            board_path.lineTo(cx + 24, cy - 78)
            board_path.lineTo(cx + 28, cy - 72)
            board_path.lineTo(cx - 28, cy - 72)
            board_path.closeSubpath()
            painter.setBrush(hc)
            painter.drawPath(board_path)
            # Tassel
            painter.setPen(QtGui.QPen(QtGui.QColor("#ffd700"), 2))
            painter.drawLine(cx + 20, cy - 76, cx + 28, cy - 62)
            # Tassel end
            painter.setBrush(QtGui.QColor("#ffd700"))
            painter.setPen(QtCore.Qt.NoPen)
            for i in range(5):
                painter.drawLine(cx + 28 - i, cy - 62, cx + 26 - i, cy - 54)
        else:
            # Hair
            hair_color = QtGui.QColor("#5d4037")
            hair_grad = QtGui.QRadialGradient(cx, cy - 68, 22)
            hair_grad.setColorAt(0, hair_color.lighter(120))
            hair_grad.setColorAt(0.6, hair_color)
            hair_grad.setColorAt(1, hair_color.darker(130))
            painter.setBrush(hair_grad)
            painter.setPen(QtCore.Qt.NoPen)
            hair_path = QtGui.QPainterPath()
            hair_path.moveTo(cx - 20, cy - 60)
            hair_path.quadTo(cx - 24, cy - 68, cx - 18, cy - 74)
            hair_path.quadTo(cx - 8, cy - 80, cx, cy - 79)
            hair_path.quadTo(cx + 8, cy - 80, cx + 18, cy - 74)
            hair_path.quadTo(cx + 24, cy - 68, cx + 20, cy - 60)
            hair_path.closeSubpath()
            painter.drawPath(hair_path)
            # Hair texture
            painter.setPen(QtGui.QPen(QtGui.QColor("#4e342e"), 1))
            painter.drawLine(cx - 12, cy - 72, cx - 10, cy - 64)
            painter.drawLine(cx, cy - 78, cx, cy - 68)
            painter.drawLine(cx + 12, cy - 72, cx + 10, cy - 64)
            # Side tufts
            painter.setBrush(hair_color)
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx - 23, cy - 62, 6, 8)
            painter.drawEllipse(cx + 17, cy - 62, 6, 8)

        # === FACE ===
        # Eyebrows (scholarly, thoughtful)
        painter.setPen(QtGui.QPen(QtGui.QColor("#4e342e"), 2))
        if self.tier in ["legendary", "godlike"]:
            # Raised knowing brows
            painter.drawLine(cx - 13, cy - 60, cx - 5, cy - 57)
            painter.drawLine(cx + 5, cy - 57, cx + 13, cy - 60)
        else:
            # Focused/thinking
            painter.drawLine(cx - 12, cy - 58, cx - 5, cy - 59)
            painter.drawLine(cx + 5, cy - 59, cx + 12, cy - 58)
        
        # Eyes
        painter.setBrush(QtGui.QColor("#e8c090"))
        painter.setPen(QtCore.Qt.NoPen)
        painter.drawEllipse(cx - 13, cy - 56, 12, 10)
        painter.drawEllipse(cx + 1, cy - 56, 12, 10)
        painter.setBrush(QtGui.QColor("#fff"))
        painter.drawEllipse(cx - 12, cy - 55, 10, 9)
        painter.drawEllipse(cx + 2, cy - 55, 10, 9)
        # Iris
        iris_colors = {
            "pathetic": "#6b5b4f", "modest": "#4a5a6f", "decent": "#3a5a7a",
            "heroic": "#2a4a7a", "epic": "#5a3a7a", "legendary": "#7a5a2a", "godlike": "#4a6a3a"
        }
        iris_color = QtGui.QColor(iris_colors.get(self.tier, "#5a5a5a"))
        painter.setBrush(iris_color)
        painter.drawEllipse(cx - 9, cy - 53, 6, 6)
        painter.drawEllipse(cx + 4, cy - 53, 6, 6)
        painter.setBrush(QtGui.QColor("#1a1a1a"))
        painter.drawEllipse(cx - 7, cy - 51, 3, 3)
        painter.drawEllipse(cx + 6, cy - 51, 3, 3)
        # Eye shine
        painter.setBrush(QtGui.QColor("#fff"))
        painter.drawEllipse(cx - 8, cy - 52, 2, 2)
        painter.drawEllipse(cx + 5, cy - 52, 2, 2)

        # Glasses (always for scholars, even without helmet)
        painter.setBrush(QtCore.Qt.NoBrush)
        glasses_color = QtGui.QColor("#8b7355") if not helm else QtGui.QColor(helm.get("color", "#8b7355")).darker(110)
        painter.setPen(QtGui.QPen(glasses_color, 2))
        # Left lens (round)
        painter.drawEllipse(cx - 15, cy - 57, 14, 12)
        # Right lens
        painter.drawEllipse(cx + 1, cy - 57, 14, 12)
        # Bridge
        painter.drawLine(cx - 1, cy - 52, cx + 1, cy - 52)
        # Temple arms
        painter.drawLine(cx - 15, cy - 52, cx - 22, cy - 54)
        painter.drawLine(cx + 15, cy - 52, cx + 22, cy - 54)
        # Lens shine
        painter.setPen(QtGui.QPen(QtGui.QColor(255, 255, 255, 80), 1))
        painter.drawArc(cx - 13, cy - 55, 8, 6, 45 * 16, 90 * 16)
        painter.drawArc(cx + 3, cy - 55, 8, 6, 45 * 16, 90 * 16)

        # Nose
        painter.setPen(QtGui.QPen(QtGui.QColor("#d4943a"), 1))
        painter.drawLine(cx, cy - 48, cx - 1, cy - 42)
        painter.drawArc(cx - 4, cy - 42, 4, 3, 180 * 16, 180 * 16)
        painter.drawArc(cx, cy - 42, 4, 3, 180 * 16, 180 * 16)

        # Mouth (scholarly expressions)
        painter.setPen(QtGui.QPen(QtGui.QColor("#a05a3a"), 2))
        if self.tier in ["legendary", "godlike"]:
            # Wise knowing smile
            painter.drawArc(cx - 8, cy - 44, 16, 10, 210 * 16, 120 * 16)
        elif self.tier in ["epic", "heroic"]:
            # Slight satisfied smile
            painter.drawArc(cx - 7, cy - 42, 14, 6, 220 * 16, 100 * 16)
        else:
            # Focused/neutral
            painter.drawLine(cx - 5, cy - 38, cx + 5, cy - 38)

        # Ears
        painter.setBrush(QtGui.QColor("#ffcc80"))
        painter.setPen(QtGui.QPen(QtGui.QColor("#d4943a"), 1))
        painter.drawEllipse(cx - 24, cy - 52, 5, 9)
        painter.drawEllipse(cx + 19, cy - 52, 5, 9)

        # === AMULET (Scholar's Medal/Pocket Watch) ===
        amulet = self.equipped.get("Amulet")
        if amulet:
            ac = QtGui.QColor(amulet.get("color", "#4fc3f7"))
            # Chain
            painter.setPen(QtGui.QPen(QtGui.QColor("#b8860b"), 2))
            for i in range(3):
                painter.drawEllipse(cx - 10 + i * 3, cy - 26 + i * 3, 3, 3)
                painter.drawEllipse(cx + 7 - i * 3, cy - 26 + i * 3, 3, 3)
            # Medal/Pocket watch body
            painter.setBrush(QtGui.QColor("#daa520"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#b8860b"), 2))
            painter.drawEllipse(cx - 10, cy - 16, 20, 20)
            # Inner crystal/gem
            gem_grad = QtGui.QRadialGradient(cx - 2, cy - 8, 8)
            gem_grad.setColorAt(0, ac.lighter(150))
            gem_grad.setColorAt(0.5, ac)
            gem_grad.setColorAt(1, ac.darker(130))
            painter.setBrush(gem_grad)
            painter.setPen(QtGui.QPen(ac.darker(140), 1))
            painter.drawEllipse(cx - 7, cy - 13, 14, 14)
            # Watch hands / crystal facets
            if self.tier in ["epic", "legendary", "godlike"]:
                painter.setPen(QtGui.QPen(ac.lighter(170), 1))
                painter.drawLine(cx, cy - 10, cx, cy - 4)
                painter.drawLine(cx - 3, cy - 6, cx + 3, cy - 6)
            # Shine
            painter.setBrush(QtGui.QColor(255, 255, 255, 150))
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx - 4, cy - 11, 4, 4)

        # === WEAPON (Quill/Fountain Pen/Pointer) ===
        weap = self.equipped.get("Weapon")
        if weap:
            wc = QtGui.QColor(weap.get("color", "#1a237e"))
            # Quill pen
            # Feather body
            feather_path = QtGui.QPainterPath()
            feather_path.moveTo(cx - 58, cy + 25)
            feather_path.quadTo(cx - 65, cy - 5, cx - 55, cy - 45)
            feather_path.quadTo(cx - 50, cy - 55, cx - 48, cy - 60)
            feather_path.quadTo(cx - 52, cy - 50, cx - 52, cy - 40)
            feather_path.quadTo(cx - 55, cy - 5, cx - 48, cy + 25)
            feather_path.closeSubpath()
            feather_grad = QtGui.QLinearGradient(cx - 60, cy - 30, cx - 48, cy - 30)
            feather_grad.setColorAt(0, wc.lighter(130))
            feather_grad.setColorAt(0.5, wc)
            feather_grad.setColorAt(1, wc.darker(110))
            painter.setBrush(feather_grad)
            painter.setPen(QtGui.QPen(wc.darker(140), 1))
            painter.drawPath(feather_path)
            # Feather barbs/details
            painter.setPen(QtGui.QPen(wc.darker(130), 1))
            for i in range(6):
                y_pos = cy - 45 + i * 10
                painter.drawLine(cx - 56, y_pos, cx - 50, y_pos - 3)
            # Quill shaft
            painter.setPen(QtGui.QPen(QtGui.QColor("#f5f5dc"), 2))
            painter.drawLine(cx - 53, cy - 40, cx - 53, cy + 30)
            # Quill tip (nib)
            painter.setBrush(QtGui.QColor("#b8860b"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#8b6914"), 1))
            nib_path = QtGui.QPainterPath()
            nib_path.moveTo(cx - 55, cy + 25)
            nib_path.lineTo(cx - 53, cy + 38)
            nib_path.lineTo(cx - 51, cy + 25)
            nib_path.closeSubpath()
            painter.drawPath(nib_path)
            # Ink drip for high tiers
            if self.tier in ["legendary", "godlike"]:
                painter.setBrush(QtGui.QColor("#1a237e"))
                painter.setPen(QtCore.Qt.NoPen)
                painter.drawEllipse(cx - 55, cy + 36, 4, 6)

        # === SHIELD (Tome/Book/Encyclopedia) ===
        shield = self.equipped.get("Shield")
        if shield:
            sc = QtGui.QColor(shield.get("color", "#8d6e63"))
            # Book body
            book_grad = QtGui.QRadialGradient(cx + 48, cy + 8, 25)
            book_grad.setColorAt(0, sc.lighter(115))
            book_grad.setColorAt(0.5, sc)
            book_grad.setColorAt(1, sc.darker(130))
            # Book cover
            book_path = QtGui.QPainterPath()
            book_path.moveTo(cx + 32, cy - 18)
            book_path.lineTo(cx + 68, cy - 18)
            book_path.lineTo(cx + 68, cy + 35)
            book_path.lineTo(cx + 32, cy + 35)
            book_path.closeSubpath()
            painter.setBrush(book_grad)
            painter.setPen(QtGui.QPen(sc.darker(150), 3))
            painter.drawPath(book_path)
            # Book spine
            painter.setBrush(sc.darker(120))
            painter.drawRect(cx + 30, cy - 18, 5, 53)
            # Pages (white edge)
            painter.setBrush(QtGui.QColor("#fffef0"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#e0dcc8"), 1))
            painter.drawRect(cx + 35, cy - 15, 30, 47)
            # Page lines
            painter.setPen(QtGui.QPen(QtGui.QColor("#ccc"), 1))
            for i in range(8):
                painter.drawLine(cx + 38, cy - 10 + i * 6, cx + 62, cy - 10 + i * 6)
            # Cover decoration
            painter.setPen(QtGui.QPen(QtGui.QColor("#daa520"), 2))
            painter.drawRect(cx + 40, cy - 12, 20, 25)
            # Mystical symbol for high tiers
            if self.tier in ["epic", "legendary", "godlike"]:
                painter.setBrush(QtGui.QColor("#daa520"))
                painter.setPen(QtCore.Qt.NoPen)
                # Star symbol
                painter.drawEllipse(cx + 47, cy - 3, 8, 8)
                painter.setPen(QtGui.QPen(QtGui.QColor("#daa520"), 2))
                painter.drawLine(cx + 51, cy - 8, cx + 51, cy + 10)
                painter.drawLine(cx + 44, cy + 1, cx + 58, cy + 1)
            # Bookmark ribbon
            painter.setPen(QtGui.QPen(QtGui.QColor("#c62828"), 2))
            painter.drawLine(cx + 55, cy - 18, cx + 58, cy + 38)

        # === POWER LABEL ===
        label_rect = QtCore.QRect(0, h - 28, w, 25)
        painter.fillRect(label_rect, QtGui.QColor(0, 0, 0, 100))
        
        # Power text color based on tier (no glow loop - causes double-text artifacts)
        if self.tier in ["legendary", "godlike"]:
            painter.setPen(QtGui.QColor("#ffd700"))
        elif self.tier in ["epic"]:
            painter.setPen(QtGui.QColor("#e040fb"))
        elif self.tier in ["heroic"]:
            painter.setPen(QtGui.QColor("#42a5f5"))
        else:
            painter.setPen(QtGui.QColor("#fff"))
        
        # Draw single clean power text
        painter.setFont(QtGui.QFont("Segoe UI", 11, QtGui.QFont.Bold))
        painter.drawText(label_rect, QtCore.Qt.AlignCenter, f"üìö {self.power}")

    def _draw_wanderer_character(self, painter: QtGui.QPainter) -> None:
        """Draw the mystical/dreamweaver themed character."""
        # painter = QtGui.QPainter(self)  # Uses passed painter
        painter.setRenderHint(QtGui.QPainter.Antialiasing)

        # Use canonical dimensions for drawing (scaling handled by caller)
        w, h = self.BASE_W, self.BASE_H
        cx, cy = w // 2, h // 2 + 5

        # Background with mystical night sky gradient
        bg_gradient = QtGui.QRadialGradient(cx, cy - 40, max(w, h) * 0.9)
        bg_gradient.setColorAt(0, QtGui.QColor("#1a1a3a"))
        bg_gradient.setColorAt(0.4, QtGui.QColor("#0d0d2b"))
        bg_gradient.setColorAt(0.7, QtGui.QColor("#05051a"))
        bg_gradient.setColorAt(1, QtGui.QColor("#000010"))
        painter.fillRect(0, 0, w, h, bg_gradient)
        
        # Tiny stars in background
        painter.setBrush(QtGui.QColor(255, 255, 255, 180))
        painter.setPen(QtCore.Qt.NoPen)
        import random
        rng = random.Random(self.power + 999)
        for _ in range(12):
            sx, sy = rng.randint(5, w-5), rng.randint(5, int(h * 0.7))
            painter.drawEllipse(sx, sy, 2, 2)
        
        # Floor/mist
        floor_gradient = QtGui.QLinearGradient(cx - 45, cy + 65, cx + 45, cy + 80)
        floor_gradient.setColorAt(0, QtGui.QColor(100, 100, 180, 20))
        floor_gradient.setColorAt(0.5, QtGui.QColor(150, 150, 220, 60))
        floor_gradient.setColorAt(1, QtGui.QColor(100, 100, 180, 20))
        painter.setBrush(floor_gradient)
        painter.setPen(QtCore.Qt.NoPen)
        painter.drawEllipse(cx - 45, cy + 65, 90, 20)

        body_color = QtGui.QColor(self.TIER_COLORS.get(self.tier, "#bdbdbd"))
        body_outline = QtGui.QColor(self.TIER_OUTLINE.get(self.tier, "#888"))
        glow = self.TIER_GLOW.get(self.tier)

        def darken(color: str, amount: int = 130) -> QtGui.QColor:
            c = QtGui.QColor(color)
            return c.darker(amount)
        
        def lighten(color: str, amount: int = 130) -> QtGui.QColor:
            c = QtGui.QColor(color)
            return c.lighter(amount)

        # Mystical aura for high tiers
        if glow:
            glow_color = QtGui.QColor(glow)
            painter.setBrush(QtCore.Qt.NoBrush)
            for i, opacity in enumerate([0.08, 0.12, 0.2, 0.3]):
                painter.setOpacity(opacity)
                size = 150 - i * 18
                painter.setPen(QtGui.QPen(glow_color, 2))
                painter.drawEllipse(cx - size//2, cy - 75, size, int(size * 1.2))
            painter.setOpacity(1.0)
            # Inner glow
            painter.setBrush(glow_color)
            painter.setPen(QtCore.Qt.NoPen)
            painter.setOpacity(0.2)
            painter.drawEllipse(cx - 55, cy - 65, 110, 140)
            painter.setOpacity(1.0)
        
        # Floating star/moon particles
        particles = self.TIER_PARTICLES.get(self.tier)
        if particles:
            p_color, p_count = particles
            for i, (px, py, ps) in enumerate(self._particles[:p_count]):
                painter.setOpacity(0.5 + (i % 3) * 0.15)
                # Draw crescent moons and stars
                if i % 3 == 0:
                    # Star
                    painter.setBrush(QtGui.QColor(p_color))
                    painter.setPen(QtCore.Qt.NoPen)
                    star_path = QtGui.QPainterPath()
                    star_cx, star_cy = cx + px, cy + py
                    star_path.moveTo(star_cx, star_cy - ps)
                    star_path.lineTo(star_cx + ps//3, star_cy - ps//3)
                    star_path.lineTo(star_cx + ps, star_cy)
                    star_path.lineTo(star_cx + ps//3, star_cy + ps//3)
                    star_path.lineTo(star_cx, star_cy + ps)
                    star_path.lineTo(star_cx - ps//3, star_cy + ps//3)
                    star_path.lineTo(star_cx - ps, star_cy)
                    star_path.lineTo(star_cx - ps//3, star_cy - ps//3)
                    star_path.closeSubpath()
                    painter.drawPath(star_path)
                else:
                    # Moon crescent
                    painter.setBrush(QtGui.QColor(p_color))
                    painter.setPen(QtCore.Qt.NoPen)
                    painter.drawEllipse(cx + px, cy + py, ps + 1, ps + 1)
            painter.setOpacity(1.0)

        # === CLOAK/SHROUD (Flowing star-cloth) ===
        cloak = self.equipped.get("Cloak")
        if cloak:
            cc = QtGui.QColor(cloak.get("color", "#1a1a4a"))
            path = QtGui.QPainterPath()
            path.moveTo(cx - 24, cy - 28)
            path.lineTo(cx + 24, cy - 28)
            path.cubicTo(cx + 40, cy + 5, cx + 45, cy + 45, cx + 38, cy + 75)
            path.quadTo(cx + 18, cy + 80, cx, cy + 78)
            path.quadTo(cx - 18, cy + 80, cx - 38, cy + 75)
            path.cubicTo(cx - 45, cy + 45, cx - 40, cy + 5, cx - 24, cy - 28)
            cloak_gradient = QtGui.QLinearGradient(cx, cy - 30, cx, cy + 75)
            cloak_gradient.setColorAt(0, cc.lighter(110))
            cloak_gradient.setColorAt(0.5, cc)
            cloak_gradient.setColorAt(1, darken(cloak.get("color", "#1a1a4a"), 130))
            painter.setBrush(cloak_gradient)
            painter.setPen(QtGui.QPen(darken(cloak.get("color", "#1a1a4a"), 150), 2))
            painter.drawPath(path)
            # Star pattern on cloak
            painter.setBrush(QtGui.QColor(255, 255, 200, 100))
            painter.setPen(QtCore.Qt.NoPen)
            cloak_stars = [(cx - 20, cy + 15), (cx + 15, cy + 25), (cx - 8, cy + 45),
                          (cx + 22, cy + 50), (cx - 25, cy + 60), (cx + 8, cy + 65)]
            for sx, sy in cloak_stars:
                painter.drawEllipse(sx, sy, 3, 3)
            # Cloak folds with shimmer
            painter.setPen(QtGui.QPen(cc.lighter(120), 1))
            painter.drawLine(cx - 18, cy - 15, cx - 25, cy + 70)
            painter.drawLine(cx + 18, cy - 15, cx + 25, cy + 70)
            painter.drawLine(cx, cy - 10, cx, cy + 72)

        # === LEGS (hidden by flowing robes) ===
        chestplate = self.equipped.get("Chestplate")
        if chestplate and isinstance(chestplate, dict):
            robe_color = QtGui.QColor(chestplate.get("color", "#2a2a5a"))
        else:
            robe_color = QtGui.QColor("#2a2a5a")
        robe_grad = QtGui.QLinearGradient(cx - 25, cy + 25, cx + 25, cy + 25)
        robe_grad.setColorAt(0, robe_color.darker(120))
        robe_grad.setColorAt(0.5, robe_color)
        robe_grad.setColorAt(1, robe_color.darker(120))
        painter.setBrush(robe_grad)
        painter.setPen(QtGui.QPen(robe_color.darker(150), 2))
        robe_path = QtGui.QPainterPath()
        robe_path.moveTo(cx - 22, cy + 22)
        robe_path.lineTo(cx + 22, cy + 22)
        robe_path.quadTo(cx + 28, cy + 50, cx + 25, cy + 68)
        robe_path.quadTo(cx, cy + 72, cx - 25, cy + 68)
        robe_path.quadTo(cx - 28, cy + 50, cx - 22, cy + 22)
        painter.drawPath(robe_path)

        # === BOOTS/TREADS (Cloud Walkers/Star Treads) ===
        boots = self.equipped.get("Boots")
        if boots:
            bc = QtGui.QColor(boots.get("color", "#3a3a6a"))
            boot_grad = QtGui.QLinearGradient(0, cy + 60, 0, cy + 78)
            boot_grad.setColorAt(0, bc.lighter(120))
            boot_grad.setColorAt(0.5, bc)
            boot_grad.setColorAt(1, bc.darker(120))
            painter.setBrush(boot_grad)
            painter.setPen(QtGui.QPen(bc.darker(140), 2))
            # Left boot - ethereal curved design
            left_boot = QtGui.QPainterPath()
            left_boot.moveTo(cx - 20, cy + 62)
            left_boot.quadTo(cx - 22, cy + 70, cx - 18, cy + 76)
            left_boot.quadTo(cx - 10, cy + 78, cx - 4, cy + 74)
            left_boot.lineTo(cx - 4, cy + 62)
            left_boot.closeSubpath()
            painter.drawPath(left_boot)
            # Right boot
            right_boot = QtGui.QPainterPath()
            right_boot.moveTo(cx + 4, cy + 62)
            right_boot.lineTo(cx + 4, cy + 74)
            right_boot.quadTo(cx + 10, cy + 78, cx + 18, cy + 76)
            right_boot.quadTo(cx + 22, cy + 70, cx + 20, cy + 62)
            right_boot.closeSubpath()
            painter.drawPath(right_boot)
            # Moon/star emblem on boots
            painter.setBrush(QtGui.QColor("#ffd700"))
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx - 14, cy + 66, 5, 5)
            painter.drawEllipse(cx + 9, cy + 66, 5, 5)
        else:
            # Bare feet with mystical glow
            painter.setBrush(QtGui.QColor("#e6c8a0"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#c9a066"), 1))
            painter.drawRoundedRect(cx - 16, cy + 62, 12, 14, 4, 4)
            painter.drawRoundedRect(cx + 4, cy + 62, 12, 14, 4, 4)

        # === ARMS (Flowing sleeves) ===
        arm_color = robe_color
        arm_grad_l = QtGui.QLinearGradient(cx - 44, cy - 5, cx - 28, cy - 5)
        arm_grad_l.setColorAt(0, arm_color.darker(125))
        arm_grad_l.setColorAt(0.4, arm_color)
        arm_grad_l.setColorAt(1, arm_color.darker(110))
        painter.setBrush(arm_grad_l)
        painter.setPen(QtGui.QPen(arm_color.darker(150), 2))
        # Wide flowing sleeves
        arm_path_l = QtGui.QPainterPath()
        arm_path_l.moveTo(cx - 26, cy - 24)
        arm_path_l.quadTo(cx - 36, cy - 26, cx - 42, cy - 16)
        arm_path_l.quadTo(cx - 52, cy + 8, cx - 50, cy + 25)
        arm_path_l.lineTo(cx - 30, cy + 20)
        arm_path_l.quadTo(cx - 28, cy - 5, cx - 26, cy - 24)
        painter.drawPath(arm_path_l)
        # Right sleeve
        arm_grad_r = QtGui.QLinearGradient(cx + 28, cy - 5, cx + 44, cy - 5)
        arm_grad_r.setColorAt(0, arm_color.darker(110))
        arm_grad_r.setColorAt(0.6, arm_color)
        arm_grad_r.setColorAt(1, arm_color.darker(125))
        painter.setBrush(arm_grad_r)
        arm_path_r = QtGui.QPainterPath()
        arm_path_r.moveTo(cx + 26, cy - 24)
        arm_path_r.quadTo(cx + 36, cy - 26, cx + 42, cy - 16)
        arm_path_r.quadTo(cx + 52, cy + 8, cx + 50, cy + 25)
        arm_path_r.lineTo(cx + 30, cy + 20)
        arm_path_r.quadTo(cx + 28, cy - 5, cx + 26, cy - 24)
        painter.drawPath(arm_path_r)

        # === GAUNTLETS (Arm Wraps / Dream Catchers) ===
        gaunt = self.equipped.get("Gauntlets")
        if gaunt:
            gc = QtGui.QColor(gaunt.get("color", "#4a4a8a"))
            gaunt_grad = QtGui.QLinearGradient(0, cy + 12, 0, cy + 32)
            gaunt_grad.setColorAt(0, gc.lighter(115))
            gaunt_grad.setColorAt(0.5, gc)
            gaunt_grad.setColorAt(1, gc.darker(110))
            painter.setBrush(gaunt_grad)
            painter.setPen(QtGui.QPen(gc.darker(130), 1))
            # Left arm wrap with bands
            painter.drawRoundedRect(cx - 50, cy + 14, 22, 18, 6, 6)
            # Wrap bands
            painter.setPen(QtGui.QPen(gc.lighter(130), 2))
            painter.drawLine(cx - 48, cy + 18, cx - 30, cy + 18)
            painter.drawLine(cx - 48, cy + 24, cx - 30, cy + 24)
            # Dream catcher circle for high tiers
            if self.tier in ["heroic", "epic", "legendary", "godlike"]:
                painter.setBrush(QtCore.Qt.NoBrush)
                painter.setPen(QtGui.QPen(QtGui.QColor("#ffd700"), 1))
                painter.drawEllipse(cx - 44, cy + 28, 8, 8)
            # Right arm wrap
            painter.setBrush(gaunt_grad)
            painter.setPen(QtGui.QPen(gc.darker(130), 1))
            painter.drawRoundedRect(cx + 28, cy + 14, 22, 18, 6, 6)
            painter.setPen(QtGui.QPen(gc.lighter(130), 2))
            painter.drawLine(cx + 30, cy + 18, cx + 48, cy + 18)
            painter.drawLine(cx + 30, cy + 24, cx + 48, cy + 24)
            if self.tier in ["heroic", "epic", "legendary", "godlike"]:
                painter.setBrush(QtCore.Qt.NoBrush)
                painter.setPen(QtGui.QPen(QtGui.QColor("#ffd700"), 1))
                painter.drawEllipse(cx + 36, cy + 28, 8, 8)
        else:
            # Bare hands with ethereal glow
            painter.setBrush(QtGui.QColor("#e6c8a0"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#c9a066"), 1))
            painter.drawEllipse(cx - 48, cy + 16, 14, 14)
            painter.drawEllipse(cx + 34, cy + 16, 14, 14)

        # === TORSO ===
        torso_grad = QtGui.QLinearGradient(cx - 25, cy, cx + 25, cy)
        torso_grad.setColorAt(0, robe_color.darker(115))
        torso_grad.setColorAt(0.3, robe_color)
        torso_grad.setColorAt(0.7, robe_color)
        torso_grad.setColorAt(1, robe_color.darker(115))
        painter.setBrush(torso_grad)
        painter.setPen(QtGui.QPen(robe_color.darker(150), 2))
        torso_path = QtGui.QPainterPath()
        torso_path.moveTo(cx - 26, cy - 28)
        torso_path.quadTo(cx - 28, cy - 5, cx - 22, cy + 25)
        torso_path.lineTo(cx + 22, cy + 25)
        torso_path.quadTo(cx + 28, cy - 5, cx + 26, cy - 28)
        torso_path.closeSubpath()
        painter.drawPath(torso_path)

        # === CHESTPLATE (Starweave Robe / Mooncloth Vest) ===
        chest = self.equipped.get("Chestplate")
        if chest:
            cc = QtGui.QColor(chest.get("color", "#3a3a7a"))
            chest_grad = QtGui.QLinearGradient(cx - 20, cy - 25, cx + 20, cy + 15)
            chest_grad.setColorAt(0, cc.lighter(120))
            chest_grad.setColorAt(0.5, cc)
            chest_grad.setColorAt(1, cc.darker(110))
            painter.setBrush(chest_grad)
            painter.setPen(QtGui.QPen(cc.darker(140), 2))
            # Flowing vest shape
            vest_path = QtGui.QPainterPath()
            vest_path.moveTo(cx - 22, cy - 26)
            vest_path.quadTo(cx, cy - 30, cx + 22, cy - 26)
            vest_path.lineTo(cx + 18, cy + 18)
            vest_path.quadTo(cx, cy + 22, cx - 18, cy + 18)
            vest_path.closeSubpath()
            painter.drawPath(vest_path)
            # Star pattern embroidery
            painter.setBrush(QtGui.QColor(255, 255, 200, 150))
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx - 12, cy - 15, 4, 4)
            painter.drawEllipse(cx + 8, cy - 10, 3, 3)
            painter.drawEllipse(cx - 5, cy + 2, 4, 4)
            painter.drawEllipse(cx + 10, cy + 8, 3, 3)
            # Moon crescent centerpiece
            painter.setBrush(QtGui.QColor("#ffd700"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#daa520"), 1))
            moon_path = QtGui.QPainterPath()
            moon_path.moveTo(cx - 6, cy - 5)
            moon_path.arcTo(cx - 8, cy - 8, 16, 16, 45, 270)
            moon_path.arcTo(cx - 4, cy - 4, 8, 8, 315, -270)
            painter.drawEllipse(cx - 6, cy - 8, 12, 12)
            # Inner cut for crescent
            painter.setBrush(cc)
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx - 2, cy - 6, 10, 10)
        else:
            # Simple robe pattern
            painter.setPen(QtGui.QPen(robe_color.darker(130), 1))
            painter.drawLine(cx, cy - 25, cx, cy + 18)
            painter.drawLine(cx - 12, cy - 24, cx, cy - 18)
            painter.drawLine(cx + 12, cy - 24, cx, cy - 18)

        # === NECK ===
        neck_grad = QtGui.QLinearGradient(cx - 8, cy - 35, cx + 8, cy - 35)
        neck_grad.setColorAt(0, QtGui.QColor("#d4b090"))
        neck_grad.setColorAt(0.5, QtGui.QColor("#e6c8a0"))
        neck_grad.setColorAt(1, QtGui.QColor("#d4b090"))
        painter.setBrush(neck_grad)
        painter.setPen(QtGui.QPen(QtGui.QColor("#c49a70"), 1))
        painter.drawRect(cx - 9, cy - 36, 18, 12)

        # === HEAD ===
        head_gradient = QtGui.QRadialGradient(cx - 5, cy - 55, 30)
        head_gradient.setColorAt(0, QtGui.QColor("#f5e0c8"))
        head_gradient.setColorAt(0.5, QtGui.QColor("#e6c8a0"))
        head_gradient.setColorAt(0.8, QtGui.QColor("#d4a870"))
        head_gradient.setColorAt(1, QtGui.QColor("#c49060"))
        painter.setBrush(head_gradient)
        painter.setPen(QtGui.QPen(QtGui.QColor("#b08050"), 2))
        head_path = QtGui.QPainterPath()
        head_path.moveTo(cx - 2, cy - 32)
        head_path.quadTo(cx - 22, cy - 35, cx - 22, cy - 52)
        head_path.quadTo(cx - 22, cy - 72, cx, cy - 72)
        head_path.quadTo(cx + 22, cy - 72, cx + 22, cy - 52)
        head_path.quadTo(cx + 22, cy - 35, cx + 2, cy - 32)
        head_path.closeSubpath()
        painter.drawPath(head_path)

        # === HELMET (Dream Crown / Star Circlet / Moon Tiara) ===
        helm = self.equipped.get("Helmet")
        if helm:
            hc = QtGui.QColor(helm.get("color", "#4a4a8a"))
            # Circlet/tiara base
            painter.setBrush(QtCore.Qt.NoBrush)
            painter.setPen(QtGui.QPen(hc.lighter(120), 3))
            painter.drawArc(cx - 20, cy - 68, 40, 20, 0, 180 * 16)
            # Crown points with stars
            painter.setBrush(hc.lighter(130))
            painter.setPen(QtGui.QPen(hc.darker(110), 1))
            # Center star point
            center_star = QtGui.QPainterPath()
            center_star.moveTo(cx, cy - 82)
            center_star.lineTo(cx + 4, cy - 72)
            center_star.lineTo(cx - 4, cy - 72)
            center_star.closeSubpath()
            painter.drawPath(center_star)
            # Side points
            left_point = QtGui.QPainterPath()
            left_point.moveTo(cx - 14, cy - 76)
            left_point.lineTo(cx - 10, cy - 68)
            left_point.lineTo(cx - 18, cy - 68)
            left_point.closeSubpath()
            painter.drawPath(left_point)
            right_point = QtGui.QPainterPath()
            right_point.moveTo(cx + 14, cy - 76)
            right_point.lineTo(cx + 10, cy - 68)
            right_point.lineTo(cx + 18, cy - 68)
            right_point.closeSubpath()
            painter.drawPath(right_point)
            # Center gem (moon crystal)
            gem_grad = QtGui.QRadialGradient(cx, cy - 70, 6)
            gem_grad.setColorAt(0, QtGui.QColor("#fff"))
            gem_grad.setColorAt(0.5, hc.lighter(150))
            gem_grad.setColorAt(1, hc)
            painter.setBrush(gem_grad)
            painter.setPen(QtGui.QPen(hc.darker(120), 1))
            painter.drawEllipse(cx - 5, cy - 74, 10, 10)
            # Gem sparkle
            painter.setBrush(QtGui.QColor(255, 255, 255, 200))
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx - 2, cy - 72, 3, 3)
        else:
            # Flowing hair (silvery/mystical)
            hair_color = QtGui.QColor("#6a6a8a")
            hair_grad = QtGui.QRadialGradient(cx, cy - 68, 24)
            hair_grad.setColorAt(0, hair_color.lighter(130))
            hair_grad.setColorAt(0.6, hair_color)
            hair_grad.setColorAt(1, hair_color.darker(120))
            painter.setBrush(hair_grad)
            painter.setPen(QtCore.Qt.NoPen)
            # Flowing mystical hair
            hair_path = QtGui.QPainterPath()
            hair_path.moveTo(cx - 22, cy - 58)
            hair_path.quadTo(cx - 28, cy - 68, cx - 20, cy - 76)
            hair_path.quadTo(cx - 10, cy - 84, cx, cy - 82)
            hair_path.quadTo(cx + 10, cy - 84, cx + 20, cy - 76)
            hair_path.quadTo(cx + 28, cy - 68, cx + 22, cy - 58)
            hair_path.closeSubpath()
            painter.drawPath(hair_path)
            # Hair strands with shimmer
            painter.setPen(QtGui.QPen(hair_color.lighter(140), 1))
            painter.drawLine(cx - 14, cy - 74, cx - 12, cy - 62)
            painter.drawLine(cx - 6, cy - 80, cx - 5, cy - 66)
            painter.drawLine(cx, cy - 82, cx, cy - 68)
            painter.drawLine(cx + 6, cy - 80, cx + 5, cy - 66)
            painter.drawLine(cx + 14, cy - 74, cx + 12, cy - 62)
            # Side tufts
            painter.setBrush(hair_color)
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx - 25, cy - 60, 7, 10)
            painter.drawEllipse(cx + 18, cy - 60, 7, 10)

        # === FACE ===
        # Mystical/serene eyebrows
        painter.setPen(QtGui.QPen(QtGui.QColor("#5a5a7a"), 2))
        if self.tier in ["legendary", "godlike"]:
            # Serene arched brows
            painter.drawArc(cx - 14, cy - 62, 10, 6, 30 * 16, 120 * 16)
            painter.drawArc(cx + 4, cy - 62, 10, 6, 30 * 16, 120 * 16)
        else:
            # Calm brows
            painter.drawLine(cx - 12, cy - 58, cx - 5, cy - 59)
            painter.drawLine(cx + 5, cy - 59, cx + 12, cy - 58)
        
        # Eyes (mystical, glowing)
        painter.setBrush(QtGui.QColor("#d8c0a0"))
        painter.setPen(QtCore.Qt.NoPen)
        painter.drawEllipse(cx - 13, cy - 56, 12, 10)
        painter.drawEllipse(cx + 1, cy - 56, 12, 10)
        # Eye whites with slight glow
        eye_glow = QtGui.QRadialGradient(cx - 7, cy - 51, 6)
        eye_glow.setColorAt(0, QtGui.QColor("#fff"))
        eye_glow.setColorAt(1, QtGui.QColor("#e8e8ff"))
        painter.setBrush(eye_glow)
        painter.drawEllipse(cx - 12, cy - 55, 10, 9)
        eye_glow2 = QtGui.QRadialGradient(cx + 7, cy - 51, 6)
        eye_glow2.setColorAt(0, QtGui.QColor("#fff"))
        eye_glow2.setColorAt(1, QtGui.QColor("#e8e8ff"))
        painter.setBrush(eye_glow2)
        painter.drawEllipse(cx + 2, cy - 55, 10, 9)
        # Iris (mystical purple/silver)
        iris_colors = {
            "pathetic": "#7a7a9a", "modest": "#6a6aaa", "decent": "#5a5aba",
            "heroic": "#6a4aaa", "epic": "#8a4aca", "legendary": "#aa6ada", "godlike": "#ca8afa"
        }
        iris_color = QtGui.QColor(iris_colors.get(self.tier, "#7a7aaa"))
        iris_grad = QtGui.QRadialGradient(cx - 7, cy - 51, 4)
        iris_grad.setColorAt(0, iris_color.lighter(130))
        iris_grad.setColorAt(1, iris_color)
        painter.setBrush(iris_grad)
        painter.drawEllipse(cx - 9, cy - 53, 6, 6)
        iris_grad2 = QtGui.QRadialGradient(cx + 7, cy - 51, 4)
        iris_grad2.setColorAt(0, iris_color.lighter(130))
        iris_grad2.setColorAt(1, iris_color)
        painter.setBrush(iris_grad2)
        painter.drawEllipse(cx + 4, cy - 53, 6, 6)
        # Pupils (star-shaped for high tiers)
        painter.setBrush(QtGui.QColor("#1a1a2a"))
        if self.tier in ["legendary", "godlike"]:
            # Star pupils
            for px in [cx - 7, cx + 6]:
                star = QtGui.QPainterPath()
                star.moveTo(px, cy - 52)
                star.lineTo(px + 1, cy - 50)
                star.lineTo(px + 2, cy - 51)
                star.lineTo(px + 1, cy - 49)
                star.lineTo(px, cy - 48)
                star.lineTo(px - 1, cy - 49)
                star.lineTo(px - 2, cy - 51)
                star.lineTo(px - 1, cy - 50)
                star.closeSubpath()
                painter.drawPath(star)
        else:
            painter.drawEllipse(cx - 8, cy - 52, 3, 3)
            painter.drawEllipse(cx + 5, cy - 52, 3, 3)
        # Eye shine (multiple for mystical look)
        painter.setBrush(QtGui.QColor("#fff"))
        painter.drawEllipse(cx - 9, cy - 53, 2, 2)
        painter.drawEllipse(cx + 4, cy - 53, 2, 2)
        painter.setOpacity(0.6)
        painter.drawEllipse(cx - 5, cy - 49, 1, 1)
        painter.drawEllipse(cx + 8, cy - 49, 1, 1)
        painter.setOpacity(1.0)

        # Nose
        painter.setPen(QtGui.QPen(QtGui.QColor("#c49060"), 1))
        painter.drawLine(cx, cy - 48, cx - 1, cy - 42)
        painter.drawArc(cx - 4, cy - 42, 4, 3, 180 * 16, 180 * 16)
        painter.drawArc(cx, cy - 42, 4, 3, 180 * 16, 180 * 16)

        # Mouth (serene expressions)
        painter.setPen(QtGui.QPen(QtGui.QColor("#a06050"), 2))
        if self.tier in ["legendary", "godlike"]:
            # Serene knowing smile
            painter.drawArc(cx - 8, cy - 44, 16, 10, 210 * 16, 120 * 16)
        elif self.tier in ["epic", "heroic"]:
            # Slight peaceful smile
            painter.drawArc(cx - 7, cy - 42, 14, 6, 220 * 16, 100 * 16)
        else:
            # Contemplative
            painter.drawLine(cx - 5, cy - 38, cx + 5, cy - 38)

        # Ears
        painter.setBrush(QtGui.QColor("#e6c8a0"))
        painter.setPen(QtGui.QPen(QtGui.QColor("#c49a70"), 1))
        painter.drawEllipse(cx - 24, cy - 52, 5, 9)
        painter.drawEllipse(cx + 19, cy - 52, 5, 9)

        # Third eye mark for high tiers (no helmet)
        if not helm and self.tier in ["epic", "legendary", "godlike"]:
            painter.setBrush(QtGui.QColor(200, 180, 255, 150))
            painter.setPen(QtGui.QPen(QtGui.QColor("#9a8aca"), 1))
            painter.drawEllipse(cx - 3, cy - 62, 6, 4)

        # === AMULET (Dream Catcher / Star Pendant / Moon Crystal) ===
        amulet = self.equipped.get("Amulet")
        if amulet:
            ac = QtGui.QColor(amulet.get("color", "#8a8aca"))
            # Chain with ethereal links
            painter.setPen(QtGui.QPen(QtGui.QColor("#c0c0e0"), 2))
            for i in range(4):
                painter.drawEllipse(cx - 11 + i * 3, cy - 28 + i * 2, 3, 3)
                painter.drawEllipse(cx + 8 - i * 3, cy - 28 + i * 2, 3, 3)
            # Dream catcher circle
            painter.setBrush(QtCore.Qt.NoBrush)
            painter.setPen(QtGui.QPen(ac.lighter(120), 2))
            painter.drawEllipse(cx - 12, cy - 18, 24, 24)
            # Inner web pattern
            painter.setPen(QtGui.QPen(ac, 1))
            painter.drawEllipse(cx - 8, cy - 14, 16, 16)
            painter.drawEllipse(cx - 4, cy - 10, 8, 8)
            # Cross pattern
            painter.drawLine(cx, cy - 18, cx, cy + 6)
            painter.drawLine(cx - 12, cy - 6, cx + 12, cy - 6)
            # Center crystal
            gem_grad = QtGui.QRadialGradient(cx, cy - 6, 5)
            gem_grad.setColorAt(0, QtGui.QColor("#fff"))
            gem_grad.setColorAt(0.5, ac.lighter(140))
            gem_grad.setColorAt(1, ac)
            painter.setBrush(gem_grad)
            painter.setPen(QtGui.QPen(ac.darker(120), 1))
            painter.drawEllipse(cx - 4, cy - 10, 8, 8)
            # Feather dangles for high tiers
            if self.tier in ["epic", "legendary", "godlike"]:
                painter.setPen(QtGui.QPen(ac.lighter(110), 1))
                painter.drawLine(cx - 8, cy + 6, cx - 10, cy + 18)
                painter.drawLine(cx, cy + 6, cx, cy + 16)
                painter.drawLine(cx + 8, cy + 6, cx + 10, cy + 18)

        # === WEAPON (Dream Staff / Star Wand / Void Orb) ===
        weap = self.equipped.get("Weapon")
        if weap:
            wc = QtGui.QColor(weap.get("color", "#6a6aaa"))
            # Staff body
            staff_grad = QtGui.QLinearGradient(cx - 56, cy - 50, cx - 50, cy + 35)
            staff_grad.setColorAt(0, wc.lighter(130))
            staff_grad.setColorAt(0.5, wc)
            staff_grad.setColorAt(1, wc.darker(120))
            painter.setBrush(staff_grad)
            painter.setPen(QtGui.QPen(wc.darker(140), 2))
            # Curved mystical staff
            staff_path = QtGui.QPainterPath()
            staff_path.moveTo(cx - 56, cy + 35)
            staff_path.quadTo(cx - 58, cy, cx - 54, cy - 45)
            staff_path.lineTo(cx - 50, cy - 45)
            staff_path.quadTo(cx - 52, cy, cx - 50, cy + 35)
            staff_path.closeSubpath()
            painter.drawPath(staff_path)
            # Staff spiral wrapping
            painter.setPen(QtGui.QPen(wc.lighter(140), 1))
            for i in range(8):
                y = cy - 35 + i * 8
                painter.drawLine(cx - 56, y, cx - 50, y + 4)
            # Orb at top
            orb_grad = QtGui.QRadialGradient(cx - 52, cy - 55, 12)
            orb_grad.setColorAt(0, QtGui.QColor("#fff"))
            orb_grad.setColorAt(0.3, wc.lighter(150))
            orb_grad.setColorAt(0.7, wc)
            orb_grad.setColorAt(1, wc.darker(130))
            painter.setBrush(orb_grad)
            painter.setPen(QtGui.QPen(wc.darker(120), 2))
            painter.drawEllipse(cx - 62, cy - 65, 20, 20)
            # Orb inner glow
            painter.setBrush(QtGui.QColor(255, 255, 255, 100))
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx - 58, cy - 61, 8, 8)
            # Orbiting stars for high tiers
            if self.tier in ["legendary", "godlike"]:
                painter.setBrush(QtGui.QColor("#ffd700"))
                painter.drawEllipse(cx - 66, cy - 52, 4, 4)
                painter.drawEllipse(cx - 46, cy - 58, 4, 4)
                painter.drawEllipse(cx - 58, cy - 70, 3, 3)

        # === SHIELD (Dream Ward / Reality Anchor / Astral Aegis) ===
        shield = self.equipped.get("Shield")
        if shield:
            sc = QtGui.QColor(shield.get("color", "#5a5a9a"))
            # Circular mystical ward
            shield_grad = QtGui.QRadialGradient(cx + 50, cy + 8, 28)
            shield_grad.setColorAt(0, sc.lighter(140))
            shield_grad.setColorAt(0.5, sc)
            shield_grad.setColorAt(1, sc.darker(130))
            painter.setBrush(shield_grad)
            painter.setPen(QtGui.QPen(sc.darker(150), 3))
            painter.drawEllipse(cx + 28, cy - 14, 44, 44)
            # Outer ring
            painter.setBrush(QtCore.Qt.NoBrush)
            painter.setPen(QtGui.QPen(sc.lighter(130), 2))
            painter.drawEllipse(cx + 32, cy - 10, 36, 36)
            # Inner mystical patterns
            painter.setPen(QtGui.QPen(sc.lighter(140), 1))
            # Star pattern
            for angle in range(0, 360, 60):
                import math
                rad = math.radians(angle)
                x1 = cx + 50 + 12 * math.cos(rad)
                y1 = cy + 8 + 12 * math.sin(rad)
                x2 = cx + 50 + 18 * math.cos(rad)
                y2 = cy + 8 + 18 * math.sin(rad)
                painter.drawLine(int(x1), int(y1), int(x2), int(y2))
            # Center eye symbol
            eye_grad = QtGui.QRadialGradient(cx + 50, cy + 8, 10)
            eye_grad.setColorAt(0, QtGui.QColor("#fff"))
            eye_grad.setColorAt(0.4, sc.lighter(160))
            eye_grad.setColorAt(1, sc)
            painter.setBrush(eye_grad)
            painter.setPen(QtGui.QPen(sc.darker(120), 1))
            painter.drawEllipse(cx + 42, cy, 16, 16)
            # Pupil (void)
            painter.setBrush(QtGui.QColor("#1a1a3a"))
            painter.drawEllipse(cx + 47, cy + 5, 6, 6)
            # Eye shine
            painter.setBrush(QtGui.QColor(255, 255, 255, 180))
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx + 48, cy + 6, 2, 2)
            # Floating runes for high tiers
            if self.tier in ["epic", "legendary", "godlike"]:
                painter.setOpacity(0.4)
                painter.setBrush(sc.lighter(150))
                painter.drawEllipse(cx + 26, cy - 4, 6, 6)
                painter.drawEllipse(cx + 68, cy - 2, 5, 5)
                painter.drawEllipse(cx + 30, cy + 22, 5, 5)
                painter.drawEllipse(cx + 64, cy + 20, 6, 6)
                painter.setOpacity(1.0)

        # === POWER LABEL ===
        label_rect = QtCore.QRect(0, h - 28, w, 25)
        painter.fillRect(label_rect, QtGui.QColor(0, 0, 0, 120))
        
        # Power text color based on tier (no glow loop - causes double-text artifacts)
        if self.tier in ["legendary", "godlike"]:
            painter.setPen(QtGui.QColor("#e0d0ff"))
        elif self.tier in ["epic"]:
            painter.setPen(QtGui.QColor("#c0a0ff"))
        elif self.tier in ["heroic"]:
            painter.setPen(QtGui.QColor("#a0a0ff"))
        else:
            painter.setPen(QtGui.QColor("#d0d0ff"))
        
        # Draw single clean power text
        painter.setFont(QtGui.QFont("Segoe UI", 11, QtGui.QFont.Bold))
        painter.drawText(label_rect, QtCore.Qt.AlignCenter, f"üåô {self.power}")

    def _draw_underdog_character(self, painter: QtGui.QPainter) -> None:
        """Draw the modern office/corporate themed character."""
        # painter = QtGui.QPainter(self)  # Uses passed painter
        painter.setRenderHint(QtGui.QPainter.Antialiasing)

        # Use canonical dimensions for drawing (scaling handled by caller)
        w, h = self.BASE_W, self.BASE_H
        cx, cy = w // 2, h // 2 + 5

        # Background with modern office gradient
        bg_gradient = QtGui.QLinearGradient(0, 0, 0, h)
        bg_gradient.setColorAt(0, QtGui.QColor("#2d3436"))
        bg_gradient.setColorAt(0.3, QtGui.QColor("#636e72"))
        bg_gradient.setColorAt(0.7, QtGui.QColor("#b2bec3"))
        bg_gradient.setColorAt(1, QtGui.QColor("#dfe6e9"))
        painter.fillRect(0, 0, w, h, bg_gradient)
        
        # Office floor tiles
        painter.setPen(QtGui.QPen(QtGui.QColor(100, 100, 100, 60), 1))
        for i in range(-2, 5):
            x = cx + i * 30
            painter.drawLine(x, cy + 50, x + 15, cy + 80)
        for j in range(3):
            y = cy + 55 + j * 10
            painter.drawLine(cx - 60, y, cx + 60, y + 8)
        
        # Floor shadow
        floor_gradient = QtGui.QLinearGradient(cx - 40, cy + 65, cx + 40, cy + 80)
        floor_gradient.setColorAt(0, QtGui.QColor(50, 50, 50, 20))
        floor_gradient.setColorAt(0.5, QtGui.QColor(30, 30, 30, 80))
        floor_gradient.setColorAt(1, QtGui.QColor(50, 50, 50, 20))
        painter.setBrush(floor_gradient)
        painter.setPen(QtCore.Qt.NoPen)
        painter.drawEllipse(cx - 40, cy + 65, 80, 18)

        body_color = QtGui.QColor(self.TIER_COLORS.get(self.tier, "#bdbdbd"))
        body_outline = QtGui.QColor(self.TIER_OUTLINE.get(self.tier, "#888"))
        glow = self.TIER_GLOW.get(self.tier)

        def darken(color: str, amount: int = 130) -> QtGui.QColor:
            c = QtGui.QColor(color)
            return c.darker(amount)
        
        def lighten(color: str, amount: int = 130) -> QtGui.QColor:
            c = QtGui.QColor(color)
            return c.lighter(amount)

        # Success aura for high tiers
        if glow:
            glow_color = QtGui.QColor(glow)
            painter.setBrush(QtCore.Qt.NoBrush)
            for i, opacity in enumerate([0.06, 0.1, 0.15, 0.25]):
                painter.setOpacity(opacity)
                size = 140 - i * 16
                painter.setPen(QtGui.QPen(glow_color, 2))
                painter.drawEllipse(cx - size//2, cy - 70, size, int(size * 1.15))
            painter.setOpacity(1.0)
            # Inner glow
            painter.setBrush(glow_color)
            painter.setPen(QtCore.Qt.NoPen)
            painter.setOpacity(0.15)
            painter.drawEllipse(cx - 50, cy - 60, 100, 130)
            painter.setOpacity(1.0)
        
        # Floating success particles (dollar signs, stars, etc.)
        particles = self.TIER_PARTICLES.get(self.tier)
        if particles:
            p_color, p_count = particles
            for i, (px, py, ps) in enumerate(self._particles[:p_count]):
                painter.setOpacity(0.4 + (i % 3) * 0.15)
                painter.setBrush(QtGui.QColor(p_color))
                painter.setPen(QtCore.Qt.NoPen)
                if i % 4 == 0:
                    # Star shape
                    star_cx, star_cy = cx + px, cy + py
                    star = QtGui.QPainterPath()
                    star.moveTo(star_cx, star_cy - ps)
                    star.lineTo(star_cx + ps//3, star_cy - ps//3)
                    star.lineTo(star_cx + ps, star_cy)
                    star.lineTo(star_cx + ps//3, star_cy + ps//3)
                    star.lineTo(star_cx, star_cy + ps)
                    star.lineTo(star_cx - ps//3, star_cy + ps//3)
                    star.lineTo(star_cx - ps, star_cy)
                    star.lineTo(star_cx - ps//3, star_cy - ps//3)
                    star.closeSubpath()
                    painter.drawPath(star)
                else:
                    # Diamond/gem
                    painter.drawEllipse(cx + px, cy + py, ps + 1, ps + 1)
            painter.setOpacity(1.0)

        # === CLOAK/OUTERWEAR (Jacket/Hoodie/Blazer) ===
        cloak = self.equipped.get("Cloak")
        if cloak:
            cc = QtGui.QColor(cloak.get("color", "#34495e"))
            path = QtGui.QPainterPath()
            path.moveTo(cx - 26, cy - 26)
            path.lineTo(cx + 26, cy - 26)
            path.quadTo(cx + 35, cy + 5, cx + 32, cy + 50)
            path.lineTo(cx + 28, cy + 68)
            path.quadTo(cx, cy + 72, cx - 28, cy + 68)
            path.lineTo(cx - 32, cy + 50)
            path.quadTo(cx - 35, cy + 5, cx - 26, cy - 26)
            cloak_gradient = QtGui.QLinearGradient(cx, cy - 30, cx, cy + 70)
            cloak_gradient.setColorAt(0, cc.lighter(115))
            cloak_gradient.setColorAt(0.5, cc)
            cloak_gradient.setColorAt(1, darken(cloak.get("color", "#34495e"), 125))
            painter.setBrush(cloak_gradient)
            painter.setPen(QtGui.QPen(darken(cloak.get("color", "#34495e"), 140), 2))
            painter.drawPath(path)
            # Jacket lapels/collar
            painter.setPen(QtGui.QPen(cc.darker(130), 2))
            painter.drawLine(cx - 8, cy - 22, cx - 12, cy + 20)
            painter.drawLine(cx + 8, cy - 22, cx + 12, cy + 20)
            # Pockets
            painter.drawRect(cx - 22, cy + 25, 12, 8)
            painter.drawRect(cx + 10, cy + 25, 12, 8)

        # === LEGS (Pants/Trousers) ===
        pants_color = QtGui.QColor("#2c3e50")
        pants_grad = QtGui.QLinearGradient(cx - 18, cy + 25, cx + 18, cy + 25)
        pants_grad.setColorAt(0, pants_color.darker(115))
        pants_grad.setColorAt(0.5, pants_color)
        pants_grad.setColorAt(1, pants_color.darker(115))
        painter.setBrush(pants_grad)
        painter.setPen(QtGui.QPen(pants_color.darker(140), 2))
        # Left leg
        left_leg = QtGui.QPainterPath()
        left_leg.moveTo(cx - 18, cy + 25)
        left_leg.lineTo(cx - 4, cy + 25)
        left_leg.lineTo(cx - 6, cy + 62)
        left_leg.lineTo(cx - 20, cy + 62)
        left_leg.closeSubpath()
        painter.drawPath(left_leg)
        # Right leg
        right_leg = QtGui.QPainterPath()
        right_leg.moveTo(cx + 4, cy + 25)
        right_leg.lineTo(cx + 18, cy + 25)
        right_leg.lineTo(cx + 20, cy + 62)
        right_leg.lineTo(cx + 6, cy + 62)
        right_leg.closeSubpath()
        painter.drawPath(right_leg)

        # === BOOTS/FOOTWEAR (Sneakers/Loafers/Dress Shoes) ===
        boots = self.equipped.get("Boots")
        if boots:
            bc = QtGui.QColor(boots.get("color", "#2d3436"))
            boot_grad = QtGui.QLinearGradient(0, cy + 58, 0, cy + 78)
            boot_grad.setColorAt(0, bc.lighter(115))
            boot_grad.setColorAt(0.5, bc)
            boot_grad.setColorAt(1, bc.darker(115))
            painter.setBrush(boot_grad)
            painter.setPen(QtGui.QPen(bc.darker(130), 2))
            # Left shoe - modern sneaker shape
            left_shoe = QtGui.QPainterPath()
            left_shoe.moveTo(cx - 22, cy + 60)
            left_shoe.lineTo(cx - 4, cy + 60)
            left_shoe.lineTo(cx - 2, cy + 72)
            left_shoe.quadTo(cx - 8, cy + 78, cx - 18, cy + 76)
            left_shoe.quadTo(cx - 26, cy + 72, cx - 24, cy + 64)
            left_shoe.closeSubpath()
            painter.drawPath(left_shoe)
            # Right shoe
            right_shoe = QtGui.QPainterPath()
            right_shoe.moveTo(cx + 4, cy + 60)
            right_shoe.lineTo(cx + 22, cy + 60)
            right_shoe.quadTo(cx + 26, cy + 68, cx + 24, cy + 72)
            right_shoe.quadTo(cx + 18, cy + 78, cx + 8, cy + 76)
            right_shoe.lineTo(cx + 2, cy + 72)
            right_shoe.closeSubpath()
            painter.drawPath(right_shoe)
            # Shoe details (laces/stripes)
            painter.setPen(QtGui.QPen(bc.lighter(150), 1))
            painter.drawLine(cx - 18, cy + 64, cx - 8, cy + 64)
            painter.drawLine(cx - 17, cy + 68, cx - 9, cy + 68)
            painter.drawLine(cx + 8, cy + 64, cx + 18, cy + 64)
            painter.drawLine(cx + 9, cy + 68, cx + 17, cy + 68)
            # Sole
            painter.setPen(QtGui.QPen(QtGui.QColor("#fff"), 2))
            painter.drawLine(cx - 24, cy + 74, cx - 4, cy + 76)
            painter.drawLine(cx + 4, cy + 76, cx + 24, cy + 74)
        else:
            # Basic shoes
            painter.setBrush(QtGui.QColor("#2d3436"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#1e272e"), 1))
            painter.drawRoundedRect(cx - 22, cy + 60, 18, 16, 4, 4)
            painter.drawRoundedRect(cx + 4, cy + 60, 18, 16, 4, 4)

        # === ARMS (Shirt sleeves) ===
        chestplate = self.equipped.get("Chestplate")
        if chestplate and isinstance(chestplate, dict):
            shirt_color = QtGui.QColor(chestplate.get("color", "#74b9ff"))
        else:
            shirt_color = QtGui.QColor("#74b9ff")
        arm_grad_l = QtGui.QLinearGradient(cx - 42, cy - 5, cx - 26, cy - 5)
        arm_grad_l.setColorAt(0, shirt_color.darker(120))
        arm_grad_l.setColorAt(0.5, shirt_color)
        arm_grad_l.setColorAt(1, shirt_color.darker(105))
        painter.setBrush(arm_grad_l)
        painter.setPen(QtGui.QPen(shirt_color.darker(140), 2))
        # Left arm
        left_arm = QtGui.QPainterPath()
        left_arm.moveTo(cx - 26, cy - 22)
        left_arm.quadTo(cx - 34, cy - 20, cx - 40, cy - 10)
        left_arm.quadTo(cx - 46, cy + 8, cx - 44, cy + 25)
        left_arm.lineTo(cx - 32, cy + 22)
        left_arm.quadTo(cx - 30, cy - 2, cx - 26, cy - 22)
        painter.drawPath(left_arm)
        # Right arm
        arm_grad_r = QtGui.QLinearGradient(cx + 26, cy - 5, cx + 42, cy - 5)
        arm_grad_r.setColorAt(0, shirt_color.darker(105))
        arm_grad_r.setColorAt(0.5, shirt_color)
        arm_grad_r.setColorAt(1, shirt_color.darker(120))
        painter.setBrush(arm_grad_r)
        right_arm = QtGui.QPainterPath()
        right_arm.moveTo(cx + 26, cy - 22)
        right_arm.quadTo(cx + 34, cy - 20, cx + 40, cy - 10)
        right_arm.quadTo(cx + 46, cy + 8, cx + 44, cy + 25)
        right_arm.lineTo(cx + 32, cy + 22)
        right_arm.quadTo(cx + 30, cy - 2, cx + 26, cy - 22)
        painter.drawPath(right_arm)

        # === GAUNTLETS/ACCESSORIES (Smartwatch/Wristband) ===
        gaunt = self.equipped.get("Gauntlets")
        if gaunt:
            gc = QtGui.QColor(gaunt.get("color", "#2d3436"))
            # Left wristwatch/band
            painter.setBrush(gc)
            painter.setPen(QtGui.QPen(gc.darker(130), 1))
            painter.drawRoundedRect(cx - 46, cy + 14, 16, 12, 3, 3)
            # Watch face
            painter.setBrush(QtGui.QColor("#1e272e"))
            painter.drawRoundedRect(cx - 44, cy + 16, 12, 8, 2, 2)
            # Watch screen glow
            screen_grad = QtGui.QRadialGradient(cx - 38, cy + 20, 5)
            screen_grad.setColorAt(0, QtGui.QColor("#00ff88"))
            screen_grad.setColorAt(1, QtGui.QColor("#00aa55"))
            painter.setBrush(screen_grad)
            painter.drawRect(cx - 42, cy + 17, 8, 6)
            # Right wristband/fitness tracker
            painter.setBrush(gc)
            painter.setPen(QtGui.QPen(gc.darker(130), 1))
            painter.drawRoundedRect(cx + 30, cy + 14, 16, 12, 3, 3)
            # Band pattern
            painter.setPen(QtGui.QPen(gc.lighter(130), 1))
            painter.drawLine(cx + 32, cy + 18, cx + 44, cy + 18)
            painter.drawLine(cx + 32, cy + 22, cx + 44, cy + 22)
        else:
            # Bare hands
            painter.setBrush(QtGui.QColor("#e6c8a0"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#c9a066"), 1))
            painter.drawEllipse(cx - 46, cy + 16, 14, 12)
            painter.drawEllipse(cx + 32, cy + 16, 14, 12)

        # === TORSO ===
        torso_grad = QtGui.QLinearGradient(cx - 24, cy, cx + 24, cy)
        torso_grad.setColorAt(0, shirt_color.darker(110))
        torso_grad.setColorAt(0.3, shirt_color)
        torso_grad.setColorAt(0.7, shirt_color)
        torso_grad.setColorAt(1, shirt_color.darker(110))
        painter.setBrush(torso_grad)
        painter.setPen(QtGui.QPen(shirt_color.darker(140), 2))
        torso_path = QtGui.QPainterPath()
        torso_path.moveTo(cx - 24, cy - 26)
        torso_path.quadTo(cx - 26, cy - 5, cx - 18, cy + 28)
        torso_path.lineTo(cx + 18, cy + 28)
        torso_path.quadTo(cx + 26, cy - 5, cx + 24, cy - 26)
        torso_path.closeSubpath()
        painter.drawPath(torso_path)

        # === CHESTPLATE/TOP (Hoodie/Blazer/Polo) ===
        chest = self.equipped.get("Chestplate")
        if chest:
            cc = QtGui.QColor(chest.get("color", "#0984e3"))
            chest_grad = QtGui.QLinearGradient(cx - 20, cy - 24, cx + 20, cy + 20)
            chest_grad.setColorAt(0, cc.lighter(115))
            chest_grad.setColorAt(0.5, cc)
            chest_grad.setColorAt(1, cc.darker(110))
            painter.setBrush(chest_grad)
            painter.setPen(QtGui.QPen(cc.darker(130), 2))
            # Shirt/top shape
            top_path = QtGui.QPainterPath()
            top_path.moveTo(cx - 20, cy - 24)
            top_path.quadTo(cx, cy - 28, cx + 20, cy - 24)
            top_path.lineTo(cx + 16, cy + 22)
            top_path.quadTo(cx, cy + 26, cx - 16, cy + 22)
            top_path.closeSubpath()
            painter.drawPath(top_path)
            # Collar (polo/button-down style)
            painter.setPen(QtGui.QPen(cc.darker(120), 2))
            painter.drawLine(cx - 10, cy - 24, cx, cy - 18)
            painter.drawLine(cx + 10, cy - 24, cx, cy - 18)
            # Buttons
            painter.setBrush(QtGui.QColor("#dfe6e9"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#b2bec3"), 1))
            for by in [cy - 12, cy - 2, cy + 8]:
                painter.drawEllipse(cx - 2, by, 4, 4)
            # Pocket
            painter.setPen(QtGui.QPen(cc.darker(120), 1))
            painter.drawRect(cx - 14, cy - 8, 8, 10)
        else:
            # Plain t-shirt look
            painter.setPen(QtGui.QPen(shirt_color.darker(120), 1))
            painter.drawLine(cx, cy - 24, cx, cy + 20)

        # === NECK ===
        neck_grad = QtGui.QLinearGradient(cx - 8, cy - 32, cx + 8, cy - 32)
        neck_grad.setColorAt(0, QtGui.QColor("#d4b090"))
        neck_grad.setColorAt(0.5, QtGui.QColor("#e6c8a0"))
        neck_grad.setColorAt(1, QtGui.QColor("#d4b090"))
        painter.setBrush(neck_grad)
        painter.setPen(QtGui.QPen(QtGui.QColor("#c49a70"), 1))
        painter.drawRect(cx - 8, cy - 34, 16, 12)

        # === HEAD ===
        head_gradient = QtGui.QRadialGradient(cx - 4, cy - 52, 28)
        head_gradient.setColorAt(0, QtGui.QColor("#f5e0c8"))
        head_gradient.setColorAt(0.5, QtGui.QColor("#e6c8a0"))
        head_gradient.setColorAt(0.8, QtGui.QColor("#d4a870"))
        head_gradient.setColorAt(1, QtGui.QColor("#c49060"))
        painter.setBrush(head_gradient)
        painter.setPen(QtGui.QPen(QtGui.QColor("#b08050"), 2))
        head_path = QtGui.QPainterPath()
        head_path.moveTo(cx - 2, cy - 30)
        head_path.quadTo(cx - 20, cy - 33, cx - 20, cy - 50)
        head_path.quadTo(cx - 20, cy - 70, cx, cy - 70)
        head_path.quadTo(cx + 20, cy - 70, cx + 20, cy - 50)
        head_path.quadTo(cx + 20, cy - 33, cx + 2, cy - 30)
        head_path.closeSubpath()
        painter.drawPath(head_path)

        # === HELMET/HEADWEAR (Headphones/Cap/Beanie) ===
        helm = self.equipped.get("Helmet")
        if helm:
            hc = QtGui.QColor(helm.get("color", "#2d3436"))
            # Headphones design
            # Headband
            painter.setBrush(QtCore.Qt.NoBrush)
            painter.setPen(QtGui.QPen(hc, 4))
            painter.drawArc(cx - 22, cy - 75, 44, 30, 0, 180 * 16)
            # Left ear cup
            painter.setBrush(hc)
            painter.setPen(QtGui.QPen(hc.darker(130), 2))
            left_cup = QtGui.QPainterPath()
            left_cup.addRoundedRect(cx - 28, cy - 60, 12, 18, 4, 4)
            painter.drawPath(left_cup)
            # Ear cup detail (speaker mesh)
            painter.setBrush(hc.darker(140))
            painter.drawEllipse(cx - 26, cy - 56, 8, 10)
            # Right ear cup
            painter.setBrush(hc)
            painter.setPen(QtGui.QPen(hc.darker(130), 2))
            right_cup = QtGui.QPainterPath()
            right_cup.addRoundedRect(cx + 16, cy - 60, 12, 18, 4, 4)
            painter.drawPath(right_cup)
            painter.setBrush(hc.darker(140))
            painter.drawEllipse(cx + 18, cy - 56, 8, 10)
            # LED indicator for high tiers
            if self.tier in ["heroic", "epic", "legendary", "godlike"]:
                painter.setBrush(QtGui.QColor("#00ff88"))
                painter.setPen(QtCore.Qt.NoPen)
                painter.drawEllipse(cx - 25, cy - 46, 4, 4)
                painter.drawEllipse(cx + 21, cy - 46, 4, 4)
        else:
            # Modern haircut
            hair_color = QtGui.QColor("#4a3728")
            hair_grad = QtGui.QRadialGradient(cx, cy - 65, 22)
            hair_grad.setColorAt(0, hair_color.lighter(120))
            hair_grad.setColorAt(0.6, hair_color)
            hair_grad.setColorAt(1, hair_color.darker(115))
            painter.setBrush(hair_grad)
            painter.setPen(QtCore.Qt.NoPen)
            # Modern styled hair
            hair_path = QtGui.QPainterPath()
            hair_path.moveTo(cx - 20, cy - 55)
            hair_path.quadTo(cx - 24, cy - 65, cx - 18, cy - 72)
            hair_path.quadTo(cx - 8, cy - 78, cx + 5, cy - 76)
            hair_path.quadTo(cx + 18, cy - 74, cx + 22, cy - 65)
            hair_path.quadTo(cx + 24, cy - 55, cx + 20, cy - 50)
            hair_path.quadTo(cx + 18, cy - 58, cx + 12, cy - 62)
            hair_path.quadTo(cx, cy - 66, cx - 12, cy - 62)
            hair_path.quadTo(cx - 18, cy - 58, cx - 20, cy - 55)
            painter.drawPath(hair_path)
            # Side hair
            painter.drawEllipse(cx - 22, cy - 56, 6, 12)
            painter.drawEllipse(cx + 16, cy - 56, 6, 12)

        # === FACE ===
        # Modern/confident eyebrows
        painter.setPen(QtGui.QPen(QtGui.QColor("#4a3728"), 2))
        if self.tier in ["legendary", "godlike"]:
            # Confident raised brows
            painter.drawLine(cx - 12, cy - 58, cx - 4, cy - 60)
            painter.drawLine(cx + 4, cy - 60, cx + 12, cy - 58)
        elif self.tier in ["epic", "heroic"]:
            # Focused brows
            painter.drawLine(cx - 12, cy - 57, cx - 5, cy - 58)
            painter.drawLine(cx + 5, cy - 58, cx + 12, cy - 57)
        else:
            # Normal brows
            painter.drawLine(cx - 11, cy - 56, cx - 5, cy - 57)
            painter.drawLine(cx + 5, cy - 57, cx + 11, cy - 56)
        
        # Eyes (alert, focused)
        painter.setBrush(QtGui.QColor("#e8dcc8"))
        painter.setPen(QtCore.Qt.NoPen)
        painter.drawEllipse(cx - 12, cy - 54, 11, 9)
        painter.drawEllipse(cx + 1, cy - 54, 11, 9)
        # Eye whites
        painter.setBrush(QtGui.QColor("#fff"))
        painter.drawEllipse(cx - 11, cy - 53, 9, 8)
        painter.drawEllipse(cx + 2, cy - 53, 9, 8)
        # Iris (determined colors)
        iris_colors = {
            "pathetic": "#6b4423", "modest": "#5d4037", "decent": "#4e342e",
            "heroic": "#1565c0", "epic": "#0d47a1", "legendary": "#00838f", "godlike": "#006064"
        }
        iris_color = QtGui.QColor(iris_colors.get(self.tier, "#5d4037"))
        iris_grad = QtGui.QRadialGradient(cx - 7, cy - 49, 4)
        iris_grad.setColorAt(0, iris_color.lighter(130))
        iris_grad.setColorAt(1, iris_color)
        painter.setBrush(iris_grad)
        painter.drawEllipse(cx - 9, cy - 51, 6, 6)
        iris_grad2 = QtGui.QRadialGradient(cx + 6, cy - 49, 4)
        iris_grad2.setColorAt(0, iris_color.lighter(130))
        iris_grad2.setColorAt(1, iris_color)
        painter.setBrush(iris_grad2)
        painter.drawEllipse(cx + 4, cy - 51, 6, 6)
        # Pupils
        painter.setBrush(QtGui.QColor("#1a1a1a"))
        painter.drawEllipse(cx - 7, cy - 50, 3, 3)
        painter.drawEllipse(cx + 5, cy - 50, 3, 3)
        # Eye shine
        painter.setBrush(QtGui.QColor("#fff"))
        painter.drawEllipse(cx - 8, cy - 51, 2, 2)
        painter.drawEllipse(cx + 4, cy - 51, 2, 2)

        # Nose
        painter.setPen(QtGui.QPen(QtGui.QColor("#c49060"), 1))
        painter.drawLine(cx, cy - 46, cx - 1, cy - 40)
        painter.drawArc(cx - 4, cy - 40, 4, 3, 180 * 16, 180 * 16)
        painter.drawArc(cx, cy - 40, 4, 3, 180 * 16, 180 * 16)

        # Mouth (confident expressions)
        painter.setPen(QtGui.QPen(QtGui.QColor("#a06050"), 2))
        if self.tier in ["legendary", "godlike"]:
            # Big confident grin
            painter.drawArc(cx - 10, cy - 42, 20, 12, 210 * 16, 120 * 16)
            # Teeth hint
            painter.setPen(QtGui.QPen(QtGui.QColor("#fff"), 1))
            painter.drawLine(cx - 6, cy - 34, cx + 6, cy - 34)
        elif self.tier in ["epic", "heroic"]:
            # Smirk
            painter.drawArc(cx - 8, cy - 40, 16, 8, 220 * 16, 100 * 16)
        elif self.tier == "decent":
            # Slight smile
            painter.drawArc(cx - 6, cy - 38, 12, 6, 220 * 16, 100 * 16)
        else:
            # Determined/neutral
            painter.drawLine(cx - 5, cy - 36, cx + 5, cy - 36)

        # Ears (only visible when no headphones)
        helm = self.equipped.get("Helmet")
        if not helm:
            painter.setBrush(QtGui.QColor("#e6c8a0"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#c49a70"), 1))
            painter.drawEllipse(cx - 22, cy - 52, 5, 9)
            painter.drawEllipse(cx + 17, cy - 52, 5, 9)

        # 5 o'clock shadow for higher tiers (subtle)
        if self.tier in ["heroic", "epic", "legendary", "godlike"]:
            painter.setOpacity(0.15)
            painter.setBrush(QtGui.QColor("#4a3728"))
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx - 10, cy - 38, 20, 10)
            painter.setOpacity(1.0)

        # === AMULET/BADGE (ID Badge/Keycard/Award) ===
        amulet = self.equipped.get("Amulet")
        if amulet:
            ac = QtGui.QColor(amulet.get("color", "#ffd700"))
            # Lanyard
            painter.setPen(QtGui.QPen(QtGui.QColor("#2d3436"), 2))
            painter.drawLine(cx - 8, cy - 26, cx - 6, cy - 12)
            painter.drawLine(cx + 8, cy - 26, cx + 6, cy - 12)
            # ID Badge
            badge_grad = QtGui.QLinearGradient(cx - 10, cy - 12, cx + 10, cy + 8)
            badge_grad.setColorAt(0, QtGui.QColor("#fff"))
            badge_grad.setColorAt(0.3, QtGui.QColor("#f5f5f5"))
            badge_grad.setColorAt(1, QtGui.QColor("#e0e0e0"))
            painter.setBrush(badge_grad)
            painter.setPen(QtGui.QPen(QtGui.QColor("#bdbdbd"), 1))
            painter.drawRoundedRect(cx - 12, cy - 12, 24, 28, 3, 3)
            # Photo area
            painter.setBrush(QtGui.QColor("#b2bec3"))
            painter.drawRect(cx - 8, cy - 8, 16, 12)
            # Barcode
            painter.setPen(QtGui.QPen(QtGui.QColor("#2d3436"), 1))
            for i in range(8):
                x = cx - 7 + i * 2
                painter.drawLine(x, cy + 6, x, cy + 12)
            # Badge clip
            painter.setBrush(ac)
            painter.setPen(QtGui.QPen(ac.darker(130), 1))
            painter.drawRect(cx - 6, cy - 16, 12, 6)
            # Star/award indicator for high tiers
            if self.tier in ["epic", "legendary", "godlike"]:
                painter.setBrush(QtGui.QColor("#ffd700"))
                painter.setPen(QtCore.Qt.NoPen)
                painter.drawEllipse(cx + 6, cy - 10, 8, 8)

        # === WEAPON/DEVICE (Smartphone/Keyboard/Coffee Mug) ===
        weap = self.equipped.get("Weapon")
        if weap:
            wc = QtGui.QColor(weap.get("color", "#2d3436"))
            # Smartphone in hand
            phone_grad = QtGui.QLinearGradient(cx - 58, cy - 10, cx - 42, cy + 20)
            phone_grad.setColorAt(0, wc.lighter(110))
            phone_grad.setColorAt(0.5, wc)
            phone_grad.setColorAt(1, wc.darker(115))
            painter.setBrush(phone_grad)
            painter.setPen(QtGui.QPen(wc.darker(140), 2))
            # Phone body
            painter.drawRoundedRect(cx - 58, cy - 15, 18, 35, 3, 3)
            # Screen
            screen_grad = QtGui.QLinearGradient(cx - 56, cy - 12, cx - 42, cy + 15)
            screen_grad.setColorAt(0, QtGui.QColor("#4fc3f7"))
            screen_grad.setColorAt(0.5, QtGui.QColor("#29b6f6"))
            screen_grad.setColorAt(1, QtGui.QColor("#0288d1"))
            painter.setBrush(screen_grad)
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawRect(cx - 56, cy - 10, 14, 26)
            # Screen content (app icons)
            painter.setBrush(QtGui.QColor("#fff"))
            for row in range(3):
                for col in range(2):
                    painter.drawRect(cx - 55 + col * 7, cy - 8 + row * 8, 5, 5)
            # Camera notch
            painter.setBrush(wc.darker(130))
            painter.drawEllipse(cx - 51, cy - 13, 4, 3)
            # Notification badge for high tiers
            if self.tier in ["legendary", "godlike"]:
                painter.setBrush(QtGui.QColor("#e74c3c"))
                painter.drawEllipse(cx - 44, cy - 14, 6, 6)
                painter.setPen(QtGui.QPen(QtGui.QColor("#fff"), 1))
                painter.setFont(QtGui.QFont("Segoe UI", 5, QtGui.QFont.Bold))
                painter.drawText(cx - 43, cy - 8, "9")

        # === SHIELD/PROTECTION (Laptop/Tablet/Briefcase) ===
        shield = self.equipped.get("Shield")
        if shield:
            sc = QtGui.QColor(shield.get("color", "#636e72"))
            # Laptop
            laptop_grad = QtGui.QLinearGradient(cx + 28, cy - 20, cx + 70, cy + 25)
            laptop_grad.setColorAt(0, sc.lighter(115))
            laptop_grad.setColorAt(0.5, sc)
            laptop_grad.setColorAt(1, sc.darker(120))
            painter.setBrush(laptop_grad)
            painter.setPen(QtGui.QPen(sc.darker(140), 2))
            # Screen (tilted)
            screen_path = QtGui.QPainterPath()
            screen_path.moveTo(cx + 30, cy - 15)
            screen_path.lineTo(cx + 68, cy - 20)
            screen_path.lineTo(cx + 65, cy + 18)
            screen_path.lineTo(cx + 32, cy + 22)
            screen_path.closeSubpath()
            painter.drawPath(screen_path)
            # Screen display
            display_grad = QtGui.QLinearGradient(cx + 32, cy - 12, cx + 64, cy + 18)
            display_grad.setColorAt(0, QtGui.QColor("#2d3436"))
            display_grad.setColorAt(0.3, QtGui.QColor("#1e272e"))
            display_grad.setColorAt(1, QtGui.QColor("#0d1b2a"))
            painter.setBrush(display_grad)
            painter.setPen(QtCore.Qt.NoPen)
            display_path = QtGui.QPainterPath()
            display_path.moveTo(cx + 34, cy - 10)
            display_path.lineTo(cx + 64, cy - 14)
            display_path.lineTo(cx + 62, cy + 14)
            display_path.lineTo(cx + 35, cy + 18)
            display_path.closeSubpath()
            painter.drawPath(display_path)
            # Code on screen
            painter.setPen(QtGui.QPen(QtGui.QColor("#00ff88"), 1))
            for i in range(5):
                y = cy - 6 + i * 5
                w_line = 10 + (i % 3) * 5
                painter.drawLine(cx + 36, y, cx + 36 + w_line, y)
            # Keyboard base
            painter.setBrush(sc.darker(110))
            painter.setPen(QtGui.QPen(sc.darker(130), 1))
            painter.drawRect(cx + 30, cy + 24, 36, 8)
            # Keyboard keys hint
            painter.setPen(QtGui.QPen(sc.lighter(130), 1))
            for i in range(6):
                painter.drawLine(cx + 34 + i * 5, cy + 26, cx + 34 + i * 5, cy + 30)
            # Apple/brand logo
            if self.tier in ["epic", "legendary", "godlike"]:
                painter.setBrush(QtGui.QColor("#c0c0c0"))
                painter.setPen(QtCore.Qt.NoPen)
                painter.drawEllipse(cx + 46, cy - 2, 6, 6)

        # === POWER LABEL ===
        label_rect = QtCore.QRect(0, h - 28, w, 25)
        painter.fillRect(label_rect, QtGui.QColor(0, 0, 0, 120))
        
        # Power text color based on tier (no glow loop - causes double-text artifacts)
        if self.tier in ["legendary", "godlike"]:
            painter.setPen(QtGui.QColor("#ffd700"))
        elif self.tier in ["epic"]:
            painter.setPen(QtGui.QColor("#00bcd4"))
        elif self.tier in ["heroic"]:
            painter.setPen(QtGui.QColor("#4fc3f7"))
        else:
            painter.setPen(QtGui.QColor("#b2bec3"))
        
        # Draw single clean power text
        painter.setFont(QtGui.QFont("Segoe UI", 11, QtGui.QFont.Bold))
        painter.drawText(label_rect, QtCore.Qt.AlignCenter, f"üè¢ {self.power}")

    def _draw_scientist_character(self, painter: QtGui.QPainter) -> None:
        """Draw the modern research scientist character."""
        # painter = QtGui.QPainter(self)  # Uses passed painter
        painter.setRenderHint(QtGui.QPainter.Antialiasing)

        # Use canonical dimensions for drawing (scaling handled by caller)
        w, h = self.BASE_W, self.BASE_H
        cx, cy = w // 2, h // 2 + 5

        # Background with sterile laboratory gradient (cyan/green lab aesthetic)
        bg_gradient = QtGui.QLinearGradient(0, 0, 0, h)
        bg_gradient.setColorAt(0, QtGui.QColor("#004d40"))  # Dark teal
        bg_gradient.setColorAt(0.4, QtGui.QColor("#00695c"))  # Teal
        bg_gradient.setColorAt(0.7, QtGui.QColor("#00897b"))  # Light teal
        bg_gradient.setColorAt(1, QtGui.QColor("#26a69a"))  # Cyan-green
        painter.fillRect(0, 0, w, h, bg_gradient)
        
        # Lab equipment shelves in background (left side)
        painter.setOpacity(0.4)
        painter.setBrush(QtGui.QColor("#263238"))
        painter.setPen(QtGui.QPen(QtGui.QColor("#37474f"), 2))
        # Shelving unit
        painter.drawRect(10, cy - 60, 45, 90)
        painter.drawLine(10, cy - 30, 55, cy - 30)
        painter.drawLine(10, cy, 55, cy)
        # Beakers and flasks on shelves
        painter.setOpacity(0.5)
        # Top shelf - Erlenmeyer flask
        painter.setBrush(QtGui.QColor("#4fc3f7"))
        flask_path = QtGui.QPainterPath()
        flask_path.moveTo(25, cy - 55)
        flask_path.lineTo(22, cy - 45)
        flask_path.quadTo(20, cy - 35, 28, cy - 35)
        flask_path.lineTo(32, cy - 35)
        flask_path.quadTo(40, cy - 35, 38, cy - 45)
        flask_path.lineTo(35, cy - 55)
        flask_path.closeSubpath()
        painter.drawPath(flask_path)
        # Middle shelf - Beaker
        painter.setBrush(QtGui.QColor("#8bc34a"))
        painter.drawRect(18, cy - 25, 12, 18)
        painter.drawLine(18, cy - 15, 30, cy - 15)
        # Bottom shelf - Round flask
        painter.setBrush(QtGui.QColor("#ff9800"))
        painter.drawEllipse(22, cy + 5, 16, 16)
        painter.drawRect(28, cy + 3, 4, 6)
        painter.setOpacity(1.0)
        
        # Lab equipment on right side (microscope stand for high tiers)
        if self.tier in ["heroic", "epic", "legendary", "godlike"]:
            painter.setOpacity(0.35)
            painter.setBrush(QtGui.QColor("#455a64"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#607d8b"), 2))
            # Microscope base
            painter.drawRect(w - 60, cy + 10, 40, 8)
            # Stand
            painter.drawRect(w - 44, cy - 40, 8, 50)
            # Microscope body
            painter.drawEllipse(w - 50, cy - 45, 20, 15)
            painter.setOpacity(1.0)
        
        # Biohazard symbols on walls (all tiers)
        painter.setOpacity(0.25)
        painter.setBrush(QtCore.Qt.NoBrush)
        painter.setPen(QtGui.QPen(QtGui.QColor("#ffeb3b"), 2))
        # Left wall biohazard
        painter.drawEllipse(15, 25, 25, 25)
        painter.drawEllipse(22, 32, 11, 11)
        # Draw 3 biohazard segments
        for angle in [0, 120, 240]:
            painter.save()
            painter.translate(27.5, 37.5)
            painter.rotate(angle)
            painter.drawEllipse(8, -3, 6, 6)
            painter.restore()
        painter.setOpacity(1.0)
        
        # Centrifuge (spinning lab equipment) for mid+ tiers
        if self.tier not in ["pathetic", "modest"]:
            painter.setOpacity(0.3)
            painter.setBrush(QtGui.QColor("#37474f"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#546e7a"), 2))
            # Centrifuge body
            painter.drawRect(w - 55, cy - 75, 35, 25)
            # Lid with motion blur effect
            painter.setOpacity(0.15)
            for blur in range(3):
                painter.drawArc(w - 53 + blur * 2, cy - 73, 15, 15, 45 * 16, 270 * 16)
            painter.setOpacity(1.0)
        
        # Fume hood with glowing interior (epic+)
        if self.tier in ["epic", "legendary", "godlike"]:
            painter.setOpacity(0.25)
            painter.setBrush(QtGui.QColor("#263238"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#37474f"), 2))
            # Hood structure
            painter.drawRect(w - 90, 50, 70, 60)
            # Glowing interior
            fume_glow = QtGui.QRadialGradient(w - 55, 80, 30)
            fume_glow.setColorAt(0, QtGui.QColor("#00e676"))
            fume_glow.setColorAt(1, QtGui.QColor("#00695c"))
            painter.setBrush(fume_glow)
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawRect(w - 85, 55, 60, 50)
            painter.setOpacity(1.0)
        
        # Achievement certificates/awards on back wall for high tiers
        if self.tier in ["epic", "legendary", "godlike"]:
            painter.setOpacity(0.3)
            painter.setBrush(QtGui.QColor("#ffd700" if self.tier == "godlike" else "#c0c0c0"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#8b7500" if self.tier == "godlike" else "#808080"), 1))
            # Certificate frame (top right)
            painter.drawRect(w - 80, 20, 60, 45)
            painter.drawRect(w - 77, 23, 54, 39)
            # Medal/award (top left) for godlike
            if self.tier == "godlike":
                painter.setBrush(QtGui.QColor("#ffd700"))
                painter.drawEllipse(20, 15, 30, 30)
                painter.setPen(QtGui.QPen(QtGui.QColor("#ff6b6b"), 2))
                painter.drawLine(35, 45, 35, 60)
            painter.setOpacity(1.0)
        
        # Whiteboard with formulas (heroic+ tiers)
        if self.tier in ["heroic", "epic", "legendary", "godlike"]:
            painter.setOpacity(0.35)
            painter.setBrush(QtGui.QColor("#f5f5f5"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#757575"), 2))
            # Whiteboard on right wall
            painter.drawRect(w - 90, cy - 50, 70, 50)
            # Formulas written on board
            painter.setPen(QtGui.QPen(QtGui.QColor("#1e88e5"), 1))
            painter.drawText(w - 85, cy - 40, "E=mc¬≤")
            painter.drawText(w - 85, cy - 30, "ŒîG=ŒîH-TŒîS")
            painter.setPen(QtGui.QPen(QtGui.QColor("#d32f2f"), 1))
            painter.drawLine(w - 85, cy - 20, w - 35, cy - 22)
            painter.drawLine(w - 85, cy - 15, w - 50, cy - 16)
            painter.setOpacity(1.0)
        
        # Computer workstation (legendary/godlike only)
        if self.tier in ["legendary", "godlike"]:
            painter.setOpacity(0.4)
            painter.setBrush(QtGui.QColor("#263238"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#37474f"), 1))
            # Monitor
            painter.drawRect(w - 75, cy + 15, 50, 35)
            # Glowing screen
            screen_glow = QtGui.QRadialGradient(w - 50, cy + 32, 25)
            screen_glow.setColorAt(0, QtGui.QColor("#00e676"))
            screen_glow.setColorAt(1, QtGui.QColor("#00c853"))
            painter.setBrush(screen_glow)
            painter.drawRect(w - 72, cy + 18, 44, 29)
            # Data visualization on screen
            painter.setPen(QtGui.QPen(QtGui.QColor("#ffffff"), 1))
            for i in range(5):
                h = 5 + i * 3
                painter.drawLine(w - 68 + i * 8, cy + 42, w - 68 + i * 8, cy + 42 - h)
            painter.setOpacity(1.0)
        
        # Laboratory floor tiles
        painter.setPen(QtGui.QPen(QtGui.QColor(255, 255, 255, 50), 1))
        for i in range(-3, 4):
            x = cx + i * 25
            painter.drawLine(x, cy + 50, x + 12, cy + 80)
        for j in range(3):
            y = cy + 55 + j * 10
            painter.drawLine(cx - 70, y, cx + 70, y + 6)
        
        # Floor shadow (clean lab floor)
        floor_gradient = QtGui.QLinearGradient(cx - 45, cy + 65, cx + 45, cy + 80)
        floor_gradient.setColorAt(0, QtGui.QColor(50, 50, 100, 30))
        floor_gradient.setColorAt(0.5, QtGui.QColor(30, 30, 80, 90))
        floor_gradient.setColorAt(1, QtGui.QColor(50, 50, 100, 30))
        painter.setBrush(floor_gradient)
        painter.setPen(QtCore.Qt.NoPen)
        painter.drawEllipse(cx - 45, cy + 65, 90, 18)

        body_color = QtGui.QColor(self.TIER_COLORS.get(self.tier, "#bdbdbd"))
        body_outline = QtGui.QColor(self.TIER_OUTLINE.get(self.tier, "#888"))
        glow = self.TIER_GLOW.get(self.tier)

        def darken(color: str, amount: int = 130) -> QtGui.QColor:
            c = QtGui.QColor(color)
            return c.darker(amount)
        
        def lighten(color: str, amount: int = 130) -> QtGui.QColor:
            c = QtGui.QColor(color)
            return c.lighter(amount)

        # Scientific aura for high tiers (golden/quantum glow)
        if glow:
            glow_color = QtGui.QColor(glow)
            painter.setBrush(QtCore.Qt.NoBrush)
            for i, opacity in enumerate([0.08, 0.12, 0.18, 0.28]):
                painter.setOpacity(opacity)
                size = 150 - i * 18
                painter.setPen(QtGui.QPen(glow_color, 2))
                painter.drawEllipse(cx - size//2, cy - 75, size, int(size * 1.2))
            painter.setOpacity(1.0)
            # Inner scientific glow
            painter.setBrush(glow_color)
            painter.setPen(QtCore.Qt.NoPen)
            painter.setOpacity(0.18)
            painter.drawEllipse(cx - 55, cy - 65, 110, 140)
            painter.setOpacity(1.0)
        
        # Floating scientific particles (chemical formulas and periodic elements)
        particles = self.TIER_PARTICLES.get(self.tier)
        if particles:
            p_color, p_count = particles
            # Chemical formulas and periodic elements
            elements = ["H‚ÇÇO", "CO‚ÇÇ", "NaCl", "Au", "Fe", "C", "O‚ÇÇ", "N‚ÇÇ", "CH‚ÇÑ", "H‚ÇÇSO‚ÇÑ"]
            element_colors = ["#4fc3f7", "#66bb6a", "#ffa726", "#ffd700", "#ef5350", 
                            "#9e9e9e", "#42a5f5", "#ba68c8", "#26c6da", "#ffeb3b"]
            
            for i, (px, py, ps) in enumerate(self._particles[:p_count]):
                painter.setOpacity(0.55 + (i % 3) * 0.15)
                if i % 8 == 0:
                    # Periodic table element box
                    elem_color = QtGui.QColor(element_colors[i % len(element_colors)])
                    painter.setBrush(elem_color)
                    painter.setPen(QtGui.QPen(elem_color.darker(130), 1))
                    painter.drawRect(cx + px - ps*2, cy + py - ps*2, ps*4, ps*4)
                    painter.setPen(QtGui.QPen(QtGui.QColor("#fff"), 1))
                    painter.setFont(QtGui.QFont("Arial", max(6, ps)))
                    painter.drawText(cx + px - ps, cy + py + ps//2, elements[i % len(elements)][:2])
                    painter.setPen(QtCore.Qt.NoPen)
                elif i % 8 == 1:
                    # Chemical formula text
                    painter.setPen(QtGui.QPen(QtGui.QColor(p_color), 1))
                    painter.setFont(QtGui.QFont("Arial", max(7, ps + 2)))
                    painter.drawText(cx + px - ps*2, cy + py, elements[i % len(elements)])
                    painter.setPen(QtCore.Qt.NoPen)
                elif i % 8 == 2:
                    # Benzene ring (hexagon)
                    painter.setPen(QtGui.QPen(QtGui.QColor(p_color), 2))
                    painter.setBrush(QtCore.Qt.NoBrush)
                    hex_path = QtGui.QPainterPath()
                    for angle in range(0, 360, 60):
                        rad = angle * 3.14159 / 180
                        x = cx + px + ps * 2 * math.cos(rad)
                        y = cy + py + ps * 2 * math.sin(rad)
                        if angle == 0:
                            hex_path.moveTo(x, y)
                        else:
                            hex_path.lineTo(x, y)
                    hex_path.closeSubpath()
                    painter.drawPath(hex_path)
                    painter.setPen(QtCore.Qt.NoPen)
                elif i % 8 == 3:
                    # DNA helix segment
                    painter.setPen(QtGui.QPen(QtGui.QColor(p_color), 2))
                    painter.drawLine(cx + px - ps, cy + py - ps*2, cx + px + ps, cy + py + ps*2)
                    painter.drawLine(cx + px + ps, cy + py - ps*2, cx + px - ps, cy + py + ps*2)
                    painter.setPen(QtCore.Qt.NoPen)
                elif i % 8 == 4:
                    # Molecule with bonds
                    painter.setBrush(QtGui.QColor(p_color))
                    painter.drawEllipse(cx + px - ps, cy + py - ps, ps * 2, ps * 2)
                    painter.setPen(QtGui.QPen(QtGui.QColor(p_color), 1))
                    painter.drawLine(cx + px, cy + py, cx + px + ps*2, cy + py + ps*2)
                    painter.setPen(QtCore.Qt.NoPen)
                    painter.drawEllipse(cx + px + ps, cy + py + ps, ps * 2, ps * 2)
                elif i % 8 == 5:
                    # Sine wave (data visualization)
                    painter.setPen(QtGui.QPen(QtGui.QColor(p_color), 2))
                    wave_path = QtGui.QPainterPath()
                    wave_path.moveTo(cx + px - ps*2, cy + py)
                    for wx in range(-ps*2, ps*2, 2):
                        wy = ps * math.sin(wx * 0.3)
                        wave_path.lineTo(cx + px + wx, cy + py + wy)
                    painter.drawPath(wave_path)
                    painter.setPen(QtCore.Qt.NoPen)
                else:
                    # Atom with electron cloud
                    painter.setBrush(QtGui.QColor(p_color))
                    painter.drawEllipse(cx + px - ps, cy + py - ps, ps * 2, ps * 2)
                    painter.setPen(QtGui.QPen(QtGui.QColor(p_color), 1))
                    painter.drawEllipse(cx + px - ps*2, cy + py - ps//2, ps*4, ps)
                    painter.setPen(QtCore.Qt.NoPen)
            painter.setOpacity(1.0)

        # === CHESTPLATE (Lab Coat - behind body) ===
        coat = self.equipped.get("Chestplate")
        if coat:
            # Pathetic tier has old, dingy gray coat instead of white
            if self.tier == "pathetic":
                cc = QtGui.QColor("#d7ccc8")  # Dingy beige/gray
            else:
                cc = QtGui.QColor(coat.get("color", "#e8e8e8"))  # Default white lab coat
            # Professional lab coat shape
            path = QtGui.QPainterPath()
            path.moveTo(cx - 28, cy - 28)
            path.lineTo(cx + 28, cy - 28)
            path.quadTo(cx + 38, cy, cx + 36, cy + 50)
            path.lineTo(cx + 32, cy + 70)
            path.quadTo(cx, cy + 74, cx - 32, cy + 70)
            path.lineTo(cx - 36, cy + 50)
            path.quadTo(cx - 38, cy, cx - 28, cy - 28)
            # Clean lab coat gradient
            coat_gradient = QtGui.QLinearGradient(cx - 30, cy - 30, cx + 30, cy + 70)
            coat_gradient.setColorAt(0, cc.lighter(108))
            coat_gradient.setColorAt(0.5, cc)
            coat_gradient.setColorAt(1, darken(coat.get("color", "#e8e8e8"), 115))
            painter.setBrush(coat_gradient)
            painter.setPen(QtGui.QPen(darken(coat.get("color", "#e8e8e8"), 125), 2))
            painter.drawPath(path)
            # Lab coat lapels
            painter.setPen(QtGui.QPen(cc.darker(115), 2))
            painter.drawLine(cx - 12, cy - 26, cx - 18, cy + 25)
            painter.drawLine(cx + 12, cy - 26, cx + 18, cy + 25)
            # Lab coat pockets (signature feature)
            painter.setBrush(cc.darker(108))
            painter.drawRect(cx - 26, cy + 28, 14, 12)
            painter.drawRect(cx + 12, cy + 28, 14, 12)
            # Pocket details
            painter.setPen(QtGui.QPen(cc.darker(120), 1))
            painter.drawLine(cx - 26, cy + 30, cx - 12, cy + 30)
            painter.drawLine(cx + 12, cy + 30, cx + 26, cy + 30)
            # Pocket protector with multiple colored pens (iconic scientist accessory)
            if self.tier in ["heroic", "epic", "legendary", "godlike"]:
                # Pocket protector (white plastic)
                painter.setBrush(QtGui.QColor("#f5f5f5"))
                painter.setPen(QtGui.QPen(QtGui.QColor("#bdbdbd"), 1))
                painter.drawRect(cx - 26, cy + 20, 14, 18)
                # Red pen
                painter.setBrush(QtGui.QColor("#e53935"))
                painter.setPen(QtGui.QPen(QtGui.QColor("#c62828"), 1))
                painter.drawRect(cx - 24, cy + 22, 2, 8)
                painter.drawEllipse(cx - 24, cy + 21, 2, 2)
                # Blue pen
                painter.setBrush(QtGui.QColor("#1976d2"))
                painter.setPen(QtGui.QPen(QtGui.QColor("#0d47a1"), 1))
                painter.drawRect(cx - 21, cy + 24, 2, 8)
                painter.drawEllipse(cx - 21, cy + 23, 2, 2)
                # Green pen
                painter.setBrush(QtGui.QColor("#43a047"))
                painter.setPen(QtGui.QPen(QtGui.QColor("#2e7d32"), 1))
                painter.drawRect(cx - 18, cy + 22, 2, 8)
                painter.drawEllipse(cx - 18, cy + 21, 2, 2)
            elif self.tier in ["decent"]:
                # Single pen for decent tier
                painter.setBrush(QtGui.QColor("#1976d2"))
                painter.setPen(QtGui.QPen(QtGui.QColor("#0d47a1"), 1))
                painter.drawRect(cx - 24, cy + 22, 3, 8)
                painter.drawEllipse(cx - 24, cy + 20, 3, 3)
            # Lab coat stains for lower tiers (realistic research struggle)
            if self.tier == "pathetic":
                # VERY stained and worn coat - multiple large stains
                painter.setOpacity(0.6)
                painter.setBrush(QtGui.QColor("#8b4513"))
                painter.setPen(QtCore.Qt.NoPen)
                # Large coffee stain on chest
                painter.drawEllipse(cx + 12, cy - 10, 10, 10)
                painter.drawEllipse(cx - 10, cy + 5, 8, 8)
                # Chemical splash marks (multiple)
                painter.setBrush(QtGui.QColor("#ff6b6b"))
                painter.drawEllipse(cx - 22, cy + 15, 6, 6)
                painter.drawEllipse(cx - 18, cy + 20, 5, 5)
                painter.drawEllipse(cx + 18, cy + 35, 7, 7)
                # Ink stain
                painter.setBrush(QtGui.QColor("#1a237e"))
                painter.drawEllipse(cx - 20, cy - 5, 5, 8)
                # Mystery yellow stain
                painter.setBrush(QtGui.QColor("#fbc02d"))
                painter.drawEllipse(cx + 20, cy + 25, 6, 6)
                painter.setOpacity(1.0)
            elif self.tier == "modest":
                # Moderately stained
                painter.setOpacity(0.5)
                painter.setBrush(QtGui.QColor("#8b4513"))
                painter.setPen(QtCore.Qt.NoPen)
                # Coffee stains
                painter.drawEllipse(cx + 14, cy - 8, 7, 7)
                painter.drawEllipse(cx - 12, cy + 8, 5, 5)
                # Chemical splash marks
                painter.setBrush(QtGui.QColor("#ff6b6b"))
                painter.drawEllipse(cx - 18, cy + 15, 5, 5)
                painter.drawEllipse(cx - 16, cy + 18, 4, 4)
                painter.setOpacity(1.0)

        # === CLOAK (Hazmat Suit overlay for high-tier containment) ===
        cloak = self.equipped.get("Cloak")
        if cloak:
            cloak_c = QtGui.QColor(cloak.get("color", "#ffeb3b"))  # Yellow hazmat default
            painter.setOpacity(0.35)
            # Transparent hazmat suit overlay
            hazmat_grad = QtGui.QLinearGradient(cx - 35, cy - 30, cx + 35, cy + 60)
            hazmat_grad.setColorAt(0, cloak_c.lighter(120))
            hazmat_grad.setColorAt(0.5, cloak_c)
            hazmat_grad.setColorAt(1, cloak_c.darker(110))
            painter.setBrush(hazmat_grad)
            painter.setPen(QtGui.QPen(cloak_c.darker(130), 2))
            # Hazmat suit shape (wider than lab coat, more protective)
            hazmat_path = QtGui.QPainterPath()
            hazmat_path.moveTo(cx - 32, cy - 30)
            hazmat_path.lineTo(cx + 32, cy - 30)
            hazmat_path.quadTo(cx + 42, cy, cx + 40, cy + 55)
            hazmat_path.lineTo(cx + 36, cy + 72)
            hazmat_path.quadTo(cx, cy + 76, cx - 36, cy + 72)
            hazmat_path.lineTo(cx - 40, cy + 55)
            hazmat_path.quadTo(cx - 42, cy, cx - 32, cy - 30)
            hazmat_path.closeSubpath()
            painter.drawPath(hazmat_path)
            painter.setOpacity(1.0)
            # Hazmat suit seams/details
            painter.setOpacity(0.6)
            painter.setPen(QtGui.QPen(cloak_c.darker(140), 2))
            painter.drawLine(cx - 30, cy - 28, cx - 32, cy + 70)
            painter.drawLine(cx + 30, cy - 28, cx + 32, cy + 70)
            painter.drawLine(cx, cy - 28, cx, cy + 70)
            # Hazmat zipper
            painter.setPen(QtGui.QPen(QtGui.QColor("#455a64"), 2))
            for z in range(cy - 26, cy + 70, 8):
                painter.drawLine(cx - 2, z, cx + 2, z)
            painter.setOpacity(1.0)
            # Warning stripes (biohazard theme)
            painter.setOpacity(0.5)
            painter.setBrush(QtGui.QColor("#ff5722"))
            painter.setPen(QtCore.Qt.NoPen)
            for stripe in range(3):
                y_pos = cy + 15 + stripe * 20
                painter.drawRect(cx - 38, y_pos, 76, 4)
            painter.setOpacity(1.0)

        # === LEGS (Dress pants/Slacks) ===
        pants_color = QtGui.QColor("#2c3e50")
        pants_grad = QtGui.QLinearGradient(cx - 20, cy + 25, cx + 20, cy + 25)
        pants_grad.setColorAt(0, pants_color.darker(118))
        pants_grad.setColorAt(0.5, pants_color)
        pants_grad.setColorAt(1, pants_color.darker(118))
        painter.setBrush(pants_grad)
        painter.setPen(QtGui.QPen(pants_color.darker(145), 2))
        # Left leg
        left_leg = QtGui.QPainterPath()
        left_leg.moveTo(cx - 20, cy + 25)
        left_leg.lineTo(cx - 5, cy + 25)
        left_leg.lineTo(cx - 7, cy + 62)
        left_leg.lineTo(cx - 22, cy + 62)
        left_leg.closeSubpath()
        painter.drawPath(left_leg)
        # Right leg
        right_leg = QtGui.QPainterPath()
        right_leg.moveTo(cx + 5, cy + 25)
        right_leg.lineTo(cx + 20, cy + 25)
        right_leg.lineTo(cx + 22, cy + 62)
        right_leg.lineTo(cx + 7, cy + 62)
        right_leg.closeSubpath()
        painter.drawPath(right_leg)

        # === BOOTS (Comfortable sneakers - not dress shoes!) ===
        boots = self.equipped.get("Boots")
        if boots:
            bc = QtGui.QColor(boots.get("color", "#34495e"))
            boot_grad = QtGui.QLinearGradient(0, cy + 58, 0, cy + 78)
            boot_grad.setColorAt(0, bc.lighter(130))
            boot_grad.setColorAt(0.5, bc)
            boot_grad.setColorAt(1, bc.darker(118))
            painter.setBrush(boot_grad)
            painter.setPen(QtGui.QPen(bc.darker(135), 2))
            # Left sneaker - athletic style
            left_shoe = QtGui.QPainterPath()
            left_shoe.moveTo(cx - 24, cy + 62)
            left_shoe.lineTo(cx - 5, cy + 62)
            left_shoe.lineTo(cx - 3, cy + 72)
            left_shoe.quadTo(cx - 10, cy + 77, cx - 20, cy + 76)
            left_shoe.quadTo(cx - 27, cy + 72, cx - 26, cy + 65)
            left_shoe.closeSubpath()
            painter.drawPath(left_shoe)
            # Right sneaker
            right_shoe = QtGui.QPainterPath()
            right_shoe.moveTo(cx + 5, cy + 62)
            right_shoe.lineTo(cx + 24, cy + 62)
            right_shoe.quadTo(cx + 27, cy + 68, cx + 26, cy + 72)
            right_shoe.quadTo(cx + 20, cy + 77, cx + 10, cy + 76)
            right_shoe.lineTo(cx + 3, cy + 72)
            right_shoe.closeSubpath()
            painter.drawPath(right_shoe)
            # Sneaker details (rubber sole, laces)
            # Rubber sole stripe
            painter.setPen(QtGui.QPen(QtGui.QColor("#fff"), 2))
            painter.drawLine(cx - 24, cy + 70, cx - 6, cy + 72)
            painter.drawLine(cx + 6, cy + 72, cx + 24, cy + 70)
            # Laces
            painter.setPen(QtGui.QPen(bc.darker(150), 1))
            for lace_x in range(-18, -8, 4):
                painter.drawLine(cx + lace_x, cy + 64, cx + lace_x + 3, cy + 66)
            for lace_x in range(10, 20, 4):
                painter.drawLine(cx + lace_x, cy + 64, cx + lace_x + 3, cy + 66)
        else:
            # Basic sneakers
            painter.setBrush(QtGui.QColor("#546e7a"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#37474f"), 1))
            painter.drawRoundedRect(cx - 24, cy + 60, 19, 17, 6, 6)
            painter.drawRoundedRect(cx + 5, cy + 60, 19, 17, 6, 6)
            # White rubber sole
            painter.setPen(QtGui.QPen(QtGui.QColor("#fff"), 2))
            painter.drawLine(cx - 22, cy + 72, cx - 8, cy + 74)
            painter.drawLine(cx + 7, cy + 74, cx + 21, cy + 72)

        # === ARMS (Shirt sleeves under lab coat) ===
        shirt_color = QtGui.QColor("#74b9ff")
        arm_grad_l = QtGui.QLinearGradient(cx - 44, cy - 5, cx - 28, cy - 5)
        arm_grad_l.setColorAt(0, shirt_color.darker(125))
        arm_grad_l.setColorAt(0.5, shirt_color)
        arm_grad_l.setColorAt(1, shirt_color.darker(108))
        painter.setBrush(arm_grad_l)
        painter.setPen(QtGui.QPen(shirt_color.darker(145), 2))
        # Left arm
        left_arm = QtGui.QPainterPath()
        left_arm.moveTo(cx - 28, cy - 24)
        left_arm.quadTo(cx - 36, cy - 22, cx - 42, cy - 12)
        left_arm.quadTo(cx - 48, cy + 6, cx - 46, cy + 26)
        left_arm.lineTo(cx - 34, cy + 23)
        left_arm.quadTo(cx - 32, cy - 4, cx - 28, cy - 24)
        painter.drawPath(left_arm)
        # Right arm
        arm_grad_r = QtGui.QLinearGradient(cx + 28, cy - 5, cx + 44, cy - 5)
        arm_grad_r.setColorAt(0, shirt_color.darker(108))
        arm_grad_r.setColorAt(0.5, shirt_color)
        arm_grad_r.setColorAt(1, shirt_color.darker(125))
        painter.setBrush(arm_grad_r)
        right_arm = QtGui.QPainterPath()
        right_arm.moveTo(cx + 28, cy - 24)
        right_arm.quadTo(cx + 36, cy - 22, cx + 42, cy - 12)
        right_arm.quadTo(cx + 48, cy + 6, cx + 46, cy + 26)
        right_arm.lineTo(cx + 34, cy + 23)
        right_arm.quadTo(cx + 32, cy - 4, cx + 28, cy - 24)
        painter.drawPath(right_arm)

        # === GAUNTLETS (Latex Gloves) ===
        gaunt = self.equipped.get("Gauntlets")
        # Pathetic tier has no gloves - too expensive
        if self.tier == "pathetic":
            gaunt = None
        if gaunt:
            gc = QtGui.QColor(gaunt.get("color", "#b0e0ff"))  # Light blue latex default
            # Left glove
            painter.setBrush(gc)
            painter.setPen(QtGui.QPen(gc.darker(125), 1))
            left_hand = QtGui.QPainterPath()
            left_hand.moveTo(cx - 48, cy + 18)
            left_hand.quadTo(cx - 52, cy + 22, cx - 50, cy + 28)
            left_hand.quadTo(cx - 46, cy + 30, cx - 44, cy + 26)
            left_hand.quadTo(cx - 44, cy + 20, cx - 48, cy + 18)
            painter.drawPath(left_hand)
            # Glove cuff
            painter.drawRect(cx - 49, cy + 15, 10, 6)
            # Right glove
            right_hand = QtGui.QPainterPath()
            right_hand.moveTo(cx + 48, cy + 18)
            right_hand.quadTo(cx + 52, cy + 22, cx + 50, cy + 28)
            right_hand.quadTo(cx + 46, cy + 30, cx + 44, cy + 26)
            right_hand.quadTo(cx + 44, cy + 20, cx + 48, cy + 18)
            painter.drawPath(right_hand)
            painter.drawRect(cx + 39, cy + 15, 10, 6)
        else:
            # Bare hands
            painter.setBrush(QtGui.QColor("#e6c8a0"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#c9a066"), 1))
            painter.drawEllipse(cx - 48, cy + 17, 15, 13)
            painter.drawEllipse(cx + 33, cy + 17, 15, 13)

        # === TORSO (Casual untucked shirt under lab coat) ===
        torso_grad = QtGui.QLinearGradient(cx - 26, cy, cx + 26, cy)
        torso_grad.setColorAt(0, shirt_color.darker(112))
        torso_grad.setColorAt(0.3, shirt_color)
        torso_grad.setColorAt(0.7, shirt_color)
        torso_grad.setColorAt(1, shirt_color.darker(112))
        painter.setBrush(torso_grad)
        painter.setPen(QtGui.QPen(shirt_color.darker(145), 2))
        torso_path = QtGui.QPainterPath()
        torso_path.moveTo(cx - 26, cy - 28)
        torso_path.quadTo(cx - 28, cy - 7, cx - 20, cy + 28)
        torso_path.lineTo(cx + 20, cy + 28)
        torso_path.quadTo(cx + 28, cy - 7, cx + 26, cy - 28)
        torso_path.closeSubpath()
        painter.drawPath(torso_path)

        # === CHEST LAYER (Casual T-shirt or polo - NO TIE) ===
        cc = QtGui.QColor("#7e57c2") if self.tier in ["pathetic", "modest"] else QtGui.QColor("#3498db")
        chest_grad = QtGui.QLinearGradient(cx - 22, cy - 26, cx + 22, cy + 22)
        chest_grad.setColorAt(0, cc.lighter(118))
        chest_grad.setColorAt(0.5, cc)
        chest_grad.setColorAt(1, cc.darker(112))
        painter.setBrush(chest_grad)
        painter.setPen(QtGui.QPen(cc.darker(135), 2))
        # Casual shirt (untucked, wrinkled appearance)
        shirt_path = QtGui.QPainterPath()
        shirt_path.moveTo(cx - 22, cy - 26)
        shirt_path.quadTo(cx, cy - 30, cx + 22, cy - 26)
        # Untucked bottom edge showing below lab coat opening
        shirt_path.lineTo(cx + 18, cy + 26)
        shirt_path.quadTo(cx + 12, cy + 30, cx, cy + 31)  # Hanging out
        shirt_path.quadTo(cx - 12, cy + 30, cx - 18, cy + 26)
        shirt_path.closeSubpath()
        painter.drawPath(shirt_path)
        # Simple V-neck collar (casual, not button-down)
        painter.setPen(QtGui.QPen(cc.darker(125), 2))
        painter.drawLine(cx - 9, cy - 26, cx, cy - 22)
        painter.drawLine(cx + 9, cy - 26, cx, cy - 22)
        # NO TIE - scientists are casual!
        # Wrinkle lines for realism
        painter.setOpacity(0.3)
        painter.setPen(QtGui.QPen(cc.darker(120), 1))
        painter.drawLine(cx - 12, cy - 8, cx + 10, cy - 6)
        painter.drawLine(cx - 8, cy + 4, cx + 12, cy + 6)
        painter.setOpacity(1.0)

        # === SHIELD (Lab Notebook / Data Tablet) ===
        shield = self.equipped.get("Shield")
        if shield:
            sc = QtGui.QColor(shield.get("color", "#37474f"))  # Dark gray notebook default
            # Notebook/tablet held at side
            notebook_grad = QtGui.QLinearGradient(cx + 32, cy - 8, cx + 44, cy + 12)
            notebook_grad.setColorAt(0, sc.lighter(115))
            notebook_grad.setColorAt(0.5, sc)
            notebook_grad.setColorAt(1, sc.darker(115))
            painter.setBrush(notebook_grad)
            painter.setPen(QtGui.QPen(sc.darker(140), 2))
            # Notebook rectangle
            painter.drawRoundedRect(cx + 32, cy - 8, 16, 22, 2, 2)
            # Notebook binding/spine
            painter.setPen(QtGui.QPen(sc.darker(150), 3))
            painter.drawLine(cx + 33, cy - 8, cx + 33, cy + 14)
            # Page lines (scientific notes)
            painter.setPen(QtGui.QPen(sc.lighter(140), 1))
            for line_y in range(cy - 6, cy + 13, 3):
                painter.drawLine(cx + 35, line_y, cx + 46, line_y)
            # Digital variant for epic+ tiers
            if self.tier in ["epic", "legendary", "godlike"]:
                # Glowing screen effect
                painter.setOpacity(0.6)
                screen_glow = QtGui.QRadialGradient(cx + 40, cy + 3, 12)
                screen_glow.setColorAt(0, QtGui.QColor("#4fc3f7"))
                screen_glow.setColorAt(1, QtGui.QColor("#0277bd"))
                painter.setBrush(screen_glow)
                painter.setPen(QtCore.Qt.NoPen)
                painter.drawRoundedRect(cx + 34, cy - 6, 12, 18, 1, 1)
                painter.setOpacity(1.0)
                # Digital data symbols
                painter.setPen(QtGui.QPen(QtGui.QColor("#e0f7ff"), 1))
                painter.drawText(cx + 36, cy - 2, "01")
                painter.drawText(cx + 36, cy + 4, "10")
                painter.drawText(cx + 36, cy + 10, "11")

        # === WEAPON (Scientific Instrument) ===
        weap = self.equipped.get("Weapon")
        if weap:
            wc = QtGui.QColor(weap.get("color", "#78909c"))  # Steel-gray instrument default
            # Instrument held in left hand (microscope, spectrometer, pipette design)
            # Handle/grip
            handle_grad = QtGui.QLinearGradient(cx - 50, cy + 5, cx - 46, cy + 20)
            handle_grad.setColorAt(0, QtGui.QColor("#546e7a"))
            handle_grad.setColorAt(0.5, QtGui.QColor("#607d8b"))
            handle_grad.setColorAt(1, QtGui.QColor("#455a64"))
            painter.setBrush(handle_grad)
            painter.setPen(QtGui.QPen(QtGui.QColor("#37474f"), 2))
            painter.drawRoundedRect(cx - 54, cy + 8, 8, 24, 3, 3)
            # Grip texture
            painter.setPen(QtGui.QPen(QtGui.QColor("#455a64"), 1))
            for grip_line in range(cy + 10, cy + 30, 4):
                painter.drawLine(cx - 54, grip_line, cx - 46, grip_line)
            # Instrument body (varies by tier)
            body_grad = QtGui.QLinearGradient(cx - 52, cy - 12, cx - 44, cy + 8)
            body_grad.setColorAt(0, wc.lighter(125))
            body_grad.setColorAt(0.3, wc)
            body_grad.setColorAt(1, wc.darker(115))
            painter.setBrush(body_grad)
            painter.setPen(QtGui.QPen(wc.darker(135), 2))
            if self.tier in ["legendary", "godlike"]:
                # Advanced quantum analyzer
                painter.drawRoundedRect(cx - 58, cy - 14, 16, 22, 3, 3)
                # Glowing display panel
                painter.setOpacity(0.7)
                panel_glow = QtGui.QRadialGradient(cx - 50, cy - 3, 8)
                panel_glow.setColorAt(0, QtGui.QColor("#00e676"))
                panel_glow.setColorAt(1, QtGui.QColor("#00c853"))
                painter.setBrush(panel_glow)
                painter.setPen(QtCore.Qt.NoPen)
                painter.drawRect(cx - 56, cy - 10, 12, 14)
                painter.setOpacity(1.0)
                # Digital readout
                painter.setPen(QtGui.QPen(QtGui.QColor("#e0f7ff"), 1))
                painter.drawText(cx - 54, cy - 4, "99.9%")
                # Antenna/sensor array
                painter.setPen(QtGui.QPen(wc, 2))
                painter.drawLine(cx - 50, cy - 14, cx - 50, cy - 22)
                painter.drawEllipse(cx - 52, cy - 24, 4, 4)
            elif self.tier in ["epic", "heroic"]:
                # Precision spectrometer
                painter.drawRoundedRect(cx - 56, cy - 12, 14, 20, 2, 2)
                # Lens/measurement window
                painter.setBrush(QtGui.QColor("#4fc3f7"))
                painter.setPen(QtGui.QPen(QtGui.QColor("#0277bd"), 1))
                painter.drawEllipse(cx - 53, cy - 8, 8, 8)
                # Measurement dial
                painter.setPen(QtGui.QPen(wc.darker(130), 1))
                painter.drawArc(cx - 52, cy - 7, 6, 6, 0, 270 * 16)
                painter.drawLine(cx - 49, cy - 4, cx - 46, cy - 4)
            else:
                # Basic microscope/pipette
                painter.drawRoundedRect(cx - 54, cy - 10, 12, 18, 2, 2)
                # Measurement marks
                painter.setPen(QtGui.QPen(wc.darker(140), 1))
                for mark in range(cy - 8, cy + 6, 3):
                    painter.drawLine(cx - 54, mark, cx - 50, mark)
                # Glass tip (pipette style)
                painter.setBrush(QtGui.QColor("#b0e0ff"))
                painter.setPen(QtGui.QPen(QtGui.QColor("#4fc3f7"), 1))
                tip_path = QtGui.QPainterPath()
                tip_path.moveTo(cx - 51, cy + 8)
                tip_path.lineTo(cx - 49, cy + 8)
                tip_path.lineTo(cx - 49, cy + 16)
                tip_path.lineTo(cx - 50, cy + 18)
                tip_path.lineTo(cx - 51, cy + 16)
                tip_path.closeSubpath()
                painter.drawPath(tip_path)
                # Liquid drop at tip for realism
                if self.tier in ["decent", "modest", "heroic"]:
                    painter.setBrush(QtGui.QColor("#1976d2"))
                    painter.setPen(QtCore.Qt.NoPen)
                    painter.drawEllipse(cx - 51, cy + 18, 2, 3)

        # === NECK ===
        neck_grad = QtGui.QLinearGradient(cx - 9, cy - 34, cx + 9, cy - 34)
        neck_grad.setColorAt(0, QtGui.QColor("#d4b090"))
        neck_grad.setColorAt(0.5, QtGui.QColor("#e6c8a0"))
        neck_grad.setColorAt(1, QtGui.QColor("#d4b090"))
        painter.setBrush(neck_grad)
        painter.setPen(QtGui.QPen(QtGui.QColor("#c49a70"), 1))
        painter.drawRect(cx - 9, cy - 36, 18, 13)

        # === HEAD ===
        head_gradient = QtGui.QRadialGradient(cx - 5, cy - 54, 30)
        head_gradient.setColorAt(0, QtGui.QColor("#f5e0c8"))
        head_gradient.setColorAt(0.5, QtGui.QColor("#e6c8a0"))
        head_gradient.setColorAt(0.8, QtGui.QColor("#d4a870"))
        head_gradient.setColorAt(1, QtGui.QColor("#c49060"))
        painter.setBrush(head_gradient)
        painter.setPen(QtGui.QPen(QtGui.QColor("#b08050"), 2))
        head_path = QtGui.QPainterPath()
        head_path.moveTo(cx - 2, cy - 32)
        head_path.quadTo(cx - 22, cy - 35, cx - 22, cy - 52)
        head_path.quadTo(cx - 22, cy - 72, cx, cy - 72)
        head_path.quadTo(cx + 22, cy - 72, cx + 22, cy - 52)
        head_path.quadTo(cx + 22, cy - 35, cx + 2, cy - 32)
        head_path.closeSubpath()
        painter.drawPath(head_path)

        # === HELMET (Safety Goggles) ===
        helm = self.equipped.get("Helmet")
        # Pathetic tier can't afford goggles - force to basic appearance
        if self.tier == "pathetic":
            helm = None
        if helm:
            hc = QtGui.QColor(helm.get("color", "#4db8ff"))  # Light blue goggles default
            # Goggles strap
            painter.setBrush(QtCore.Qt.NoBrush)
            painter.setPen(QtGui.QPen(hc.darker(140), 3))
            painter.drawArc(cx - 24, cy - 75, 48, 32, 0, 180 * 16)
            # Left goggle lens
            painter.setBrush(hc)
            painter.setPen(QtGui.QPen(hc.darker(135), 2))
            painter.drawEllipse(cx - 24, cy - 58, 14, 12)
            # Lens reflection
            lens_grad_l = QtGui.QRadialGradient(cx - 19, cy - 54, 7)
            lens_grad_l.setColorAt(0, QtGui.QColor("#e0f7ff"))
            lens_grad_l.setColorAt(0.7, hc)
            lens_grad_l.setColorAt(1, hc.darker(125))
            painter.setBrush(lens_grad_l)
            painter.drawEllipse(cx - 23, cy - 57, 12, 10)
            # Right goggle lens
            painter.setBrush(hc)
            painter.setPen(QtGui.QPen(hc.darker(135), 2))
            painter.drawEllipse(cx + 10, cy - 58, 14, 12)
            lens_grad_r = QtGui.QRadialGradient(cx + 15, cy - 54, 7)
            lens_grad_r.setColorAt(0, QtGui.QColor("#e0f7ff"))
            lens_grad_r.setColorAt(0.7, hc)
            lens_grad_r.setColorAt(1, hc.darker(125))
            painter.setBrush(lens_grad_r)
            painter.drawEllipse(cx + 11, cy - 57, 12, 10)
            # Bridge
            painter.setPen(QtGui.QPen(hc.darker(140), 3))
            painter.drawLine(cx - 10, cy - 52, cx + 10, cy - 52)
            # Messy Einstein-style hair showing above goggles
            hair_color = QtGui.QColor("#4a3728") if self.tier not in ["legendary", "godlike"] else QtGui.QColor("#9e9e9e")  # Gray for Nobel tier
            hair_grad = QtGui.QRadialGradient(cx, cy - 67, 24)
            hair_grad.setColorAt(0, hair_color.lighter(125))
            hair_grad.setColorAt(0.6, hair_color)
            hair_grad.setColorAt(1, hair_color.darker(118))
            painter.setBrush(hair_grad)
            painter.setPen(QtCore.Qt.NoPen)
            # Messy hairstyle with wild spikes above goggles
            hair_path = QtGui.QPainterPath()
            hair_path.moveTo(cx - 22, cy - 57)
            # Left side spike
            hair_path.quadTo(cx - 28, cy - 70, cx - 24, cy - 82)
            hair_path.quadTo(cx - 18, cy - 85, cx - 14, cy - 80)
            # Center spike (Einstein wild hair)
            hair_path.quadTo(cx - 8, cy - 86, cx, cy - 88)
            hair_path.quadTo(cx + 8, cy - 86, cx + 14, cy - 80)
            # Right side spike
            hair_path.quadTo(cx + 18, cy - 85, cx + 24, cy - 82)
            hair_path.quadTo(cx + 28, cy - 70, cx + 22, cy - 57)
            hair_path.lineTo(cx + 10, cy - 58)
            hair_path.lineTo(cx - 10, cy - 58)
            hair_path.closeSubpath()
            painter.drawPath(hair_path)
            # Add individual hair strands sticking up
            painter.setPen(QtGui.QPen(hair_color.darker(130), 2))
            painter.drawLine(cx - 16, cy - 78, cx - 18, cy - 84)
            painter.drawLine(cx - 6, cy - 82, cx - 4, cy - 88)
            painter.drawLine(cx + 6, cy - 82, cx + 8, cy - 88)
            painter.drawLine(cx + 16, cy - 78, cx + 18, cy - 84)
            painter.setPen(QtCore.Qt.NoPen)
        else:
            # Messy Einstein-style hair (no goggles)
            hair_color = QtGui.QColor("#4a3728") if self.tier not in ["legendary", "godlike"] else QtGui.QColor("#9e9e9e")
            hair_grad = QtGui.QRadialGradient(cx, cy - 67, 24)
            hair_grad.setColorAt(0, hair_color.lighter(125))
            hair_grad.setColorAt(0.6, hair_color)
            hair_grad.setColorAt(1, hair_color.darker(118))
            painter.setBrush(hair_grad)
            painter.setPen(QtCore.Qt.NoPen)
            # Wild, unkempt hair
            hair_path = QtGui.QPainterPath()
            hair_path.moveTo(cx - 22, cy - 57)
            # Left spike
            hair_path.quadTo(cx - 28, cy - 72, cx - 24, cy - 84)
            hair_path.quadTo(cx - 16, cy - 87, cx - 10, cy - 82)
            # Center wild tuft
            hair_path.quadTo(cx - 6, cy - 88, cx, cy - 90)
            hair_path.quadTo(cx + 6, cy - 88, cx + 10, cy - 82)
            # Right spike
            hair_path.quadTo(cx + 16, cy - 87, cx + 24, cy - 84)
            hair_path.quadTo(cx + 28, cy - 72, cx + 22, cy - 57)
            hair_path.quadTo(cx + 20, cy - 60, cx + 14, cy - 64)
            hair_path.quadTo(cx, cy - 68, cx - 14, cy - 64)
            hair_path.quadTo(cx - 20, cy - 60, cx - 22, cy - 57)
            painter.drawPath(hair_path)
            # Wild side tufts
            painter.drawEllipse(cx - 26, cy - 62, 7, 16)
            painter.drawEllipse(cx + 19, cy - 62, 7, 16)
            # Individual strands
            painter.setPen(QtGui.QPen(hair_color.darker(130), 2))
            painter.drawLine(cx - 18, cy - 80, cx - 20, cy - 86)
            painter.drawLine(cx - 8, cy - 84, cx - 6, cy - 90)
            painter.drawLine(cx + 8, cy - 84, cx + 10, cy - 90)
            painter.drawLine(cx + 18, cy - 80, cx + 20, cy - 86)
            painter.setPen(QtCore.Qt.NoPen)

        # === FACE ===
        # Stubble for low-tier scientists (too busy to shave)
        if self.tier in ["pathetic", "modest"]:
            painter.setOpacity(0.4)
            painter.setPen(QtCore.Qt.NoPen)
            painter.setBrush(QtGui.QColor("#3e2723"))
            # Stippled beard effect
            for stubble_y in range(cy - 38, cy - 32, 2):
                for stubble_x in range(cx - 14, cx + 14, 2):
                    if (stubble_x + stubble_y) % 3 == 0:
                        painter.drawEllipse(stubble_x, stubble_y, 1, 1)
            painter.setOpacity(1.0)
        
        # Face mask hanging around neck (iconic scientist accessory)
        painter.setOpacity(0.7)
        painter.setBrush(QtGui.QColor("#e3f2fd"))
        painter.setPen(QtGui.QPen(QtGui.QColor("#90caf9"), 1))
        # Mask hanging loose
        mask_path = QtGui.QPainterPath()
        mask_path.moveTo(cx - 14, cy - 30)
        mask_path.quadTo(cx - 16, cy - 26, cx - 12, cy - 24)
        mask_path.lineTo(cx + 12, cy - 24)
        mask_path.quadTo(cx + 16, cy - 26, cx + 14, cy - 30)
        mask_path.closeSubpath()
        painter.drawPath(mask_path)
        # Elastic straps
        painter.setPen(QtGui.QPen(QtGui.QColor("#90caf9"), 1))
        painter.drawLine(cx - 14, cy - 28, cx - 20, cy - 36)
        painter.drawLine(cx + 14, cy - 28, cx + 20, cy - 36)
        # Pleats on mask
        painter.drawLine(cx - 8, cy - 27, cx - 8, cy - 25)
        painter.drawLine(cx, cy - 27, cx, cy - 25)
        painter.drawLine(cx + 8, cy - 27, cx + 8, cy - 25)
        painter.setOpacity(1.0)
        
        # Intelligent, focused eyebrows
        painter.setPen(QtGui.QPen(QtGui.QColor("#4a3728"), 2))
        if self.tier in ["legendary", "godlike"]:
            # Confident scientist brows
            painter.drawLine(cx - 13, cy - 59, cx - 5, cy - 61)
            painter.drawLine(cx + 5, cy - 61, cx + 13, cy - 59)
        elif self.tier in ["epic", "heroic"]:
            # Focused researcher brows
            painter.drawLine(cx - 13, cy - 58, cx - 5, cy - 59)
            painter.drawLine(cx + 5, cy - 59, cx + 13, cy - 58)
        else:
            # Thoughtful brows
            painter.drawLine(cx - 12, cy - 57, cx - 5, cy - 58)
            painter.drawLine(cx + 5, cy - 58, cx + 12, cy - 57)
        
        # Eyes (intelligent, observant, slightly squinted from screen work) - positioned lower when wearing goggles
        eye_y = cy - 52 if not helm else cy - 50
        painter.setBrush(QtGui.QColor("#e8dcc8"))
        painter.setPen(QtCore.Qt.NoPen)
        # Slightly narrower eyes (squinting)
        painter.drawEllipse(cx - 13, eye_y + 1, 11, 8)
        painter.drawEllipse(cx + 2, eye_y + 1, 11, 8)
        # Eye whites
        painter.setBrush(QtGui.QColor("#fff"))
        painter.drawEllipse(cx - 12, eye_y + 1, 9, 9)
        painter.drawEllipse(cx + 3, eye_y + 1, 9, 9)
        # Iris (scientific colors - deep blue for intelligence)
        iris_colors = {
            "pathetic": "#795548", "modest": "#6d4c41", "decent": "#5d4037",
            "heroic": "#1976d2", "epic": "#1565c0", "legendary": "#0d47a1", "godlike": "#01579b"
        }
        iris_color = QtGui.QColor(iris_colors.get(self.tier, "#6d4c41"))
        iris_grad = QtGui.QRadialGradient(cx - 8, eye_y + 4, 5)
        iris_grad.setColorAt(0, iris_color.lighter(135))
        iris_grad.setColorAt(1, iris_color)
        painter.setBrush(iris_grad)
        painter.drawEllipse(cx - 10, eye_y + 2, 7, 7)
        iris_grad2 = QtGui.QRadialGradient(cx + 7, eye_y + 4, 5)
        iris_grad2.setColorAt(0, iris_color.lighter(135))
        iris_grad2.setColorAt(1, iris_color)
        painter.setBrush(iris_grad2)
        painter.drawEllipse(cx + 5, eye_y + 2, 7, 7)
        # Pupils
        painter.setBrush(QtGui.QColor("#1a1a1a"))
        painter.drawEllipse(cx - 8, eye_y + 3, 3, 3)
        painter.drawEllipse(cx + 6, eye_y + 3, 3, 3)
        # Eye shine (intelligence sparkle)
        painter.setBrush(QtGui.QColor("#fff"))
        painter.drawEllipse(cx - 9, eye_y + 3, 2, 2)
        painter.drawEllipse(cx + 5, eye_y + 3, 2, 2)
        # Under-eye bags/circles for tired low-tier scientists
        if self.tier == "pathetic":
            # VERY dark, puffy bags - severe exhaustion
            painter.setOpacity(0.6)
            painter.setBrush(QtGui.QColor("#5d4037"))
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx - 13, eye_y + 8, 11, 6)
            painter.drawEllipse(cx + 2, eye_y + 8, 11, 6)
            painter.setOpacity(1.0)
            # Eye fatigue redness - severe
            painter.setOpacity(0.4)
            painter.setPen(QtGui.QPen(QtGui.QColor("#ff6b6b"), 2))
            painter.drawLine(cx - 10, eye_y + 2, cx - 6, eye_y + 4)
            painter.drawLine(cx + 5, eye_y + 2, cx + 9, eye_y + 4)
            painter.drawLine(cx - 11, eye_y + 4, cx - 8, eye_y + 6)
            painter.drawLine(cx + 6, eye_y + 4, cx + 10, eye_y + 6)
            painter.setOpacity(1.0)
        elif self.tier == "modest":
            # Moderate bags
            painter.setOpacity(0.4)
            painter.setBrush(QtGui.QColor("#8b7355"))
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawEllipse(cx - 13, eye_y + 8, 11, 4)
            painter.drawEllipse(cx + 2, eye_y + 8, 11, 4)
            painter.setOpacity(1.0)

        # Nose
        painter.setPen(QtGui.QPen(QtGui.QColor("#c49060"), 1))
        painter.drawLine(cx, cy - 46, cx - 1, cy - 40)
        painter.drawArc(cx - 4, cy - 40, 4, 3, 180 * 16, 180 * 16)
        painter.drawArc(cx, cy - 40, 4, 3, 180 * 16, 180 * 16)

        # Mouth (thoughtful, determined expressions)
        painter.setPen(QtGui.QPen(QtGui.QColor("#a06050"), 2))
        if self.tier in ["legendary", "godlike"]:
            # Satisfied breakthrough smile
            painter.drawArc(cx - 11, cy - 42, 22, 13, 210 * 16, 120 * 16)
            painter.setPen(QtGui.QPen(QtGui.QColor("#fff"), 1))
            painter.drawLine(cx - 7, cy - 34, cx + 7, cy - 34)
        elif self.tier in ["epic", "heroic"]:
            # Confident researcher smile
            painter.drawArc(cx - 9, cy - 40, 18, 9, 220 * 16, 100 * 16)
        elif self.tier == "decent":
            # Slight smile of progress
            painter.drawArc(cx - 7, cy - 38, 14, 7, 220 * 16, 100 * 16)
        elif self.tier == "modest":
            # Slight frown of frustration
            painter.drawArc(cx - 6, cy - 38, 12, 6, 30 * 16, 120 * 16)
        else:
            # Stressed/worried (pathetic tier)
            painter.drawArc(cx - 7, cy - 38, 14, 8, 20 * 16, 140 * 16)

        # Ears (visible when no goggles or above goggles)
        if not helm:
            painter.setBrush(QtGui.QColor("#e6c8a0"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#c49a70"), 1))
            painter.drawEllipse(cx - 24, cy - 54, 5, 10)
            painter.drawEllipse(cx + 19, cy - 54, 5, 10)

        # === AMULET (ID Badge / Research Credentials) ===
        amulet = self.equipped.get("Amulet")
        if amulet:
            ac = QtGui.QColor(amulet.get("color", "#ffd700"))
            # Lanyard
            painter.setPen(QtGui.QPen(QtGui.QColor("#2c3e50"), 2))
            painter.drawLine(cx - 9, cy - 28, cx - 7, cy - 14)
            painter.drawLine(cx + 9, cy - 28, cx + 7, cy - 14)
            # ID Badge/Credentials
            badge_grad = QtGui.QLinearGradient(cx - 14, cy - 14, cx + 14, cy + 10)
            badge_grad.setColorAt(0, QtGui.QColor("#fff"))
            badge_grad.setColorAt(0.3, QtGui.QColor("#f8f9fa"))
            badge_grad.setColorAt(1, QtGui.QColor("#e9ecef"))
            painter.setBrush(badge_grad)
            painter.setPen(QtGui.QPen(QtGui.QColor("#adb5bd"), 1))
            painter.drawRoundedRect(cx - 14, cy - 14, 28, 32, 3, 3)
            # Photo area
            painter.setBrush(QtGui.QColor("#ced4da"))
            painter.drawRect(cx - 10, cy - 10, 20, 14)
            # Institution logo/seal
            painter.setBrush(ac)
            painter.setPen(QtGui.QPen(ac.darker(130), 1))
            painter.drawEllipse(cx - 5, cy + 6, 10, 10)
            # Logo detail
            painter.setPen(QtGui.QPen(QtGui.QColor("#fff"), 2))
            painter.drawLine(cx - 2, cy + 11, cx + 2, cy + 11)
            painter.drawLine(cx, cy + 9, cx, cy + 13)
            # Barcode for security
            painter.setPen(QtGui.QPen(QtGui.QColor("#212529"), 1))
            for i in range(9):
                x = cx - 9 + i * 2
                painter.drawLine(x, cy + 2, x, cy + 4)
            # Security hologram for high tiers
            if self.tier in ["epic", "legendary", "godlike"]:
                painter.setBrush(QtGui.QColor("#00d9ff"))
                painter.setPen(QtCore.Qt.NoPen)
                painter.setOpacity(0.6)
                painter.drawRect(cx + 8, cy - 12, 4, 4)
                painter.setOpacity(1.0)
            # Nobel Prize indicator for godlike tier
            if self.tier == "godlike":
                painter.setBrush(QtGui.QColor("#ffd700"))
                painter.setPen(QtGui.QPen(QtGui.QColor("#b8860b"), 1))
                painter.drawEllipse(cx - 16, cy - 16, 6, 6)
                # Medal ribbon
                painter.setPen(QtGui.QPen(QtGui.QColor("#0066cc"), 2))
                painter.drawLine(cx - 13, cy - 10, cx - 13, cy - 14)

        # === WEAPON (Microscope/Lab Equipment) ===
        weap = self.equipped.get("Weapon")
        if weap:
            wc = QtGui.QColor(weap.get("color", "#546e7a"))
            # Microscope held in left hand
            # Base
            painter.setBrush(wc.darker(125))
            painter.setPen(QtGui.QPen(wc.darker(145), 2))
            painter.drawRect(cx - 62, cy + 20, 20, 8)
            # Arm/column
            painter.setBrush(wc)
            painter.drawRect(cx - 58, cy - 10, 8, 32)
            # Eyepiece
            microscope_grad = QtGui.QLinearGradient(cx - 60, cy - 18, cx - 48, cy - 10)
            microscope_grad.setColorAt(0, wc.darker(115))
            microscope_grad.setColorAt(0.5, wc)
            microscope_grad.setColorAt(1, wc.lighter(112))
            painter.setBrush(microscope_grad)
            painter.drawEllipse(cx - 62, cy - 18, 12, 10)
            # Lens turret
            painter.setBrush(wc.darker(110))
            painter.drawEllipse(cx - 59, cy + 8, 10, 8)
            # Objective lenses
            painter.setBrush(QtGui.QColor("#37474f"))
            painter.drawRect(cx - 57, cy + 14, 6, 6)
            # Stage (sample platform)
            painter.setBrush(wc.lighter(108))
            painter.drawRect(cx - 60, cy + 10, 14, 3)
            # Focus knobs
            painter.setBrush(QtGui.QColor("#263238"))
            painter.drawEllipse(cx - 48, cy + 8, 5, 5)
            painter.drawEllipse(cx - 48, cy + 14, 5, 5)
            # Light source for high tiers
            if self.tier in ["heroic", "epic", "legendary", "godlike"]:
                light_grad = QtGui.QRadialGradient(cx - 54, cy + 22, 4)
                light_grad.setColorAt(0, QtGui.QColor("#ffeb3b"))
                light_grad.setColorAt(0.5, QtGui.QColor("#fbc02d"))
                light_grad.setColorAt(1, wc.darker(110))
                painter.setBrush(light_grad)
                painter.setPen(QtCore.Qt.NoPen)
                painter.drawEllipse(cx - 57, cy + 22, 6, 6)

        # === SHIELD (Clipboard with Data Charts - iconic scientist accessory) ===
        shield = self.equipped.get("Shield")
        # Pathetic tier has no clipboard yet - using scraps of paper
        if self.tier == "pathetic":
            shield = None
        if shield:
            sc = QtGui.QColor(shield.get("color", "#795548"))  # Brown clipboard
            # Clipboard held in right hand at waist level
            # Clipboard backing board
            board_grad = QtGui.QLinearGradient(cx + 30, cy, cx + 58, cy + 35)
            board_grad.setColorAt(0, sc.lighter(118))
            board_grad.setColorAt(0.5, sc)
            board_grad.setColorAt(1, sc.darker(118))
            painter.setBrush(board_grad)
            painter.setPen(QtGui.QPen(sc.darker(135), 2))
            # Clipboard board (rectangular)
            painter.drawRoundedRect(cx + 30, cy, 28, 38, 2, 2)
            
            # Metal clip at top
            painter.setBrush(QtGui.QColor("#757575"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#424242"), 1))
            painter.drawRect(cx + 38, cy - 2, 12, 4)
            painter.drawArc(cx + 40, cy - 4, 8, 6, 0, 180 * 16)
            
            # White paper with data
            painter.setBrush(QtGui.QColor("#ffffff"))
            painter.setPen(QtCore.Qt.NoPen)
            painter.drawRect(cx + 32, cy + 4, 24, 32)
            
            # Data visualization on clipboard
            painter.setPen(QtGui.QPen(QtGui.QColor("#1e88e5"), 1))
            # Title text
            painter.setFont(QtGui.QFont("Arial", 5, QtGui.QFont.Bold))
            painter.drawText(cx + 34, cy + 8, "DATA")
            
            # Bar chart
            painter.setBrush(QtGui.QColor("#4caf50"))
            painter.setPen(QtCore.Qt.NoPen)
            bar_heights = [6, 10, 8, 12, 14] if self.tier in ["heroic", "epic", "legendary", "godlike"] else [4, 3, 5, 4, 3]
            for i, bar_h in enumerate(bar_heights):
                painter.drawRect(cx + 34 + i * 4, cy + 24 - bar_h, 3, bar_h)
            
            # Grid lines
            painter.setPen(QtGui.QPen(QtGui.QColor("#e0e0e0"), 1))
            for i in range(4):
                y_line = cy + 12 + i * 4
                painter.drawLine(cx + 34, y_line, cx + 54, y_line)
            
            # Checkboxes for low tiers (to-do list)
            if self.tier in ["pathetic", "modest", "decent"]:
                painter.setPen(QtGui.QPen(QtGui.QColor("#616161"), 1))
                painter.setBrush(QtCore.Qt.NoBrush)
                for i in range(3):
                    y_check = cy + 26 + i * 5
                    painter.drawRect(cx + 34, y_check, 3, 3)
                    # Checkmark for completed items
                    if i < 1 or self.tier == "decent":
                        painter.setPen(QtGui.QPen(QtGui.QColor("#4caf50"), 2))
                        painter.drawLine(cx + 34, y_check + 2, cx + 35, y_check + 3)
                        painter.drawLine(cx + 35, y_check + 3, cx + 37, y_check)
                        painter.setPen(QtGui.QPen(QtGui.QColor("#616161"), 1))
            
            # Coffee stain on paper for pathetic tier
            if self.tier == "pathetic":
                painter.setOpacity(0.3)
                painter.setBrush(QtGui.QColor("#8b4513"))
                painter.setPen(QtCore.Qt.NoPen)
                painter.drawEllipse(cx + 48, cy + 30, 6, 6)
                painter.setOpacity(1.0)
        else:
            # Pathetic tier - crumpled paper notes in hand (no proper clipboard)
            if self.tier == "pathetic":
                painter.setOpacity(0.8)
                painter.setBrush(QtGui.QColor("#f5f5dc"))
                painter.setPen(QtGui.QPen(QtGui.QColor("#8b7355"), 1))
                # Crumpled paper
                paper_path = QtGui.QPainterPath()
                paper_path.moveTo(cx + 38, cy + 8)
                paper_path.lineTo(cx + 50, cy + 6)
                paper_path.lineTo(cx + 52, cy + 18)
                paper_path.lineTo(cx + 48, cy + 22)
                paper_path.lineTo(cx + 40, cy + 20)
                paper_path.closeSubpath()
                painter.drawPath(paper_path)
                # Wrinkle lines
                painter.setPen(QtGui.QPen(QtGui.QColor("#9e9e9e"), 1))
                painter.drawLine(cx + 42, cy + 10, cx + 48, cy + 12)
                painter.drawLine(cx + 44, cy + 15, cx + 50, cy + 16)
                painter.setOpacity(1.0)

        # === CLOAK (Hazmat Suit overlay) ===
        cloak = self.equipped.get("Cloak")
        if cloak:
            haz = QtGui.QColor(cloak.get("color", "#cfd8dc"))
            painter.setOpacity(0.16)
            painter.setBrush(haz)
            painter.setPen(QtGui.QPen(haz.darker(130), 2))
            # Suit body overlay
            painter.drawRoundedRect(cx - 38, cy - 30, 76, 110, 10, 10)
            # Hood overlay
            painter.drawRoundedRect(cx - 28, cy - 82, 56, 60, 18, 18)
            painter.setOpacity(1.0)

        # === POWER LABEL ===
        label_rect = QtCore.QRect(0, h - 28, w, 25)
        painter.fillRect(label_rect, QtGui.QColor(0, 0, 0, 130))
        
        # Power text color based on tier (no glow loop - causes double-text artifacts)
        if self.tier in ["legendary", "godlike"]:
            painter.setPen(QtGui.QColor("#00e5ff"))
        elif self.tier in ["epic"]:
            painter.setPen(QtGui.QColor("#42a5f5"))
        elif self.tier in ["heroic"]:
            painter.setPen(QtGui.QColor("#64b5f6"))
        else:
            painter.setPen(QtGui.QColor("#90caf9"))
        
        # Draw single clean power text
        painter.setFont(QtGui.QFont("Segoe UI", 11, QtGui.QFont.Bold))
        painter.drawText(label_rect, QtCore.Qt.AlignCenter, f"üî¨ {self.power}")


class HydrationTab(QtWidgets.QWidget):
    """Hydration tracking tab - log water intake for rewards."""
    
    def __init__(self, blocker: 'BlockerCore', parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.blocker = blocker
        self._refresh_timer = QtCore.QTimer(self)
        self._refresh_timer.timeout.connect(self._refresh_display)
        self._refresh_timer.start(60000)  # Refresh every minute for countdown
        self._build_ui()
        self._refresh_display()
    
    def _build_ui(self) -> None:
        layout = QtWidgets.QVBoxLayout(self)
        layout.setSpacing(10)
        layout.setContentsMargins(15, 15, 15, 15)
        
        add_tab_help_button(layout, "water", self)
        
        # Header
        header_layout = QtWidgets.QHBoxLayout()
        header = QtWidgets.QLabel("üíß Hydration Tracker")
        header.setStyleSheet("font-size: 18px; font-weight: bold; color: #ffffff;")
        header_layout.addWidget(header)
        header_layout.addStretch()
        layout.addLayout(header_layout)
        
        # Entity perk contributors section (if any)
        self.entity_perks_container = QtWidgets.QWidget()
        self.entity_perks_layout = QtWidgets.QVBoxLayout(self.entity_perks_container)
        self.entity_perks_layout.setContentsMargins(0, 0, 0, 8)
        layout.addWidget(self.entity_perks_container)
        self._refresh_entity_perks_display()
        
        # Main content split
        content_layout = QtWidgets.QHBoxLayout()
        
        # Left: Quick log and timeline
        left_panel = QtWidgets.QGroupBox("Log Water")
        left_layout = QtWidgets.QVBoxLayout(left_panel)
        
        # Big water button
        self.water_btn = QtWidgets.QPushButton("üíß Log Glass of Water")
        self.water_btn.setMinimumHeight(60)
        self.water_btn.setStyleSheet("""
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 #4fc3f7, stop:1 #0288d1);
                color: white;
                font-size: 16px;
                font-weight: bold;
                border-radius: 10px;
                border: 2px solid #0288d1;
            }
            QPushButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 #81d4fa, stop:1 #03a9f4);
            }
            QPushButton:pressed {
                background: #0277bd;
            }
            QPushButton:disabled {
                background: #555555;
                border: 2px solid #444444;
                color: #888888;
            }
        """)
        self.water_btn.clicked.connect(self._log_water)
        left_layout.addWidget(self.water_btn)
        
        # Status/countdown label
        self.status_label = QtWidgets.QLabel("üïê Ready to log!")
        self.status_label.setStyleSheet("font-size: 14px; font-weight: bold; color: #4caf50;")
        self.status_label.setAlignment(QtCore.Qt.AlignCenter)
        left_layout.addWidget(self.status_label)
        
        # Today's progress
        progress_group = QtWidgets.QGroupBox("Today's Progress")
        progress_layout = QtWidgets.QVBoxLayout(progress_group)
        
        self.glasses_label = QtWidgets.QLabel("0 / 5 glasses")
        self.glasses_label.setStyleSheet("font-size: 24px; font-weight: bold; color: #4fc3f7;")
        self.glasses_label.setAlignment(QtCore.Qt.AlignCenter)
        progress_layout.addWidget(self.glasses_label)
        
        self.progress_bar = QtWidgets.QProgressBar()
        self.progress_bar.setMaximum(HYDRATION_MAX_DAILY_GLASSES)
        self.progress_bar.setValue(0)
        self.progress_bar.setTextVisible(False)
        self.progress_bar.setStyleSheet("""
            QProgressBar {
                background: #2d3436;
                border: 1px solid #4fc3f7;
                border-radius: 5px;
                height: 20px;
            }
            QProgressBar::chunk {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #4fc3f7, stop:1 #0288d1);
                border-radius: 4px;
            }
        """)
        progress_layout.addWidget(self.progress_bar)
        
        left_layout.addWidget(progress_group)
        
        # Timeline graph
        timeline_group = QtWidgets.QGroupBox("üìä Today's Timeline")
        timeline_layout = QtWidgets.QVBoxLayout(timeline_group)
        
        self.timeline_widget = HydrationTimelineWidget()
        self.timeline_widget.setMinimumHeight(80)
        timeline_layout.addWidget(self.timeline_widget)
        
        left_layout.addWidget(timeline_group)
        
        # Rewards info
        rewards_group = QtWidgets.QGroupBox("üéÅ Rewards Info")
        rewards_layout = QtWidgets.QVBoxLayout(rewards_group)
        rewards_info = QtWidgets.QLabel(
            "<b>How it works:</b><br>"
            "‚Ä¢ Max 5 glasses/day (safe hydration)<br>"
            "‚Ä¢ Wait 2 hours between glasses<br>"
            "‚Ä¢ Each glass increases reward tier!<br><br>"
            "<b>üíß Per-Glass Reward:</b><br>"
            "<table style='font-size:10px; color:#888888;'>"
            "<tr><th>Glass</th><th>Center Tier</th></tr>"
            "<tr><td>1st</td><td>Common-centered</td></tr>"
            "<tr><td>2nd</td><td>Uncommon-centered</td></tr>"
            "<tr><td>3rd</td><td>Rare-centered</td></tr>"
            "<tr><td>4th</td><td>Epic-centered</td></tr>"
            "<tr><td>5th</td><td>100% Legendary!</td></tr>"
            "</table>"
            "<br><b>üî• Streaks (5 glasses/day):</b><br>"
            "3d=Uncommon, 7d=Rare, 14d=Epic, 30d=Legendary"
        )
        rewards_info.setWordWrap(True)
        rewards_info.setStyleSheet("color: #888888; font-size: 10px;")
        rewards_layout.addWidget(rewards_info)
        left_layout.addWidget(rewards_group)
        
        left_layout.addStretch()
        content_layout.addWidget(left_panel)
        
        # Right: Stats and history
        right_panel = QtWidgets.QGroupBox("Stats & History")
        right_layout = QtWidgets.QVBoxLayout(right_panel)
        
        self.stats_label = QtWidgets.QLabel("Loading stats...")
        self.stats_label.setWordWrap(True)
        self.stats_label.setStyleSheet("font-size: 12px;")
        right_layout.addWidget(self.stats_label)
        
        # History list
        history_label = QtWidgets.QLabel("<b>Recent History:</b>")
        right_layout.addWidget(history_label)
        
        self.history_list = QtWidgets.QListWidget()
        self.history_list.setMaximumHeight(200)
        self.history_list.setStyleSheet("""
            QListWidget {
                background: #2d3436;
                border: 1px solid #4a5568;
                border-radius: 5px;
            }
            QListWidget::item {
                padding: 5px;
                border-bottom: 1px solid #3d4852;
            }
        """)
        right_layout.addWidget(self.history_list)
        
        right_layout.addStretch()
        content_layout.addWidget(right_panel)
        
        layout.addLayout(content_layout)
        
        # Reminder Settings Section
        reminder_layout = QtWidgets.QHBoxLayout()
        self.reminder_checkbox = QtWidgets.QCheckBox("üîî Remind me every")
        self.reminder_checkbox.setChecked(getattr(self.blocker, 'water_reminder_enabled', False))
        self.reminder_checkbox.stateChanged.connect(self._update_reminder_setting)
        reminder_layout.addWidget(self.reminder_checkbox)
        
        self.reminder_interval = NoScrollSpinBox()
        self.reminder_interval.setRange(15, 180)
        self.reminder_interval.setValue(getattr(self.blocker, 'water_reminder_interval', 60))
        self.reminder_interval.setSuffix(" min")
        self.reminder_interval.valueChanged.connect(self._update_reminder_setting)
        reminder_layout.addWidget(self.reminder_interval)
        
        reminder_layout.addWidget(QtWidgets.QLabel("via:"))
        self.reminder_type_combo = NoScrollComboBox()
        self.reminder_type_combo.addItems(["Toast", "Voice", "Sound", "Sound + Voice"])
        # Load saved notification type
        saved_type = getattr(self.blocker, 'water_reminder_notification_type', 'Toast')
        idx = self.reminder_type_combo.findText(saved_type)
        if idx >= 0:
            self.reminder_type_combo.setCurrentIndex(idx)
        self.reminder_type_combo.currentTextChanged.connect(self._update_reminder_setting)
        self.reminder_type_combo.setMinimumWidth(110)
        reminder_layout.addWidget(self.reminder_type_combo)
        
        reminder_layout.addStretch()
        layout.addLayout(reminder_layout)
    
    def _update_reminder_setting(self) -> None:
        """Save reminder settings when changed."""
        from datetime import datetime
        
        was_enabled = getattr(self.blocker, 'water_reminder_enabled', False)
        now_enabled = self.reminder_checkbox.isChecked()
        
        self.blocker.water_reminder_enabled = now_enabled
        self.blocker.water_reminder_interval = self.reminder_interval.value()
        
        # Save notification type preference
        if hasattr(self, 'reminder_type_combo'):
            self.blocker.water_reminder_notification_type = self.reminder_type_combo.currentText()
        
        # If user just enabled reminders, set the last reminder time to now
        # so the first reminder fires after the full interval (not immediately)
        if now_enabled and not was_enabled:
            self.blocker.water_last_reminder_time = datetime.now().isoformat()
        
        self.blocker.save_config()
    
    def _log_water(self) -> None:
        """Log a glass of water with animated lottery for reward."""
        from datetime import datetime
        from app_utils import get_activity_date
        
        # Initialize water entries if needed
        if not hasattr(self.blocker, 'water_entries'):
            self.blocker.water_entries = []
        
        # Initialize lottery attempts counter if needed
        if not hasattr(self.blocker, 'water_lottery_attempts'):
            self.blocker.water_lottery_attempts = 0
        
        # Check if we can log (with entity perk support)
        hydration_perks_active = False
        if can_log_water:
            check = can_log_water(self.blocker.water_entries, adhd_buster=self.blocker.adhd_buster)
            if not check["can_log"]:
                show_info(self, "Hydration", check["reason"])
                return
            # Track if entity perks are helping with hydration
            hydration_perks_active = check.get("perk_bonus_applied", False)
        
        now = datetime.now()
        # Use activity date (5 AM cutoff) for daily tracking
        today = get_activity_date(now)
        
        # Count today's glasses (before this one)
        glasses_today = sum(
            1 for e in self.blocker.water_entries 
            if e.get("date") == today
        )
        glass_number = glasses_today + 1  # This glass
        
        # Show animated lottery dialog
        if GAMIFICATION_AVAILABLE:
            from lottery_animation import WaterLotteryDialog
            
            active_story = self.blocker.adhd_buster.get("active_story", "warrior")
            lottery = WaterLotteryDialog(
                glass_number=glass_number,
                lottery_attempts=self.blocker.water_lottery_attempts,
                story_id=active_story,
                parent=self
            )
            
            lottery.exec()
            won, tier, item, new_attempts = lottery.get_results()
            
            # Update attempt counter
            self.blocker.water_lottery_attempts = new_attempts
            
            # Log the water entry
            entry = {
                "date": today,
                "time": now.strftime("%H:%M"),
                "glasses": 1
            }
            self.blocker.water_entries.append(entry)
            # Prune to last 2000 entries (~1 year at 5 glasses/day)
            if len(self.blocker.water_entries) > 2000:
                self.blocker.water_entries = self.blocker.water_entries[-2000:]
            
            # Emit water changed signal for timeline update
            main_window = self.window()
            game_state = getattr(main_window, 'game_state', None)
            if game_state and hasattr(game_state, 'notify_water_changed'):
                game_state.notify_water_changed(glass_number)
            
            # Award item if won
            if won and item:
                item["source"] = f"hydration_glass_{glass_number}"
                
                main_window = self.window()
                game_state = getattr(main_window, 'game_state', None)
                if game_state:
                    # Capture equipped state before award
                    equipped_before = dict(self.blocker.adhd_buster.get("equipped", {}))
                    
                    award_result = game_state.award_items_batch([item], coins=0, auto_equip=True, source="hydration_tracking")
                    
                    # Get the slots that were actually auto-equipped
                    equipped_after = game_state.adhd_buster.get("equipped", {})
                    auto_equipped_slots = [i.get("slot") for i in award_result.get("equipped", []) if i.get("slot")]
                    
                    if GAMIFICATION_AVAILABLE:
                        sync_hero_data(self.blocker.adhd_buster)
                    
                    # Show ItemRewardDialog with comparison and proper auto-equip tracking
                    from styled_dialog import ItemRewardDialog
                    dialog = ItemRewardDialog(
                        parent=self,
                        title="üíß Hydration Reward!",
                        header_emoji="üíß",
                        source_label=f"Glass #{glass_number} Lottery Win!",
                        items_earned=[item],
                        equipped=equipped_before,
                        equipped_after=equipped_after,
                        auto_equipped_slots=auto_equipped_slots,
                        game_state=game_state
                    )
                    dialog.exec()
            
            # Check streak bonus (when completing 5 glasses)
            if glass_number >= 5:
                streak_days = self._calculate_streak()
                if streak_days > 0 and get_hydration_streak_bonus_rarity:
                    streak_rarity = get_hydration_streak_bonus_rarity(streak_days + 1)
                    if streak_rarity:
                        from gamification import generate_item
                        streak_item = generate_item(rarity=streak_rarity, story_id=active_story)
                        streak_item["source"] = "hydration_streak"
                        
                        main_window = self.window()
                        game_state = getattr(main_window, 'game_state', None)
                        if game_state:
                            # Capture equipped state before award
                            equipped_before = dict(self.blocker.adhd_buster.get("equipped", {}))
                            
                            award_result = game_state.award_items_batch([streak_item], coins=0, auto_equip=True, source="hydration_streak")
                            
                            # Get the slots that were actually auto-equipped
                            equipped_after = game_state.adhd_buster.get("equipped", {})
                            auto_equipped_slots = [i.get("slot") for i in award_result.get("equipped", []) if i.get("slot")]
                            
                            # Show ItemRewardDialog with comparison
                            from styled_dialog import ItemRewardDialog
                            dialog = ItemRewardDialog(
                                parent=self,
                                title="üíß Hydration Streak Bonus!",
                                header_emoji="üíß",
                                source_label=f"üî• {streak_days + 1}-day Hydration Streak!",
                                items_earned=[streak_item],
                                equipped=equipped_before,
                                equipped_after=equipped_after,
                                auto_equipped_slots=auto_equipped_slots,
                                game_state=game_state
                            )
                            dialog.exec()
            
            self.blocker.save_config()
            
            # Show perk toast if entity perks helped with hydration
            if hydration_perks_active:
                from gamification import get_hydration_cooldown_minutes, get_hydration_daily_cap, HYDRATION_MIN_INTERVAL_HOURS, HYDRATION_MAX_DAILY_GLASSES
                cooldown = get_hydration_cooldown_minutes(self.blocker.adhd_buster)
                cap = get_hydration_daily_cap(self.blocker.adhd_buster)
                perk_parts = []
                if cooldown < HYDRATION_MIN_INTERVAL_HOURS * 60:
                    perk_parts.append(f"{int(HYDRATION_MIN_INTERVAL_HOURS * 60) - cooldown} min faster")
                if cap > HYDRATION_MAX_DAILY_GLASSES:
                    perk_parts.append(f"+{cap - HYDRATION_MAX_DAILY_GLASSES} daily glasses")
                if perk_parts:
                    show_perk_toast(f"Hydration Perks: {', '.join(perk_parts)}", "üíß", self)
            
            # Award city water resource
            if CITY_AVAILABLE:
                try:
                    from city import add_city_resource, get_resources
                    add_city_resource(self.blocker.adhd_buster, "water", 1)
                    
                    # Show city stockpile toast (water is always stockpiled, never flows to buildings)
                    resources = get_resources(self.blocker.adhd_buster)
                    total_water = resources.get("water", 0)
                    show_perk_toast(f"üèóÔ∏è +1 Water stockpiled ({total_water} total)", "üíß", self)
                except Exception:
                    pass
        else:
            # Fallback without gamification
            entry = {
                "date": today,
                "time": now.strftime("%H:%M"),
                "glasses": 1
            }
            self.blocker.water_entries.append(entry)
            # Prune to last 2000 entries (~1 year at 5 glasses/day)
            if len(self.blocker.water_entries) > 2000:
                self.blocker.water_entries = self.blocker.water_entries[-2000:]
            self.blocker.save_config()
            show_info(self, "Water Logged! üíß", f"üíß Glass #{glass_number} logged!")
        
        self._refresh_display()

    def _calculate_streak(self) -> int:
        """Calculate current hydration streak (5 glasses/day)."""
        from datetime import datetime, timedelta
        
        if not hasattr(self.blocker, 'water_entries') or not self.blocker.water_entries:
            return 0
        
        # Group by date
        daily_totals = {}
        for entry in self.blocker.water_entries:
            date = entry.get("date", "")
            if date:
                daily_totals[date] = daily_totals.get(date, 0) + entry.get("glasses", 1)
        
        # Count consecutive days with 5 glasses
        streak = 0
        check_date = datetime.now().date() - timedelta(days=1)  # Start from yesterday
        max_streak_check = 365  # Max 1 year (realistic maximum streak to display)
        
        while streak < max_streak_check:
            date_str = check_date.strftime("%Y-%m-%d")
            if daily_totals.get(date_str, 0) >= HYDRATION_MAX_DAILY_GLASSES:
                streak += 1
                check_date -= timedelta(days=1)
            else:
                break
        
        return streak
    
    def _refresh_display(self) -> None:
        """Refresh stats and history display."""
        from datetime import datetime
        from gamification import get_hydration_daily_cap
        from app_utils import get_activity_date
        
        # Use activity date (5 AM cutoff) for daily tracking
        today = get_activity_date()
        
        if not hasattr(self.blocker, 'water_entries'):
            self.blocker.water_entries = []
        
        # Get perk-modified daily cap
        daily_cap = get_hydration_daily_cap(self.blocker.adhd_buster) if get_hydration_daily_cap else HYDRATION_MAX_DAILY_GLASSES
        
        # Get today's entries
        today_entries = [e for e in self.blocker.water_entries if e.get("date") == today]
        glasses_today = len(today_entries)
        
        # Update progress display (use perk-modified cap)
        cap_label = f"{glasses_today} / {daily_cap} glasses"
        if daily_cap > HYDRATION_MAX_DAILY_GLASSES:
            cap_label += " ‚ú®"  # Entity perk indicator
        self.glasses_label.setText(cap_label)
        self.progress_bar.setMaximum(daily_cap)
        self.progress_bar.setValue(min(glasses_today, daily_cap))
        
        if glasses_today >= daily_cap:
            self.glasses_label.setStyleSheet("font-size: 24px; font-weight: bold; color: #4caf50;")
        else:
            self.glasses_label.setStyleSheet("font-size: 24px; font-weight: bold; color: #4fc3f7;")
        
        # Update status/countdown (with entity perk support)
        if can_log_water:
            check = can_log_water(self.blocker.water_entries, adhd_buster=self.blocker.adhd_buster)
            if check["can_log"]:
                self.water_btn.setEnabled(True)
                self.status_label.setText("‚úÖ Ready to log!")
                self.status_label.setStyleSheet("font-size: 14px; font-weight: bold; color: #4caf50;")
            else:
                if check.get("minutes_remaining", 0) > 0:
                    mins = check["minutes_remaining"]
                    next_time = check.get("next_available_time", "")
                    status_text = f"‚è≥ Wait {mins} min (next at {next_time})"
                    if check.get("perk_bonus_applied"):
                        status_text = status_text.replace("‚è≥", "‚è≥‚ú®")  # Perk indicator
                    self.water_btn.setEnabled(False)
                    self.status_label.setText(status_text)
                    self.status_label.setStyleSheet("font-size: 14px; font-weight: bold; color: #ff9800;")
                else:
                    self.water_btn.setEnabled(False)
                    self.status_label.setText("üéØ Daily goal complete!")
                    self.status_label.setStyleSheet("font-size: 14px; font-weight: bold; color: #4caf50;")
        
        # Update timeline
        times_today = [e.get("time", "") for e in today_entries if e.get("time")]
        self.timeline_widget.set_times(times_today)
        
        # Update stats
        if get_hydration_stats:
            stats = get_hydration_stats(self.blocker.water_entries)
            streak = stats.get("current_streak", 0)
            streak_emoji = "üî•" if streak >= 3 else "üìä"
            
            self.stats_label.setText(
                f"<b>üìä Your Hydration Stats</b><br><br>"
                f"üíß Total glasses: {stats.get('total_glasses', 0)}<br>"
                f"üìÖ Days tracked: {stats.get('total_days', 0)}<br>"
                f"‚è∞ Average daily: {stats.get('avg_daily', 0):.1f} glasses<br>"
                f"üéØ Days on target ({daily_cap}+): {stats.get('days_on_target', 0)} "
                f"({stats.get('target_rate', 0):.0f}%)<br>"
                f"{streak_emoji} Current streak: {streak} days"
            )
        else:
            self.stats_label.setText("Stats unavailable")
        
        # Update history
        self.history_list.clear()
        
        # Group entries by date
        daily_totals = {}
        for entry in self.blocker.water_entries:
            date = entry.get("date", "")
            if date:
                daily_totals[date] = daily_totals.get(date, 0) + entry.get("glasses", 1)
        
        # Show last 10 days
        for date in sorted(daily_totals.keys(), reverse=True)[:10]:
            glasses = daily_totals[date]
            icon = "‚úÖ" if glasses >= HYDRATION_MAX_DAILY_GLASSES else "üíß"
            item = QtWidgets.QListWidgetItem(f"{icon} {date}: {glasses} glasses")
            self.history_list.addItem(item)
        
        # Update main timeline widget if parent window has it
        if self.parent() and hasattr(self.parent(), 'timeline_widget'):
            try:
                self.parent().timeline_widget.update_data()
            except Exception:
                pass
    
    def _refresh_entity_perks_display(self) -> None:
        """Refresh the entity perks display showing which entities boost hydration."""
        # Clear existing content
        while self.entity_perks_layout.count():
            item = self.entity_perks_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        try:
            from gamification import get_entity_hydration_perk_contributors
            
            perks = get_entity_hydration_perk_contributors(self.blocker.adhd_buster)
            contributors = perks.get("contributors", [])
            
            if not contributors:
                self.entity_perks_container.hide()
                return
            
            self.entity_perks_container.show()
            
            # Create title with totals
            total_cd = perks.get("total_cooldown_reduction", 0)
            total_cap = perks.get("total_cap_bonus", 0)
            parts = []
            if total_cd > 0:
                parts.append(f"-{total_cd}min cooldown")
            if total_cap > 0:
                parts.append(f"+{total_cap} cap")
            title_text = f"‚ú® Entity Patrons ({', '.join(parts)})" if parts else "‚ú® Entity Patrons"
            
            title = QtWidgets.QLabel(title_text)
            title.setStyleSheet("color: #888; font-size: 10px; font-weight: bold;")
            self.entity_perks_layout.addWidget(title)
            
            # Create mini-cards using shared function
            from merge_dialog import create_entity_perk_mini_cards
            perk_labels = {
                "cooldown": "‚è±Ô∏è",
                "cap": "ü•õ",
            }
            cards_widget = create_entity_perk_mini_cards(contributors, perk_labels)
            if cards_widget:
                self.entity_perks_layout.addWidget(cards_widget)
                
        except Exception as e:
            print(f"[Hydration] Error refreshing entity perks: {e}")
            self.entity_perks_container.hide()


class HydrationTimelineWidget(QtWidgets.QWidget):
    """Custom widget to show water intake timeline for the day."""
    
    def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self._times: list = []  # List of "HH:MM" strings
        self.setMinimumHeight(60)
    
    def set_times(self, times: list) -> None:
        """Set the times when water was logged."""
        self._times = times
        self.update()
    
    def paintEvent(self, event) -> None:
        """Draw the timeline."""
        from datetime import datetime
        
        painter = QtGui.QPainter(self)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        
        rect = self.rect()
        margin = 30
        timeline_y = rect.height() // 2
        
        # Draw timeline background
        painter.setPen(QtGui.QPen(QtGui.QColor("#4a5568"), 2))
        painter.drawLine(margin, timeline_y, rect.width() - margin, timeline_y)
        
        # Draw hour markers (6am to 10pm)
        start_hour = 6
        end_hour = 22
        total_hours = end_hour - start_hour
        timeline_width = rect.width() - 2 * margin
        
        painter.setPen(QtGui.QColor("#666666"))
        painter.setFont(QtGui.QFont("Segoe UI", 8))
        
        for h in range(start_hour, end_hour + 1, 2):
            x = margin + (h - start_hour) / total_hours * timeline_width
            painter.drawLine(int(x), timeline_y - 5, int(x), timeline_y + 5)
            painter.drawText(int(x) - 10, timeline_y + 20, f"{h:02d}")
        
        # Draw water drops at logged times
        drop_color = QtGui.QColor("#4fc3f7")
        painter.setBrush(drop_color)
        painter.setPen(QtGui.QPen(QtGui.QColor("#0288d1"), 2))
        
        for time_str in self._times:
            try:
                h, m = map(int, time_str.split(":"))
                hour_decimal = h + m / 60.0
                
                if start_hour <= hour_decimal <= end_hour:
                    x = margin + (hour_decimal - start_hour) / total_hours * timeline_width
                    # Draw water drop
                    painter.drawEllipse(int(x) - 8, timeline_y - 20, 16, 16)
                    # Draw time label
                    painter.setPen(QtGui.QColor("#4fc3f7"))
                    painter.drawText(int(x) - 15, timeline_y - 25, time_str)
                    painter.setPen(QtGui.QPen(QtGui.QColor("#0288d1"), 2))
            except (ValueError, AttributeError):
                continue
        
        # Draw current time marker
        now = datetime.now()
        current_hour = now.hour + now.minute / 60.0
        if start_hour <= current_hour <= end_hour:
            x = margin + (current_hour - start_hour) / total_hours * timeline_width
            painter.setPen(QtGui.QPen(QtGui.QColor("#ff9800"), 2))
            painter.drawLine(int(x), timeline_y - 15, int(x), timeline_y + 15)
        
        painter.end()


# ============================================================================
# Power Analysis Dialog
# ============================================================================

class PowerAnalysisDialog(StyledDialog):
    """
    Industry-standard Power Analysis Dialog.
    
    Shows comprehensive breakdown of hero power with:
    - Total power header with formula breakdown
    - Equipment table with power per slot
    - Entity Patrons section (power from collected entities)
    - Lucky Bonuses section (coin/XP/merge luck from gear)
    - Set Bonuses section (active and potential sets)
    - Style Bonus section (only if discovered - easter egg)
    - Tips for improvement
    """
    
    # Rarity colors for consistent display
    RARITY_COLORS = {
        "Common": "#9e9e9e",
        "Uncommon": "#4caf50", 
        "Rare": "#2196f3",
        "Epic": "#9c27b0",
        "Legendary": "#ff9800"
    }
    
    # Max power per slot by rarity
    RARITY_POWER = {
        "Common": 10,
        "Uncommon": 25,
        "Rare": 50,
        "Epic": 100,
        "Legendary": 250
    }
    
    def __init__(self, breakdown: dict, equipped: dict, parent=None, *,
                 entity_power_info: dict = None,
                 lucky_bonuses: dict = None,
                 potential_sets: list = None,
                 style_discovered: bool = False,
                 story_id: str = None):
        self.breakdown = breakdown
        self.equipped = equipped
        self.entity_power_info = entity_power_info or {}
        self.lucky_bonuses = lucky_bonuses or {}
        self.potential_sets = potential_sets or []
        self.style_discovered = style_discovered
        self._story_id = story_id  # For themed slot names
        super().__init__(parent, "‚öîÔ∏è Power Analysis", "üìä", 750, 850, closable=True)
        self.setMinimumSize(700, 600)

    def _build_content(self, layout: QtWidgets.QVBoxLayout) -> None:
        # Create scrollable area for all content
        scroll = QtWidgets.QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("QScrollArea { border: none; background: transparent; }")
        scroll.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        
        content = QtWidgets.QWidget()
        content_layout = QtWidgets.QVBoxLayout(content)
        content_layout.setSpacing(12)
        content_layout.setContentsMargins(5, 5, 5, 5)
        
        # === SECTION 1: Power Summary Header ===
        self._build_power_header(content_layout)
        
        # === SECTION 2: Equipment Breakdown ===
        self._build_equipment_section(content_layout)
        
        # === SECTION 3: Entity Patrons (Power from Entities) ===
        self._build_entity_patrons_section(content_layout)
        
        # === SECTION 4: Set Bonuses ===
        self._build_set_bonuses_section(content_layout)
        
        # === SECTION 5: Style Bonus (Easter Egg - only if discovered) ===
        if self.style_discovered:
            self._build_style_bonus_section(content_layout)
        
        # === SECTION 6: Lucky Bonuses from Gear ===
        self._build_lucky_bonuses_section(content_layout)
        
        # === SECTION 7: Power Potential & Tips ===
        self._build_tips_section(content_layout)
        
        content_layout.addStretch()
        scroll.setWidget(content)
        layout.addWidget(scroll, 1)
        
        # Close button
        self.add_button_row(layout, [("Close", "primary", self.accept)])
    
    def _create_section_header(self, title: str, icon: str = "") -> QtWidgets.QLabel:
        """Create a styled section header."""
        header = QtWidgets.QLabel(f"{icon} {title}" if icon else title)
        header.setStyleSheet("""
            font-size: 14px;
            font-weight: bold;
            color: #e0e0e0;
            padding: 8px 0px 4px 0px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        """)
        return header
    
    def _create_info_card(self, bg_color: str = "rgba(0,0,0,0.2)", border_color: str = "transparent") -> tuple:
        """Create a styled card widget and its layout."""
        card = QtWidgets.QWidget()
        card.setStyleSheet(f"""
            background-color: {bg_color};
            border: 1px solid {border_color};
            border-radius: 8px;
            padding: 8px;
        """)
        card_layout = QtWidgets.QVBoxLayout(card)
        card_layout.setSpacing(6)
        card_layout.setContentsMargins(10, 8, 10, 8)
        return card, card_layout
    
    def _build_power_header(self, layout: QtWidgets.QVBoxLayout) -> None:
        """Build the power summary header with total and formula."""
        breakdown = self.breakdown
        
        total = breakdown.get("total_power", 0)
        base = breakdown.get("base_power", 0)
        set_bonus = breakdown.get("set_bonus", 0)
        style_bonus = breakdown.get("style_bonus", 0) if self.style_discovered else 0
        entity_bonus = breakdown.get("entity_bonus", 0)
        city_power_bonus = breakdown.get("city_power_bonus", 0)
        style_info = breakdown.get("style_info")
        
        # Calculate max potential (8 legendary slots = 2000 base)
        max_base = 8 * self.RARITY_POWER["Legendary"]  # 2000
        
        # Header card with gradient
        header_card, header_layout = self._create_info_card("rgba(255,215,0,0.1)", "#FFD700")
        
        # Total Power - large display
        total_row = QtWidgets.QHBoxLayout()
        total_label = QtWidgets.QLabel("Total Power")
        total_label.setStyleSheet("font-size: 16px; color: #b0b0b0; background: transparent;")
        total_value = QtWidgets.QLabel(f"{total:,}")
        total_value.setStyleSheet("font-size: 36px; font-weight: bold; color: #FFD700; background: transparent;")
        total_row.addWidget(total_label)
        total_row.addStretch()
        total_row.addWidget(total_value)
        header_layout.addLayout(total_row)
        
        # Power formula breakdown
        formula_parts = []
        formula_parts.append(f"<span style='color:#64b5f6;'>‚öîÔ∏è Gear: {base}</span>")
        if set_bonus > 0:
            formula_parts.append(f"<span style='color:#81c784;'>üéØ Sets: +{set_bonus}</span>")
        if style_bonus > 0 and style_info and style_info.get("style"):
            style_name = style_info['style'].get('name', 'Style')
            formula_parts.append(f"<span style='color:#FFD700;'>üëë {style_name}: +{style_bonus}</span>")
        if entity_bonus > 0:
            formula_parts.append(f"<span style='color:#ce93d8;'>üêæ Patrons: +{entity_bonus}</span>")
        if city_power_bonus > 0:
            formula_parts.append(f"<span style='color:#ff7043;'>üèãÔ∏è Training Ground: +{city_power_bonus}</span>")
        
        formula = QtWidgets.QLabel(" + ".join(formula_parts))
        formula.setTextFormat(QtCore.Qt.RichText)
        formula.setStyleSheet("font-size: 12px; background: transparent;")
        formula.setAlignment(QtCore.Qt.AlignCenter)
        formula.setWordWrap(True)
        header_layout.addWidget(formula)
        
        # Power potential bar
        potential_pct = min(100, int((base / max_base) * 100)) if max_base > 0 else 0
        
        potential_row = QtWidgets.QHBoxLayout()
        potential_label = QtWidgets.QLabel(f"Gear Potential: {potential_pct}%")
        potential_label.setStyleSheet("font-size: 11px; color: #888; background: transparent;")
        potential_max = QtWidgets.QLabel(f"(Max: {max_base:,} with all Legendary)")
        potential_max.setStyleSheet("font-size: 10px; color: #666; background: transparent;")
        potential_row.addWidget(potential_label)
        potential_row.addStretch()
        potential_row.addWidget(potential_max)
        header_layout.addLayout(potential_row)
        
        # Progress bar for potential
        progress = QtWidgets.QProgressBar()
        progress.setRange(0, 100)
        progress.setValue(potential_pct)
        progress.setTextVisible(False)
        progress.setFixedHeight(8)
        progress.setStyleSheet("""
            QProgressBar {
                background-color: rgba(0,0,0,0.3);
                border-radius: 4px;
            }
            QProgressBar::chunk {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #4caf50, stop:0.5 #8bc34a, stop:1 #cddc39);
                border-radius: 4px;
            }
        """)
        header_layout.addWidget(progress)
        
        layout.addWidget(header_card)
    
    def _build_equipment_section(self, layout: QtWidgets.QVBoxLayout) -> None:
        """Build the equipment breakdown table."""
        layout.addWidget(self._create_section_header("Equipment Breakdown", "üõ°Ô∏è"))
        
        equipped = self.equipped
        slots = ["Helmet", "Chestplate", "Gauntlets", "Boots", "Shield", "Weapon", "Cloak", "Amulet"]
        
        # Get themed slot display name function
        try:
            from gamification import get_slot_display_name
        except ImportError:
            get_slot_display_name = lambda s, _: s
        
        # Create compact grid for equipment
        grid = QtWidgets.QGridLayout()
        grid.setSpacing(4)
        
        # Header row
        headers = ["Slot", "Item", "Power", "Rarity"]
        for col, header_text in enumerate(headers):
            lbl = QtWidgets.QLabel(header_text)
            lbl.setStyleSheet("font-weight: bold; color: #888; font-size: 11px; padding: 4px;")
            if col >= 2:
                lbl.setAlignment(QtCore.Qt.AlignCenter)
            grid.addWidget(lbl, 0, col)
        
        # Equipment rows
        total_equipped = 0
        empty_slots = []
        
        for row, slot in enumerate(slots, start=1):
            item = equipped.get(slot)
            is_empty = not item or not isinstance(item, dict)
            
            if is_empty:
                empty_slots.append(slot)
            else:
                total_equipped += 1
            
            # Slot name - use themed display name
            display_slot = get_slot_display_name(slot, self._story_id)
            slot_lbl = QtWidgets.QLabel(display_slot)
            slot_lbl.setStyleSheet("color: #b0b0b0; font-size: 11px; padding: 3px;")
            grid.addWidget(slot_lbl, row, 0)
            
            # Item name
            if is_empty:
                name_lbl = QtWidgets.QLabel("[Empty]")
                name_lbl.setStyleSheet("color: #666; font-style: italic; font-size: 11px; padding: 3px;")
            else:
                item_name = item.get("name", "Unknown")
                if len(item_name) > 28:
                    item_name = item_name[:25] + "..."
                rarity = item.get("rarity", "Common")
                color = self.RARITY_COLORS.get(rarity, "#9e9e9e")
                name_lbl = QtWidgets.QLabel(item_name)
                name_lbl.setStyleSheet(f"color: {color}; font-size: 11px; padding: 3px;")
                name_lbl.setToolTip(item.get("name", ""))
            grid.addWidget(name_lbl, row, 1)
            
            # Power
            if is_empty:
                power = 0
            else:
                power = item.get("power", self.RARITY_POWER.get(item.get("rarity", "Common"), 10))
            power_lbl = QtWidgets.QLabel(str(power) if power > 0 else "-")
            power_lbl.setAlignment(QtCore.Qt.AlignCenter)
            power_lbl.setStyleSheet("font-weight: bold; color: #64b5f6; font-size: 11px; padding: 3px;" if power > 0 else "color: #555; font-size: 11px; padding: 3px;")
            grid.addWidget(power_lbl, row, 2)
            
            # Rarity
            if is_empty:
                rarity_lbl = QtWidgets.QLabel("-")
                rarity_lbl.setStyleSheet("color: #555; font-size: 11px; padding: 3px;")
            else:
                rarity = item.get("rarity", "Common")
                color = self.RARITY_COLORS.get(rarity, "#9e9e9e")
                rarity_lbl = QtWidgets.QLabel(rarity)
                rarity_lbl.setStyleSheet(f"color: {color}; font-size: 10px; padding: 3px;")
            rarity_lbl.setAlignment(QtCore.Qt.AlignCenter)
            grid.addWidget(rarity_lbl, row, 3)
        
        # Set column stretches
        grid.setColumnStretch(0, 1)  # Slot
        grid.setColumnStretch(1, 3)  # Item (wider)
        grid.setColumnStretch(2, 1)  # Power
        grid.setColumnStretch(3, 1)  # Rarity
        
        card, card_layout = self._create_info_card()
        card_layout.addLayout(grid)
        
        # Summary line
        summary = QtWidgets.QLabel(f"üì¶ {total_equipped}/8 slots equipped")
        summary.setStyleSheet("color: #888; font-size: 10px; margin-top: 4px;")
        card_layout.addWidget(summary)
        
        layout.addWidget(card)
    
    def _build_entity_patrons_section(self, layout: QtWidgets.QVBoxLayout) -> None:
        """Build the Entity Patrons section showing power from collected entities."""
        entity_info = self.entity_power_info
        total_power = entity_info.get("total_power", 0)
        contributors = entity_info.get("contributors", [])
        
        if total_power == 0 and not contributors:
            return  # Don't show section if no entity patrons
        
        layout.addWidget(self._create_section_header(f"Entity Patrons (+{total_power} Power)", "üêæ"))
        
        card, card_layout = self._create_info_card("rgba(156,39,176,0.1)", "#9c27b0")
        
        if contributors:
            # Show top contributors (limit to 6 for compactness)
            shown = contributors[:6]
            for contrib in shown:
                row = QtWidgets.QHBoxLayout()
                
                # Entity icon and name
                name_part = f"{contrib.get('icon', '‚ú®')} {contrib.get('name', 'Unknown')}"
                if contrib.get("is_exceptional"):
                    name_part += " ‚≠ê"
                name_lbl = QtWidgets.QLabel(name_part)
                name_lbl.setStyleSheet("color: #ce93d8; font-size: 11px; background: transparent;")
                
                # Power value
                power_lbl = QtWidgets.QLabel(f"+{contrib.get('power', 0)}")
                power_lbl.setStyleSheet("color: #e1bee7; font-weight: bold; font-size: 11px; background: transparent;")
                
                row.addWidget(name_lbl)
                row.addStretch()
                row.addWidget(power_lbl)
                card_layout.addLayout(row)
            
            if len(contributors) > 6:
                more = QtWidgets.QLabel(f"... and {len(contributors) - 6} more patrons")
                more.setStyleSheet("color: #888; font-size: 10px; font-style: italic; background: transparent;")
                card_layout.addWidget(more)
        else:
            tip = QtWidgets.QLabel(f"Total: +{total_power} power from your collected entities")
            tip.setStyleSheet("color: #ce93d8; font-size: 11px; background: transparent;")
            card_layout.addWidget(tip)
        
        layout.addWidget(card)
    
    def _build_set_bonuses_section(self, layout: QtWidgets.QVBoxLayout) -> None:
        """Build the Set Bonuses section showing active and potential sets."""
        active_sets = self.breakdown.get("active_sets", [])
        set_bonus = self.breakdown.get("set_bonus", 0)
        potential_sets = self.potential_sets
        
        if not active_sets and set_bonus == 0 and not potential_sets:
            return  # Don't show if no set info
        
        header_text = f"Set Bonuses (+{set_bonus} Power)" if set_bonus > 0 else "Set Bonuses"
        layout.addWidget(self._create_section_header(header_text, "üéØ"))
        
        card, card_layout = self._create_info_card("rgba(76,175,80,0.1)", "#4caf50" if set_bonus > 0 else "transparent")
        
        # Active sets
        if active_sets:
            for s in active_sets:
                row = QtWidgets.QHBoxLayout()
                set_name = QtWidgets.QLabel(f"{s.get('emoji', 'üéØ')} {s.get('name', 'Unknown Set')}")
                set_name.setStyleSheet("color: #81c784; font-size: 11px; background: transparent;")
                
                set_info = QtWidgets.QLabel(f"{s.get('count', 0)} items = +{s.get('bonus', 0)}")
                set_info.setStyleSheet("color: #a5d6a7; font-weight: bold; font-size: 11px; background: transparent;")
                
                row.addWidget(set_name)
                row.addStretch()
                row.addWidget(set_info)
                card_layout.addLayout(row)
        elif set_bonus > 0:
            info = QtWidgets.QLabel(f"+{set_bonus} power from matching gear themes")
            info.setStyleSheet("color: #81c784; font-size: 11px; background: transparent;")
            card_layout.addWidget(info)
        
        # Potential sets from inventory
        if potential_sets:
            potential_with_upside = [p for p in potential_sets if p.get("potential_bonus", 0) > p.get("current_bonus", 0)]
            if potential_with_upside:
                divider = QtWidgets.QLabel("‚îÄ" * 30)
                divider.setStyleSheet("color: #444; font-size: 8px; background: transparent;")
                card_layout.addWidget(divider)
                
                header = QtWidgets.QLabel("üí° Potential Sets (in inventory):")
                header.setStyleSheet("color: #888; font-size: 10px; margin-top: 4px; background: transparent;")
                card_layout.addWidget(header)
                
                for ps in potential_with_upside[:3]:  # Limit to top 3
                    row = QtWidgets.QHBoxLayout()
                    name = QtWidgets.QLabel(f"  {ps.get('emoji', 'üéØ')} {ps.get('name', 'Set')}")
                    name.setStyleSheet("color: #aaa; font-size: 10px; background: transparent;")
                    
                    potential = ps.get("potential_bonus", 0)
                    current = ps.get("current_bonus", 0)
                    upside = potential - current
                    
                    info = QtWidgets.QLabel(f"+{upside} possible")
                    info.setStyleSheet("color: #888; font-size: 10px; background: transparent;")
                    
                    row.addWidget(name)
                    row.addStretch()
                    row.addWidget(info)
                    card_layout.addLayout(row)
        
        if not active_sets and set_bonus == 0:
            tip = QtWidgets.QLabel("üí° Equip 2+ items with matching themes for set bonuses!")
            tip.setStyleSheet("color: #888; font-size: 10px; font-style: italic; background: transparent;")
            card_layout.addWidget(tip)
        
        layout.addWidget(card)
    
    def _build_style_bonus_section(self, layout: QtWidgets.QVBoxLayout) -> None:
        """Build the Style Bonus section (only shown if discovered)."""
        style_bonus = self.breakdown.get("style_bonus", 0)
        style_info = self.breakdown.get("style_info")
        
        if style_bonus == 0 or not style_info:
            return
        
        style_data = style_info.get("style", {})
        empty_slot = style_info.get("empty_slot", "Unknown")
        
        # Theme the empty slot display name
        try:
            from gamification import get_slot_display_name
            display_empty_slot = get_slot_display_name(empty_slot, self._story_id)
        except ImportError:
            display_empty_slot = empty_slot
        
        layout.addWidget(self._create_section_header(f"Style Bonus (+{style_bonus} Power)", "üëë"))
        
        card = QtWidgets.QWidget()
        card.setStyleSheet("""
            background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                stop:0 rgba(255, 215, 0, 0.15), stop:0.5 rgba(255, 215, 0, 0.25), stop:1 rgba(255, 215, 0, 0.15));
            border: 2px solid #FFD700;
            border-radius: 10px;
            padding: 10px;
        """)
        card_layout = QtWidgets.QVBoxLayout(card)
        card_layout.setSpacing(4)
        
        # Style name
        style_name = QtWidgets.QLabel(f"{style_data.get('emoji', 'üëë')} {style_data.get('name', 'Style Bonus')}")
        style_name.setStyleSheet("font-size: 16px; font-weight: bold; color: #FFD700; background: transparent;")
        style_name.setAlignment(QtCore.Qt.AlignCenter)
        card_layout.addWidget(style_name)
        
        # Description
        desc = QtWidgets.QLabel(style_data.get('description', 'Less is more'))
        desc.setStyleSheet("font-size: 11px; color: #e0e0e0; font-style: italic; background: transparent;")
        desc.setAlignment(QtCore.Qt.AlignCenter)
        card_layout.addWidget(desc)
        
        # Bonus details - use themed slot name
        bonus_text = QtWidgets.QLabel(f"+{style_bonus} Power ‚Ä¢ 7 Legendary items ‚Ä¢ {display_empty_slot} slot empty")
        bonus_text.setStyleSheet("font-size: 12px; color: #4CAF50; font-weight: bold; background: transparent;")
        bonus_text.setAlignment(QtCore.Qt.AlignCenter)
        card_layout.addWidget(bonus_text)
        
        layout.addWidget(card)
    
    def _build_lucky_bonuses_section(self, layout: QtWidgets.QVBoxLayout) -> None:
        """Build the Lucky Bonuses section showing gear bonuses."""
        bonuses = self.lucky_bonuses
        
        coin = bonuses.get("coin_discount", 0)
        xp = bonuses.get("xp_bonus", 0)
        merge = bonuses.get("merge_luck", 0)
        
        if coin == 0 and xp == 0 and merge == 0:
            return  # Don't show if no lucky bonuses
        
        layout.addWidget(self._create_section_header("Lucky Bonuses (from Gear)", "üçÄ"))
        
        card, card_layout = self._create_info_card("rgba(245,158,11,0.1)", "#f59e0b")
        
        bonuses_row = QtWidgets.QHBoxLayout()
        bonuses_row.setSpacing(20)
        
        if coin > 0:
            coin_lbl = QtWidgets.QLabel(f"üí∞ {coin}% Merge Discount")
            coin_lbl.setStyleSheet("color: #fcd34d; font-size: 11px; background: transparent;")
            bonuses_row.addWidget(coin_lbl)
        
        if xp > 0:
            xp_lbl = QtWidgets.QLabel(f"‚≠ê +{xp}% XP")
            xp_lbl.setStyleSheet("color: #a78bfa; font-size: 11px; background: transparent;")
            bonuses_row.addWidget(xp_lbl)
        
        if merge > 0:
            merge_lbl = QtWidgets.QLabel(f"üé≤ +{merge}% Merge Luck")
            merge_lbl.setStyleSheet("color: #60a5fa; font-size: 11px; background: transparent;")
            bonuses_row.addWidget(merge_lbl)
        
        bonuses_row.addStretch()
        card_layout.addLayout(bonuses_row)
        
        tip = QtWidgets.QLabel("üí° Lucky bonuses come from special attributes on your gear")
        tip.setStyleSheet("color: #888; font-size: 10px; font-style: italic; background: transparent;")
        card_layout.addWidget(tip)
        
        layout.addWidget(card)
    
    def _build_tips_section(self, layout: QtWidgets.QVBoxLayout) -> None:
        """Build the Tips section with actionable suggestions."""
        tips = []
        
        # Check for empty slots
        equipped = self.equipped
        slots = ["Helmet", "Chestplate", "Gauntlets", "Boots", "Shield", "Weapon", "Cloak", "Amulet"]
        empty_slots = [s for s in slots if not equipped.get(s)]
        
        if empty_slots:
            if len(empty_slots) == 1:
                tips.append(f"‚öîÔ∏è Equip your <b>{empty_slots[0]}</b> slot for +10 to +250 power")
            elif len(empty_slots) <= 3:
                tips.append(f"‚öîÔ∏è Fill empty slots: {', '.join(empty_slots)}")
            else:
                tips.append(f"‚öîÔ∏è {len(empty_slots)} empty slots - equip gear for more power!")
        
        # Check for upgrade opportunities
        low_rarity_slots = []
        for slot in slots:
            item = equipped.get(slot)
            if item and item.get("rarity") in ["Common", "Uncommon"]:
                low_rarity_slots.append(slot)
        
        if low_rarity_slots and len(low_rarity_slots) <= 3:
            tips.append(f"üîÑ Merge to upgrade: {', '.join(low_rarity_slots[:3])}")
        elif low_rarity_slots:
            tips.append(f"üîÑ {len(low_rarity_slots)} slots have Common/Uncommon gear - merge to upgrade!")
        
        # Check for potential sets
        if self.potential_sets:
            best_potential = max(self.potential_sets, key=lambda x: x.get("potential_bonus", 0) - x.get("current_bonus", 0), default=None)
            if best_potential and best_potential.get("potential_bonus", 0) > best_potential.get("current_bonus", 0):
                upside = best_potential["potential_bonus"] - best_potential["current_bonus"]
                tips.append(f"üéØ Equip {best_potential.get('emoji', '')} {best_potential.get('name', 'set')} items for +{upside} set bonus")
        
        # Entity tip
        entity_bonus = self.breakdown.get("entity_bonus", 0)
        if entity_bonus == 0:
            tips.append("üêæ Collect entities during focus sessions for patron power bonuses!")
        
        if not tips:
            return  # No tips needed - player is doing great!
        
        layout.addWidget(self._create_section_header("Tips for Improvement", "üí°"))
        
        card, card_layout = self._create_info_card("rgba(96,165,250,0.1)")
        
        for tip in tips[:4]:  # Limit to 4 tips
            tip_lbl = QtWidgets.QLabel(tip)
            tip_lbl.setTextFormat(QtCore.Qt.RichText)
            tip_lbl.setStyleSheet("color: #93c5fd; font-size: 11px; padding: 2px 0; background: transparent;")
            tip_lbl.setWordWrap(True)
            card_layout.addWidget(tip_lbl)
        
        layout.addWidget(card)


class LegendaryMinimalistDialog(StyledDialog):
    """Celebration dialog when player achieves the Legendary Minimalist style bonus."""
    
    def __init__(self, style_info: dict, parent=None):
        self.style_info = style_info
        super().__init__(
            parent,
            "STYLE BONUS UNLOCKED!",
            "üëë",
            min_width=450,
            max_width=550,
            modal=True,
            closable=True
        )
    
    def _build_content(self, layout: QtWidgets.QVBoxLayout) -> None:
        style = self.style_info.get("style", {})
        empty_slot = self.style_info.get("empty_slot", "Unknown")
        bonus = self.style_info.get("bonus", 350)
        
        # Trophy/celebration visual
        trophy = QtWidgets.QLabel("üèÜ")
        trophy.setStyleSheet("font-size: 72px; background: transparent;")
        trophy.setAlignment(QtCore.Qt.AlignCenter)
        layout.addWidget(trophy)
        
        # Style name with emoji
        style_name = QtWidgets.QLabel(f"{style.get('emoji', '‚ú®')} {style.get('name', 'Minimalist Master')}")
        style_name.setStyleSheet("""
            font-size: 28px;
            font-weight: bold;
            color: #FFD700;
            background: transparent;
        """)
        style_name.setAlignment(QtCore.Qt.AlignCenter)
        layout.addWidget(style_name)
        
        # Description
        desc = QtWidgets.QLabel(style.get("description", "Less is more"))
        desc.setStyleSheet("font-size: 14px; color: #E0E0E0; font-style: italic; background: transparent;")
        desc.setAlignment(QtCore.Qt.AlignCenter)
        layout.addWidget(desc)
        
        layout.addSpacing(20)
        
        # Bonus box
        bonus_widget = QtWidgets.QWidget()
        bonus_widget.setStyleSheet("""
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 rgba(76, 175, 80, 0.3), stop:1 rgba(76, 175, 80, 0.1));
            border: 2px solid #4CAF50;
            border-radius: 12px;
            padding: 15px;
        """)
        bonus_layout = QtWidgets.QVBoxLayout(bonus_widget)
        bonus_layout.setSpacing(8)
        
        bonus_title = QtWidgets.QLabel(f"+{bonus} POWER")
        bonus_title.setStyleSheet("font-size: 32px; font-weight: bold; color: #4CAF50; background: transparent;")
        bonus_title.setAlignment(QtCore.Qt.AlignCenter)
        bonus_layout.addWidget(bonus_title)
        
        bonus_desc = QtWidgets.QLabel("Style Bonus Added to Your Total Power!")
        bonus_desc.setStyleSheet("font-size: 12px; color: #A5D6A7; background: transparent;")
        bonus_desc.setAlignment(QtCore.Qt.AlignCenter)
        bonus_layout.addWidget(bonus_desc)
        
        layout.addWidget(bonus_widget)
        
        layout.addSpacing(15)
        
        # Explanation
        expl = QtWidgets.QLabel(
            f"You've equipped <b>7 Legendary items</b> while keeping<br>"
            f"your <b>{empty_slot}</b> slot deliberately empty.<br><br>"
            f"True power comes from knowing what NOT to wear!"
        )
        expl.setTextFormat(QtCore.Qt.RichText)
        expl.setStyleSheet("font-size: 12px; color: #B0B0B0; background: transparent;")
        expl.setAlignment(QtCore.Qt.AlignCenter)
        layout.addWidget(expl)
        
        layout.addStretch()
        
        self.add_button_row(layout, [("Awesome!", "primary", self.accept)])


class ADHDBusterTab(QtWidgets.QWidget):
    """Tab for viewing and managing the ADHD Buster character and inventory."""

    def __init__(self, blocker: BlockerCore, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.blocker = blocker
        self.merge_selected = []
        self.slot_combos: Dict[str, QtWidgets.QComboBox] = {}
        self.slot_labels: Dict[str, QtWidgets.QLabel] = {}  # Store slot label references for theme updates
        self._refreshing = False  # Prevent recursive refresh loops
        self._session_active = False  # Track if a focus session is active
        self._shown_style_bonuses = set()  # Track which style bonuses have been shown
        
        # Collapsible section states (stored in blocker config)
        self._collapsed_sections = self.blocker.adhd_buster.get("collapsed_sections", {})
        
        # Connect to game state manager for reactive updates
        self._game_state = get_game_state()
        if self._game_state:
            # Connect to specific signals for targeted updates
            self._game_state.power_changed.connect(self._on_power_changed)
            self._game_state.equipment_changed.connect(self._on_equipment_changed)
            self._game_state.set_bonus_changed.connect(self._on_set_bonus_changed)
            self._game_state.story_changed.connect(self._on_story_changed)
        
        self._build_ui()
        self.refresh_all()  # Initial data load
    
    # === Collapsible Section Management ===
    
    def _on_section_collapsed(self, section_id: str, collapsed: bool) -> None:
        """Save collapsed state when user toggles a section."""
        self._collapsed_sections[section_id] = collapsed
        self.blocker.adhd_buster["collapsed_sections"] = self._collapsed_sections
        self.blocker.save_config()
    
    # === GameState Signal Handlers ===
    
    def _on_power_changed(self, new_power: int) -> None:
        """Handle power change - update power label."""
        if hasattr(self, 'power_lbl'):
            power_info = get_power_breakdown(self.blocker.adhd_buster) if get_power_breakdown else {"base_power": new_power, "set_bonus": 0, "style_bonus": 0, "entity_bonus": 0, "total_power": new_power}
            
            # Build power breakdown string showing all components (gear + sets + style + entity patrons)
            power_parts = [str(power_info['base_power'])]
            if power_info.get("set_bonus", 0) > 0:
                power_parts.append(f"+{power_info['set_bonus']} set")
            if power_info.get("style_bonus", 0) > 0:
                style_info = power_info.get("style_info")
                style_name = style_info.get("style", {}).get("name", "style") if style_info else "style"
                power_parts.append(f"+{power_info['style_bonus']} {style_name}")
            if power_info.get("entity_bonus", 0) > 0:
                power_parts.append(f"+{power_info['entity_bonus']} patrons")
            
            if len(power_parts) > 1:
                power_txt = f"‚öî Power: {power_info['total_power']} ({' '.join(power_parts)})"
            else:
                power_txt = f"‚öî Power: {power_info['total_power']}"
            self.power_lbl.setText(power_txt)
        # Also update character display
        if hasattr(self, 'char_widget'):
            self.char_widget.update_from_data(self.blocker.adhd_buster)
        
        # Check for Legendary Minimalist style bonus
        self._check_style_bonus_unlocked()
    
    def _check_style_bonus_unlocked(self) -> None:
        """Check if player just unlocked a Legendary Minimalist style bonus and show celebration."""
        try:
            from gamification import calculate_legendary_minimalist_bonus
            equipped = self.blocker.adhd_buster.get("equipped", {})
            style_result = calculate_legendary_minimalist_bonus(equipped)
            
            if style_result.get("active"):
                # Create unique key for this style bonus
                style_key = style_result.get("empty_slot", "")
                
                # Check if we've already shown this bonus
                shown_bonuses = self.blocker.adhd_buster.get("shown_style_bonuses", [])
                if style_key not in shown_bonuses:
                    # Show celebration dialog
                    dialog = LegendaryMinimalistDialog(style_result, self)
                    dialog.exec()
                    
                    # Mark as shown so we don't show again
                    shown_bonuses.append(style_key)
                    self.blocker.adhd_buster["shown_style_bonuses"] = shown_bonuses
                    self.blocker.save_config()
        except ImportError:
            pass  # gamification not available
        except Exception as e:
            logger.debug(f"Error checking style bonus: {e}")
    
    def _on_equipment_changed(self, slot: str) -> None:
        """Handle equipment change - update specific slot combo."""
        if slot in self.slot_combos:
            self._refresh_slot_combo(slot)
        self._refresh_character()
        
        # Check for style bonus after equipment change
        self._check_style_bonus_unlocked()
    
    def _on_set_bonus_changed(self, breakdown: dict) -> None:
        """Handle set bonus change - update sets display."""
        if hasattr(self, 'sets_section'):
            self._refresh_sets_display(breakdown)
    
    def _on_story_changed(self, story_id: str) -> None:
        """Handle story change - full refresh needed for theme."""
        self.refresh_all()

    def refresh_all(self) -> None:
        """Comprehensive refresh of all UI elements - call after any data change."""
        if self._refreshing:
            return  # Prevent recursive refresh loops
        self._refreshing = True
        try:
            # Refresh in the correct order to ensure consistent state
            self._refresh_all_slot_combos()  # Equipment dropdowns first
            self._refresh_inventory()         # Then inventory list
            self._refresh_character()         # Then power/stats display (also updates story)
            # Update merge selection state
            self._update_merge_selection()
            # Update story indicator (compact label in Hero tab)
            self._update_story_indicator()
            # Update optimize button label based on entity perks
            self._update_optimize_button_label()
        finally:
            self._refreshing = False
    
    def _update_optimize_button_label(self) -> None:
        """Update the Optimize Gear button label based on Hobo/Robo Rat perk."""
        if not hasattr(self, '_optimize_btn') or not GAMIFICATION_AVAILABLE:
            return
        try:
            from gamification import get_entity_optimize_gear_cost
            optimize_perk = get_entity_optimize_gear_cost(self.blocker.adhd_buster)
            cost = optimize_perk["cost"]
            
            if optimize_perk["has_perk"]:
                if cost == 0:
                    # Robo Rat: FREE
                    self._optimize_btn.setText("‚ö° Optimize Gear (FREE ü§ñ)")
                    self._optimize_btn.setToolTip(f"{optimize_perk['description']}")
                else:
                    # Hobo Rat: 1 coin
                    self._optimize_btn.setText(f"‚ö° Optimize Gear ({cost}ü™ô üêÄ)")
                    self._optimize_btn.setToolTip(f"{optimize_perk['description']}")
            else:
                # Default: 10 coins
                self._optimize_btn.setText(f"‚ö° Optimize Gear ({cost}ü™ô)")
                self._optimize_btn.setToolTip("Automatically equip the best gear for maximum power")
        except Exception as e:
            print(f"[GamificationTab] Error updating optimize button: {e}")

    def set_session_active(self, active: bool) -> None:
        """Enable/disable interactive controls during focus sessions."""
        self._session_active = active
        
        # Show/hide session banner
        if hasattr(self, 'session_banner'):
            self.session_banner.setVisible(active)
        
        # Disable/enable equipment dropdowns
        for combo in self.slot_combos.values():
            combo.setEnabled(not active)
        
        # Disable/enable action buttons
        if hasattr(self, '_action_buttons'):
            for btn in self._action_buttons:
                btn.setEnabled(not active)
        
        # Disable/enable merge button
        if hasattr(self, 'merge_btn'):
            self.merge_btn.setEnabled(not active and len(self.merge_selected) >= 2)
        
        # Disable/enable inventory selection
        if hasattr(self, 'inv_table'):
            self.inv_table.setEnabled(not active)

    def _build_ui(self) -> None:
        layout = QtWidgets.QVBoxLayout(self)

        # Session active warning banner (hidden by default)
        self.session_banner = QtWidgets.QLabel(
            "üîí Focus session active - Equipment changes disabled until session ends"
        )
        self.session_banner.setStyleSheet(
            "background-color: #ff9800; color: white; padding: 10px; "
            "font-weight: bold; border-radius: 5px;"
        )
        self.session_banner.setAlignment(QtCore.Qt.AlignCenter)
        self.session_banner.setVisible(False)
        layout.addWidget(self.session_banner)

        # Use a splitter to allow resizing between upper content and inventory
        main_splitter = QtWidgets.QSplitter(QtCore.Qt.Vertical)
        main_splitter.setChildrenCollapsible(False)
        
        # Upper section (scrollable content: header, story, character, equipped gear)
        upper_scroll = QtWidgets.QScrollArea()
        upper_scroll.setWidgetResizable(True)
        upper_scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        container = QtWidgets.QWidget()
        self.inner_layout = QtWidgets.QVBoxLayout(container)
        # Help button moved to header row (next to Analysis button)

        # Header with power
        header = QtWidgets.QHBoxLayout()
        header.addWidget(QtWidgets.QLabel("<b style='font-size:18px;'>ü¶∏ HERO</b>"))
        header.addStretch()

        power = calculate_character_power(self.blocker.adhd_buster) if GAMIFICATION_AVAILABLE else 0
        power_info = get_power_breakdown(self.blocker.adhd_buster) if GAMIFICATION_AVAILABLE else {"base_power": 0, "set_bonus": 0, "style_bonus": 0, "entity_bonus": 0, "active_sets": [], "total_power": 0}
        
        # Build power breakdown string showing all components (gear + sets + style + entity patrons)
        power_parts = [str(power_info['base_power'])]
        if power_info.get("set_bonus", 0) > 0:
            power_parts.append(f"+{power_info['set_bonus']} set")
        if power_info.get("style_bonus", 0) > 0:
            style_info = power_info.get("style_info")
            style_name = style_info.get("style", {}).get("name", "style") if style_info else "style"
            power_parts.append(f"+{power_info['style_bonus']} {style_name}")
        if power_info.get("entity_bonus", 0) > 0:
            power_parts.append(f"+{power_info['entity_bonus']} patrons")
        
        if len(power_parts) > 1:
            power_txt = f"‚öî Power: {power_info['total_power']} ({' '.join(power_parts)})"
        else:
            power_txt = f"‚öî Power: {power_info['total_power']}"
        self.power_lbl = QtWidgets.QLabel(power_txt)
        self.power_lbl.setStyleSheet("font-weight: bold; color: #e65100;")
        header.addWidget(self.power_lbl)
        
        # Details Button
        if GAMIFICATION_AVAILABLE:
            self.details_btn = QtWidgets.QPushButton("üîç Analysis")
            self.details_btn.setCursor(QtCore.Qt.PointingHandCursor)
            self.details_btn.setToolTip("View detailed power calculation path")
            self.details_btn.setStyleSheet("""
                QPushButton {
                    background-color: #333333;
                    color: #eeeeee;
                    border: 1px solid #555555;
                    border-radius: 4px;
                    padding: 4px 8px;
                }
                QPushButton:hover {
                    background-color: #444444;
                    border-color: #666666;
                }
            """)
            self.details_btn.clicked.connect(self._show_power_analysis)
            header.addWidget(self.details_btn)
        
        # Help button (next to Analysis to save vertical space)
        from styled_dialog import create_tab_help_button
        self._hero_help_btn = create_tab_help_button("hero", self)
        header.addWidget(self._hero_help_btn)
            
        self.inner_layout.addLayout(header)

        # Character canvas and equipment side by side - use horizontal splitter for resizing
        self.char_equip_splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        self.char_equip_splitter.setChildrenCollapsible(False)
        equipped = self.blocker.adhd_buster.get("equipped", {})
        active_story = self.blocker.adhd_buster.get("active_story", "warrior")
        self.char_canvas = CharacterCanvas(equipped, power_info["total_power"], parent=self, story_theme=active_story)
        self.char_equip_splitter.addWidget(self.char_canvas)

        equip_group = QtWidgets.QGroupBox("‚öî Equipped Gear (change with dropdown)")
        equip_layout = QtWidgets.QFormLayout(equip_group)
        slots = ["Helmet", "Chestplate", "Gauntlets", "Boots", "Shield", "Weapon", "Cloak", "Amulet"]
        inventory = self.blocker.adhd_buster.get("inventory", [])
        
        # Rarity colors for visual distinction
        rarity_colors = {
            "Common": "#9e9e9e",
            "Uncommon": "#4caf50",
            "Rare": "#2196f3",
            "Epic": "#9c27b0",
            "Legendary": "#ff9800"
        }

        for slot in slots:
            combo = NoScrollComboBox()
            combo.setFocusPolicy(QtCore.Qt.StrongFocus)
            combo.addItem("[Empty]")
            slot_items = [item for item in inventory if item.get("slot") == slot]
            for idx, item in enumerate(slot_items):
                item_name = item.get('name', 'Unknown')
                item_rarity = item.get('rarity', 'Common')
                item_color = rarity_colors.get(item_rarity, "#9e9e9e")
                power = item.get('power', 10)
                display = f"{item_name} (+{power}) [{item_rarity}]"
                
                # Add lucky options summary to dropdown text if present
                lucky_options = item.get("lucky_options", {})
                if lucky_options and format_lucky_options:
                    try:
                        lucky_text = format_lucky_options(lucky_options)
                        if lucky_text:
                            display += f" ‚ú®{lucky_text}"
                    except Exception:
                        pass  # Skip if formatting fails
                
                combo.addItem(display, item)
                combo_idx = combo.count() - 1
                # Set foreground color for this item
                combo.setItemData(combo_idx, QtGui.QColor(item_color), QtCore.Qt.ForegroundRole)
                
                # Build comprehensive tooltip for this item
                slot_display = get_slot_display_name(slot, active_story) if get_slot_display_name else slot
                tooltip_parts = [f"<b style='color:{item_color};'>{item_name}</b>"]
                item_type = item.get("item_type", "")
                if item_type:
                    tooltip_parts.append(f"<br><i>{item_type}</i>")
                tooltip_parts.append(f"<br>‚öîÔ∏è Power: +{power}")
                tooltip_parts.append(f"<br>üé≠ Rarity: {item_rarity}")
                tooltip_parts.append(f"<br>üéØ Slot: {slot_display}")
                item_set = item.get("set")
                if item_set:
                    tooltip_parts.append(f"<br>üè∑Ô∏è Set: {item_set}")
                
                # Special attributes section
                has_special = False
                special_parts = []
                
                if lucky_options and format_lucky_options:
                    try:
                        lucky_text = format_lucky_options(lucky_options)
                        if lucky_text:
                            special_parts.append(f"‚ú® Lucky Options: {lucky_text}")
                            has_special = True
                    except Exception:
                        pass
                
                if has_special:
                    tooltip_parts.append("<br><br><b>‚ú® Special Attributes:</b>")
                    for sp in special_parts:
                        tooltip_parts.append(f"<br>  {sp}")
                
                tooltip_html = "".join(tooltip_parts)
                combo.setItemData(combo_idx, tooltip_html, QtCore.Qt.ToolTipRole)
                
            current = equipped.get(slot)
            if current:
                current_id = current.get("item_id")
                current_ts = current.get("obtained_at")
                current_slot = current.get("slot")
                for i in range(1, combo.count()):
                    item_data = combo.itemData(i)
                    if not item_data:
                        continue
                    # Match by item_id first, then by timestamp+slot
                    item_id = item_data.get("item_id")
                    if current_id and item_id and current_id == item_id:
                        combo.setCurrentIndex(i)
                        # Apply color to the combo box text for selected item
                        curr_rarity = current.get("rarity", "Common")
                        curr_color = rarity_colors.get(curr_rarity, "#9e9e9e")
                        combo.setStyleSheet(f"QComboBox {{ color: {curr_color}; font-weight: bold; }}")
                        break
                    elif not current_id and not item_id:
                        # Fallback: match by timestamp + slot
                        if item_data.get("obtained_at") == current_ts and item_data.get("slot") == current_slot:
                            combo.setCurrentIndex(i)
                            curr_rarity = current.get("rarity", "Common")
                            curr_color = rarity_colors.get(curr_rarity, "#9e9e9e")
                            combo.setStyleSheet(f"QComboBox {{ color: {curr_color}; font-weight: bold; }}")
                            break
            combo.currentIndexChanged.connect(lambda idx, s=slot, c=combo: self._on_equip_change(s, c))
            self.slot_combos[slot] = combo
            # Use themed slot display name - power info shown in separate label
            display_name = get_slot_display_name(slot, active_story) if get_slot_display_name else slot
            slot_label = QtWidgets.QLabel(f"{display_name}:")
            self.slot_labels[slot] = slot_label
            equip_layout.addRow(slot_label, combo)
        
        self.char_equip_splitter.addWidget(equip_group)
        
        # Style the splitter handle for visibility
        self.char_equip_splitter.setHandleWidth(6)
        self.char_equip_splitter.setStyleSheet("""
            QSplitter::handle:horizontal {
                background-color: #444;
                border: 1px solid #555;
                width: 6px;
                margin: 2px 0;
            }
            QSplitter::handle:horizontal:hover {
                background-color: #666;
            }
        """)
        
        # Restore saved splitter position or use default
        self._load_hero_splitter_state()
        
        # Save splitter position when user adjusts it
        self.char_equip_splitter.splitterMoved.connect(self._save_hero_splitter_state)
        
        self.inner_layout.addWidget(self.char_equip_splitter)

        # Active set bonuses (collapsible section)
        self.sets_section = CollapsibleSection(
            "üéØ Active Set Bonuses", "sets",
            collapsed=self._collapsed_sections.get("sets", False)
        )
        self.sets_section.collapsed_changed.connect(self._on_section_collapsed)
        self._refresh_sets_display(power_info)
        self.inner_layout.addWidget(self.sets_section)

        # Entity Patrons - entities boosting hero power (collapsible section)
        self.entity_patrons_section = CollapsibleSection(
            "üêâ Entity Patrons", "entity_patrons",
            collapsed=self._collapsed_sections.get("entity_patrons", False)
        )
        self.entity_patrons_section.collapsed_changed.connect(self._on_section_collapsed)
        self._refresh_entity_patrons_display()
        self.inner_layout.addWidget(self.entity_patrons_section)

        # Potential set bonuses from inventory (collapsible section)
        self.potential_sets_section = CollapsibleSection(
            "üí° Potential Set Bonuses (in your inventory)", "potential_sets",
            collapsed=self._collapsed_sections.get("potential_sets", False)
        )
        self.potential_sets_section.collapsed_changed.connect(self._on_section_collapsed)
        self._refresh_potential_sets_display()
        self.inner_layout.addWidget(self.potential_sets_section)
        
        # Gear bonuses (collapsible section)
        self.lucky_bonuses_section = CollapsibleSection(
            "‚ú® Gear Bonuses & Effects", "lucky_bonuses",
            collapsed=self._collapsed_sections.get("lucky_bonuses", False)
        )
        self.lucky_bonuses_section.collapsed_changed.connect(self._on_section_collapsed)
        self._refresh_lucky_bonuses_display()
        self.inner_layout.addWidget(self.lucky_bonuses_section)

        # Stats summary
        total_items = len(self.blocker.adhd_buster.get("inventory", []))
        total_collected = self.blocker.adhd_buster.get("total_collected", total_items)
        streak = self.blocker.stats.get("streak_days", 0)
        self.stats_lbl = QtWidgets.QLabel(f"üì¶ {total_items} in bag  |  üéÅ {total_collected} collected  |  üî• {streak} day streak")
        self.stats_lbl.setStyleSheet("color: gray;")
        self.inner_layout.addWidget(self.stats_lbl)

        # XP info is now shown in the XP ring widget in the timeline header
        # Store None references to avoid attribute errors in update functions
        if GAMIFICATION_AVAILABLE:
            self.level_title_lbl = None
            self.total_xp_lbl = None
            self.xp_progress_bar = None
            self.xp_text_lbl = None

        # Compact Story Indicator (full story UI now in Story tab)
        if GAMIFICATION_AVAILABLE:
            from gamification import AVAILABLE_STORIES, get_selected_story
            
            story_indicator = QtWidgets.QWidget()
            story_indicator_layout = QtWidgets.QHBoxLayout(story_indicator)
            story_indicator_layout.setContentsMargins(10, 8, 10, 8)
            
            current_story = get_selected_story(self.blocker.adhd_buster)
            story_info = AVAILABLE_STORIES.get(current_story, {})
            self.story_indicator_lbl = QtWidgets.QLabel(f"üìú Current Story: <b>{story_info.get('title', current_story)}</b>")
            self.story_indicator_lbl.setStyleSheet("font-size: 13px;")
            story_indicator_layout.addWidget(self.story_indicator_lbl)
            
            story_indicator_layout.addStretch()
            
            self.go_to_story_btn = QtWidgets.QPushButton("üìñ Go to Story Tab")
            self.go_to_story_btn.setStyleSheet("padding: 5px 15px;")
            self.go_to_story_btn.setToolTip("Open the Story tab to change stories, read chapters, and track progress")
            self.go_to_story_btn.clicked.connect(self._go_to_story_tab)
            story_indicator_layout.addWidget(self.go_to_story_btn)
            
            self.inner_layout.addWidget(story_indicator)

        # Latest Diary Entry - Speech bubble from the character
        diary_bubble_group = QtWidgets.QWidget()
        diary_bubble_layout = QtWidgets.QVBoxLayout(diary_bubble_group)
        diary_bubble_layout.setContentsMargins(10, 5, 10, 5)
        
        # Get the latest diary entry
        diary_entries = self.blocker.adhd_buster.get("diary", [])
        
        # Speech bubble header with button
        bubble_header = QtWidgets.QHBoxLayout()
        bubble_header.addWidget(QtWidgets.QLabel("<b>üí¨ Latest Adventure:</b>"))
        bubble_header.addStretch()
        self.diary_history_btn = QtWidgets.QPushButton("üìñ View All Entries")
        self.diary_history_btn.setStyleSheet("font-size: 11px; padding: 3px 8px;")
        self.diary_history_btn.clicked.connect(self._open_diary)
        bubble_header.addWidget(self.diary_history_btn)
        diary_bubble_layout.addLayout(bubble_header)
        
        # Speech bubble content
        self.speech_bubble = QtWidgets.QLabel()
        self.speech_bubble.setWordWrap(True)
        self.speech_bubble.setStyleSheet("""
            QLabel {
                background-color: #2d2d2d;
                border: 2px solid #555;
                border-radius: 12px;
                padding: 12px;
                color: #f0f0f0;
                font-size: 12px;
            }
        """)
        
        if diary_entries:
            latest = diary_entries[-1]
            entry_text = latest.get("story", "No adventures yet...")
            date_str = latest.get("short_date", latest.get("date", ""))
            tier = latest.get("tier", "unknown")
            self.speech_bubble.setText(f'"{entry_text}"\n\n‚Äî {date_str} | Tier: {tier.title()}')
        else:
            self.speech_bubble.setText("No adventures yet... Start a focus session to write your story!")
        
        diary_bubble_layout.addWidget(self.speech_bubble)
        self.inner_layout.addWidget(diary_bubble_group)
        
        # End of upper section - set it in the scroll area
        upper_scroll.setWidget(container)
        main_splitter.addWidget(upper_scroll)

        # Lower section: Inventory (resizable via splitter)
        inv_container = QtWidgets.QWidget()
        inv_container_layout = QtWidgets.QVBoxLayout(inv_container)
        inv_container_layout.setContentsMargins(5, 0, 5, 0)
        
        # Inventory with split view (list + details panel)
        inv_group = QtWidgets.QGroupBox("üì¶ Inventory (click items to select for merge)")
        inv_main_layout = QtWidgets.QVBoxLayout(inv_group)
        
        # Inventory stats header
        stats_layout = QtWidgets.QHBoxLayout()
        self.inv_stats_label = QtWidgets.QLabel()
        self.inv_stats_label.setStyleSheet("color: #666; font-size: 10px;")
        stats_layout.addWidget(self.inv_stats_label)
        stats_layout.addStretch()
        inv_main_layout.addLayout(stats_layout)
        
        # Entity perk bonus slots display - shows which entities contribute +slots
        self.inv_entity_perk_container = QtWidgets.QWidget()
        self.inv_entity_perk_container.setVisible(False)
        self.inv_entity_perk_layout = QtWidgets.QHBoxLayout(self.inv_entity_perk_container)
        self.inv_entity_perk_layout.setContentsMargins(0, 2, 0, 2)
        self.inv_entity_perk_layout.setSpacing(4)
        inv_main_layout.addWidget(self.inv_entity_perk_container)
        
        sort_bar = QtWidgets.QHBoxLayout()
        self.sort_combo = NoScrollComboBox()
        self.sort_combo.addItem("Sort: newest", "newest")
        self.sort_combo.addItem("Sort: rarity", "rarity")
        self.sort_combo.addItem("Sort: slot", "slot")
        self.sort_combo.addItem("Sort: power", "power")
        self.sort_combo.addItem("Sort: lucky", "lucky")
        self.sort_combo.currentIndexChanged.connect(self._refresh_inventory)
        sort_bar.addWidget(self.sort_combo)
        sort_bar.addStretch()
        inv_main_layout.addLayout(sort_bar)
        
        # Inventory Table
        self.inv_table = QtWidgets.QTableWidget()
        self.inv_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.inv_table.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)  # Disable row selection, use checkboxes
        self.inv_table.cellClicked.connect(self._on_inventory_cell_clicked)  # Handle checkbox clicks
        self.inv_table.setAlternatingRowColors(False)  # Disable striped rows for cleaner merge selection
        self.inv_table.verticalHeader().setVisible(False)
        self.inv_table.setShowGrid(False)
        self.inv_table.setSortingEnabled(True) # Enable sorting
        
        # Scrollbars are enabled by default
        
        self.inv_table.setStyleSheet("""
            QTableWidget {
                background-color: #2b2b2b;
                color: #ddd;
                border: 1px solid #444;
                gridline-color: #3a3a3a;
            }
            QTableWidget::item {
                padding: 3px 5px;
                border-bottom: 1px solid #3a3a3a;
            }
            QTableWidget::item:selected {
                background-color: #4a6fa5;
            }
            QHeaderView::section {
                background-color: #1e1e2e;
                color: #aaa;
                padding: 5px;
                border: none;
                font-weight: bold;
                font-size: 10px;
            }
            QToolTip { 
                color: #ffffff; 
                background-color: #2a2a2a; 
                border: 1px solid #555; 
            }
        """)
        
        # Set up columns: Merge checkbox, Eq, Name, Slot, Tier, Power, Set, +3 bonuses
        columns = [
            "üîÄ", "Eq", "Name", "Slot", "Tier", "Pwr", "Set", 
            "üí∞", "‚≠ê", "üé≤"
        ]
        self.inv_table.setColumnCount(len(columns))
        self.inv_table.setHorizontalHeaderLabels(columns)
        
        # Tooltips for headers - detailed explanations
        header_tooltips = [
            "Select for Merge\n‚òë = Selected for merging\nClick to toggle selection",
            "Equipped Status\n‚úì = Currently equipped on your hero\nEquipped items cannot be merged",
            "Item Name\nThe name of the item including its rarity adjective\nHigher tier items have more impressive names",
            "Equipment Slot\nWhere this item is equipped:\n‚Ä¢ Helmet, Chestplate, Gauntlets, Boots\n‚Ä¢ Shield, Weapon, Ring, Necklace",
            "Rarity Tier\nItem quality from Common to Legendary:\nC=Common, U=Uncommon, R=Rare, E=Epic, L=Legendary\nHigher tiers have better stats and bonuses",
            "Power Level\nThe item's combat power contribution\nHigher power = stronger hero\nTotal power from all equipped items is shown in hero stats",
            "Item Set\nItems from the same set provide bonus effects\nCollect matching set pieces for additional power",
            "üí∞ Coin Discount\nReduces costs for merge operations\nHigher % = cheaper merges (up to 90% off)\nGreat for saving coins while upgrading gear",
            "‚≠ê XP Bonus\nBonus experience points from focus sessions\nHigher % = faster leveling\nLevel up to unlock new features and rewards",
            "üé≤ Merge Luck\nIncreases success chance in Lucky Merge\nBase merge success is 25%, this adds to it\nVery valuable for upgrading your gear!"
        ]
        for i, tooltip in enumerate(header_tooltips):
            item = self.inv_table.horizontalHeaderItem(i)
            if item:
                item.setToolTip(tooltip)

        # Configure column resizing
        header = self.inv_table.horizontalHeader()
        header.setSectionResizeMode(QtWidgets.QHeaderView.Interactive) # Allow user resizing
        header.setStretchLastSection(True)
        
        # Persistence connections
        header.sectionResized.connect(self._save_inventory_state)
        header.sortIndicatorChanged.connect(self._save_inventory_state)
        
        # Load saved state
        self._load_inventory_state()
        
        inv_main_layout.addWidget(self.inv_table)
        
        # Make inventory group expand to fill available space
        inv_group.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        inv_container_layout.addWidget(inv_group, 1)  # stretch factor 1

        # Lucky Merge (below inventory)
        merge_group = QtWidgets.QGroupBox("üé≤ Lucky Merge")
        merge_layout = QtWidgets.QHBoxLayout(merge_group)
        self.merge_warn_lbl = QtWidgets.QLabel("‚ö†Ô∏è 25% base success (items lost on fail!) ‚Ä¢ Cost: 50ü™ô")
        self.merge_warn_lbl.setStyleSheet("color: #d32f2f; font-size: 10px;")
        merge_layout.addWidget(self.merge_warn_lbl)
        self.merge_btn = QtWidgets.QPushButton("üé≤ Merge Selected (0)")
        self.merge_btn.setEnabled(False)
        self.merge_btn.setToolTip("Combine items for a chance at a higher rarity item (costs 50 coins)")
        self.merge_btn.clicked.connect(self._do_merge)
        merge_layout.addWidget(self.merge_btn)
        self.merge_rate_lbl = QtWidgets.QLabel("‚Üê Select 2+ items above")
        self.merge_rate_lbl.setStyleSheet("font-size: 10px;")
        merge_layout.addWidget(self.merge_rate_lbl)
        merge_layout.addStretch()
        inv_container_layout.addWidget(merge_group)

        self._refresh_inventory()
        
        # Add inventory container to splitter
        main_splitter.addWidget(inv_container)
        
        # Set initial splitter sizes (upper section smaller, inventory larger)
        main_splitter.setSizes([300, 400])
        main_splitter.setHandleWidth(8)
        
        # Style the splitter handle for visibility
        main_splitter.setStyleSheet("""
            QSplitter::handle {
                background-color: #444;
                border: 1px solid #555;
            }
            QSplitter::handle:hover {
                background-color: #666;
            }
        """)
        
        layout.addWidget(main_splitter, 1)

        # Buttons
        btn_layout = QtWidgets.QHBoxLayout()
        
        # Refresh button for manual refresh
        refresh_btn = QtWidgets.QPushButton("üîÑ Refresh")
        refresh_btn.setToolTip("Refresh all displays to show current state")
        refresh_btn.clicked.connect(self.refresh_all)
        btn_layout.addWidget(refresh_btn)
        
        diary_btn = QtWidgets.QPushButton("üìñ Adventure Diary")
        diary_btn.clicked.connect(self._open_diary)
        btn_layout.addWidget(diary_btn)
        sell_btn = QtWidgets.QPushButton("üí∞ Sell Items")
        sell_btn.clicked.connect(self._sell_items)
        btn_layout.addWidget(sell_btn)
        self._optimize_btn = QtWidgets.QPushButton("‚ö° Optimize Gear (10ü™ô)")
        self._optimize_btn.setToolTip("Automatically equip the best gear for maximum power")
        self._optimize_btn.clicked.connect(self._optimize_gear)
        btn_layout.addWidget(self._optimize_btn)
        btn_layout.addStretch()
        # Store button references for enabling/disabling during sessions
        self._action_buttons = [refresh_btn, diary_btn, sell_btn, self._optimize_btn]
        layout.addLayout(btn_layout)
        
        # Update optimize button label based on entity perks
        self._update_optimize_button_label()

    def _on_equip_change(self, slot: str, combo: QtWidgets.QComboBox) -> None:
        """Handle equipment slot change - use GameState for reactive updates."""
        idx = combo.currentIndex()
        
        # Rarity colors for combo styling
        rarity_colors = {
            "Common": "#9e9e9e",
            "Uncommon": "#4caf50",
            "Rare": "#2196f3",
            "Epic": "#9c27b0",
            "Legendary": "#ff9800"
        }
        
        # Prepare item data
        new_item = None
        if idx > 0:
            item = combo.currentData()
            if item:
                # Create deep copy to preserve lucky_options
                new_item = item.copy()
                if "lucky_options" in item and isinstance(item["lucky_options"], dict):
                    new_item["lucky_options"] = item["lucky_options"].copy()
                # Update combo color immediately for equipped item
                item_rarity = item.get("rarity", "Common")
                item_color = rarity_colors.get(item_rarity, "#9e9e9e")
                combo.setStyleSheet(f"QComboBox {{ color: {item_color}; font-weight: bold; }}")
        else:
            # Empty selected - reset to white
            combo.setStyleSheet("QComboBox { color: #ffffff; }")
        
        # Use GameState manager for reactive updates
        if not self._game_state:
            logger.error("GameStateManager not available - cannot change equipment")
            return
        
        self._game_state.swap_equipped_item(slot, new_item)
        # Sync changes to active hero
        if GAMIFICATION_AVAILABLE:
            sync_hero_data(self.blocker.adhd_buster)
        # UI updates happen automatically via signals

    def _refresh_sets_display(self, power_info: dict = None) -> None:
        """Refresh the active set bonuses display."""
        # Clear existing content in collapsible section
        self.sets_section.clear_content()
        
        if not GAMIFICATION_AVAILABLE:
            self.sets_section.setVisible(False)
            return
            
        if power_info is None:
            power_info = get_power_breakdown(self.blocker.adhd_buster)
        
        active_sets = power_info.get("active_sets", [])
        equipped = self.blocker.adhd_buster.get("equipped", {})
        
        if active_sets:
            self.sets_section.setVisible(True)
            for s in active_sets:
                # Main set bonus line
                lbl = QtWidgets.QLabel(f"{s['emoji']} {s['name']} ({s['count']} items): <b>+{s['bonus']} power</b>")
                lbl.setTextFormat(QtCore.Qt.RichText)
                lbl.setStyleSheet("color: #4caf50; font-size: 11px; padding: 2px 0;")
                self.sets_section.add_widget(lbl)
                
                # Show which items belong to this set
                slots = s.get('slots', [])
                if slots and equipped:
                    item_names = []
                    for slot in slots:
                        item = equipped.get(slot)
                        if item:
                            # Get item name, truncate if too long
                            name = item.get('name', slot.replace('_', ' ').title())
                            if len(name) > 20:
                                name = name[:17] + "..."
                            item_names.append(name)
                    
                    if item_names:
                        items_str = ", ".join(item_names)
                        items_lbl = QtWidgets.QLabel(f"    ‚îî {items_str}")
                        items_lbl.setStyleSheet("color: #888; font-size: 10px; padding-left: 15px;")
                        self.sets_section.add_widget(items_lbl)
            
            # Update title with count
            self.sets_section.set_title(f"üéØ Active Set Bonuses ({len(active_sets)})")
        else:
            self.sets_section.setVisible(False)

    def _refresh_entity_patrons_display(self) -> None:
        """Refresh the entity patrons display showing collected entities that boost hero power."""
        # Clear existing content in collapsible section
        self.entity_patrons_section.clear_content()
        
        if not GAMIFICATION_AVAILABLE or not get_entity_power_perks:
            self.entity_patrons_section.setVisible(False)
            return
        
        # Get entity power perks with contributor details
        power_perks = get_entity_power_perks(self.blocker.adhd_buster)
        contributors = power_perks.get("contributors", [])
        total_power = power_perks.get("total_power", 0)
        
        if contributors:
            self.entity_patrons_section.setVisible(True)
            self.entity_patrons_section.set_title(f"üêâ Entity Patrons (+{total_power} Power)")
            
            # Try to import entity icon resolver
            try:
                from entitidex_tab import _resolve_entity_svg_path
                from entitidex.entity_pools import get_entity_by_id as get_entity
                from PySide6.QtSvg import QSvgRenderer
                has_svg_support = True
            except ImportError:
                has_svg_support = False
            
            # Create a horizontal flow layout for entity cards
            patrons_container = QtWidgets.QWidget()
            patrons_layout = QtWidgets.QHBoxLayout(patrons_container)
            patrons_layout.setContentsMargins(5, 5, 5, 5)
            patrons_layout.setSpacing(8)
            
            for entity_data in contributors:
                # Create a mini card for each entity
                card = QtWidgets.QFrame()
                is_exceptional = entity_data.get("is_exceptional", False)
                
                # Style cards - exceptional gets slightly lighter border
                if is_exceptional:
                    card.setStyleSheet("""
                        QFrame {
                            background-color: #2a2a2a;
                            border: 1px solid #555;
                            border-radius: 6px;
                            padding: 4px;
                        }
                        QFrame:hover {
                            border-color: #666;
                            background-color: #333;
                        }
                    """)
                else:
                    card.setStyleSheet("""
                        QFrame {
                            background-color: #2a2a2a;
                            border: 1px solid #444;
                            border-radius: 6px;
                            padding: 4px;
                        }
                        QFrame:hover {
                            border-color: #e65100;
                            background-color: #333;
                        }
                    """)
                
                card_layout = QtWidgets.QVBoxLayout(card)
                card_layout.setContentsMargins(8, 6, 8, 6)
                card_layout.setSpacing(4)
                
                # Try to load entity SVG icon
                entity_id = entity_data.get("entity_id", "")
                icon_loaded = False
                
                if has_svg_support and entity_id:
                    try:
                        entity_obj = get_entity(entity_id)
                        if entity_obj:
                            svg_path = _resolve_entity_svg_path(entity_obj, is_exceptional)
                            if svg_path:
                                renderer = QSvgRenderer(svg_path)
                                if renderer.isValid():
                                    # Create pixmap from SVG (40x40 size for mini cards)
                                    icon_size = 40
                                    pixmap = QtGui.QPixmap(icon_size, icon_size)
                                    pixmap.fill(QtCore.Qt.transparent)
                                    painter = QtGui.QPainter(pixmap)
                                    renderer.render(painter)
                                    painter.end()
                                    
                                    icon_lbl = QtWidgets.QLabel()
                                    icon_lbl.setPixmap(pixmap)
                                    icon_lbl.setAlignment(QtCore.Qt.AlignCenter)
                                    icon_lbl.setFixedSize(icon_size, icon_size)
                                    card_layout.addWidget(icon_lbl, alignment=QtCore.Qt.AlignCenter)
                                    icon_loaded = True
                    except Exception:
                        pass  # Fall back to text display
                
                # Entity name with exceptional styling
                name = entity_data.get("name", "Unknown")
                # Truncate long names
                if len(name) > 18:
                    display_name = name[:15] + "..."
                else:
                    display_name = name
                
                if is_exceptional:
                    name_style = "color: #ffd700; font-weight: bold; font-size: 10px;"
                    prefix = "‚≠ê " if not icon_loaded else ""
                else:
                    name_style = "color: #ccc; font-size: 10px;"
                    prefix = ""
                
                name_lbl = QtWidgets.QLabel(f"{prefix}{display_name}")
                name_lbl.setStyleSheet(name_style)
                name_lbl.setAlignment(QtCore.Qt.AlignCenter)
                name_lbl.setToolTip(f"{name}\n{entity_data.get('description', '')}")
                name_lbl.setWordWrap(True)
                card_layout.addWidget(name_lbl)
                
                # Power value
                power_val = entity_data.get("power", 0)
                power_lbl = QtWidgets.QLabel(f"<b>+{power_val}</b> ‚öî")
                power_lbl.setStyleSheet("color: #e65100; font-size: 12px;")
                power_lbl.setAlignment(QtCore.Qt.AlignCenter)
                card_layout.addWidget(power_lbl)
                
                patrons_layout.addWidget(card)
            
            patrons_layout.addStretch()
            self.entity_patrons_section.add_widget(patrons_container)
            
            # Add a tip
            tip_lbl = QtWidgets.QLabel("üí° Collect more Warrior entities in Entitidex to boost your hero's power!")
            tip_lbl.setStyleSheet("color: #888; font-style: italic; font-size: 10px; padding-top: 4px;")
            self.entity_patrons_section.add_widget(tip_lbl)
        else:
            self.entity_patrons_section.setVisible(False)

    def _show_power_analysis(self) -> None:
        """Show the detailed power analysis dialog."""
        if not GAMIFICATION_AVAILABLE or not get_power_breakdown:
            show_warning(
                self,
                "Analysis Unavailable",
                "Power breakdown is unavailable (gamification module not loaded).",
            )
            return

        try:
            power_info = get_power_breakdown(self.blocker.adhd_buster)
            if not power_info:
                show_warning(
                    self,
                    "Analysis Unavailable",
                    "Power breakdown data is missing. Try again after a session or reload.",
                )
                return

            equipped = self.blocker.adhd_buster.get("equipped", {})
            inventory = self.blocker.adhd_buster.get("inventory", [])
            
            # Check if style bonus has been discovered (easter egg)
            style_discovered = bool(self.blocker.adhd_buster.get("shown_style_bonuses", []))
            
            # Get entity power breakdown for patrons section
            entity_power_info = None
            if get_entity_power_perks:
                entity_power_info = get_entity_power_perks(self.blocker.adhd_buster)
            
            # Get lucky bonuses from gear
            lucky_bonuses = None
            if calculate_total_lucky_bonuses:
                lucky_bonuses = calculate_total_lucky_bonuses(equipped)
            
            # Get potential set bonuses from inventory
            potential_sets = None
            if find_potential_set_bonuses:
                potential_sets = find_potential_set_bonuses(inventory, equipped)
            
            dlg = PowerAnalysisDialog(
                power_info, equipped, self,
                entity_power_info=entity_power_info,
                lucky_bonuses=lucky_bonuses,
                potential_sets=potential_sets,
                style_discovered=style_discovered,
                story_id=get_selected_story(self.blocker.adhd_buster) if get_selected_story else None,
            )
            dlg.exec()
        except Exception as exc:  # Defensive: surface errors to the user
            show_error(
                self,
                "Analysis Failed",
                f"Could not show power analysis.\n\nDetails: {exc}",
            )
    
    def _refresh_lucky_bonuses_display(self) -> None:
        """Refresh the gear bonuses display showing total bonuses from equipped gear.
        
        Note: Only shows passive bonuses that apply while equipped (like XP bonus).
        Merge-time bonuses (Merge Discount, Merge Luck) are NOT shown here since
        they only apply during the merge process, not while wearing the gear.
        """
        # Clear existing content in collapsible section
        self.lucky_bonuses_section.clear_content()
        
        if not GAMIFICATION_AVAILABLE:
            self.lucky_bonuses_section.setVisible(False)
            return
        
        equipped = self.blocker.adhd_buster.get("equipped", {})
        
        # Calculate lucky options bonuses
        lucky_bonuses = {"coin_bonus": 0, "xp_bonus": 0, "merge_luck": 0}
        if calculate_total_lucky_bonuses:
            lucky_bonuses = calculate_total_lucky_bonuses(equipped)
        
        # Only show PASSIVE bonuses that apply while equipped
        # XP bonus is a passive bonus - you get more XP from activities while wearing the gear
        # Merge Discount and Merge Luck are NOT passive - they only apply during merging
        has_passive_bonuses = lucky_bonuses.get("xp_bonus", 0) > 0
        
        if has_passive_bonuses:
            # Build compact display items - only passive bonuses
            bonus_items = []
            
            if lucky_bonuses.get("xp_bonus", 0) > 0:
                bonus_items.append(("‚≠ê", f"+{lucky_bonuses['xp_bonus']}% XP", "#8b5cf6", "Level faster"))
            
            self.lucky_bonuses_section.setVisible(True)
            self.lucky_bonuses_section.set_title(f"‚ú® Gear Bonuses ({len(bonus_items)})")
            
            # Compact list with colored items
            for icon, title, color, tooltip in bonus_items:
                lbl = QtWidgets.QLabel(f"<b>{icon} {title}</b> <span style='color:#888;'>‚Äî {tooltip}</span>")
                lbl.setTextFormat(QtCore.Qt.RichText)
                lbl.setStyleSheet(f"color: {color}; font-size: 11px; padding: 2px 0;")
                self.lucky_bonuses_section.add_widget(lbl)
            
            # Compact summary
            summary_parts = []
            if lucky_bonuses.get("xp_bonus", 0) > 0:
                summary_parts.append(f"+{lucky_bonuses['xp_bonus']}% XP")
            
            if summary_parts:
                summary_lbl = QtWidgets.QLabel(f"üìä <b>Overall:</b> {' | '.join(summary_parts)}")
                summary_lbl.setTextFormat(QtCore.Qt.RichText)
                summary_lbl.setStyleSheet("color: #a78bfa; font-size: 11px; padding: 4px; background: rgba(139,92,246,0.1); border-radius: 4px;")
                self.lucky_bonuses_section.add_widget(summary_lbl)
        else:
            self.lucky_bonuses_section.setVisible(False)

    def _refresh_potential_sets_display(self) -> None:
        """Refresh the potential set bonuses display from inventory."""
        # Clear existing content in collapsible section
        self.potential_sets_section.clear_content()
        
        if not GAMIFICATION_AVAILABLE:
            self.potential_sets_section.setVisible(False)
            return
        
        inventory = self.blocker.adhd_buster.get("inventory", [])
        equipped = self.blocker.adhd_buster.get("equipped", {})
        
        potential_sets = find_potential_set_bonuses(inventory, equipped)
        
        # Filter to only show sets that could be improved
        improvable_sets = [
            s for s in potential_sets 
            if s["inventory_count"] > 0 and s["potential_bonus"] > s["current_bonus"]
        ]
        
        if improvable_sets:
            self.potential_sets_section.setVisible(True)
            self.potential_sets_section.set_title(f"üí° Potential Set Bonuses ({len(improvable_sets)})")
            
            for s in improvable_sets[:5]:  # Show top 5 potential sets
                if s["current_bonus"] > 0:
                    # Already have some items equipped for this set
                    lbl = QtWidgets.QLabel(
                        f"{s['emoji']} {s['name']}: <b>{s['equipped_count']} equipped</b> + "
                        f"{s['inventory_count']} in bag ‚Üí could be <b>+{s['potential_bonus']} power</b>"
                    )
                    lbl.setTextFormat(QtCore.Qt.RichText)
                    lbl.setStyleSheet("color: #ff9800; font-size: 11px; padding: 2px 0;")
                else:
                    # No items equipped yet
                    lbl = QtWidgets.QLabel(
                        f"{s['emoji']} {s['name']}: {s['inventory_count']} in bag ‚Üí "
                        f"could be <b>+{s['potential_bonus']} power</b> (need {s['max_equippable']} equipped)"
                    )
                    lbl.setTextFormat(QtCore.Qt.RichText)
                    lbl.setStyleSheet("color: #2196f3; font-size: 11px; padding: 2px 0;")
                
                self.potential_sets_section.add_widget(lbl)
            
            tip_lbl = QtWidgets.QLabel("üí° Use 'Optimize Gear' to automatically equip the best items!")
            tip_lbl.setStyleSheet("color: #888; font-style: italic; font-size: 10px;")
            self.potential_sets_section.add_widget(tip_lbl)
        else:
            self.potential_sets_section.setVisible(False)

    def _refresh_character(self) -> None:
        """Refresh all power-related displays after gear changes."""
        if not GAMIFICATION_AVAILABLE:
            return
        # Get updated power info
        equipped = self.blocker.adhd_buster.get("equipped", {})
        power_info = get_power_breakdown(self.blocker.adhd_buster)
        active_story = self.blocker.adhd_buster.get("active_story", "warrior")
        
        # Update character canvas
        self.char_canvas.equipped = equipped
        self.char_canvas.power = power_info["total_power"]
        self.char_canvas.story_theme = active_story  # Update story theme for correct character graphic
        self.char_canvas.tier = get_diary_power_tier(power_info["total_power"])  # Recalculate tier
        self.char_canvas.update()  # Trigger repaint
        
        # Update power label with all components (gear + sets + style + entity patrons)
        power_parts = [str(power_info['base_power'])]
        if power_info.get("set_bonus", 0) > 0:
            power_parts.append(f"+{power_info['set_bonus']} set")
        if power_info.get("style_bonus", 0) > 0:
            style_info = power_info.get("style_info")
            style_name = style_info.get("style", {}).get("name", "style") if style_info else "style"
            power_parts.append(f"+{power_info['style_bonus']} {style_name}")
        if power_info.get("entity_bonus", 0) > 0:
            power_parts.append(f"+{power_info['entity_bonus']} patrons")
        
        if len(power_parts) > 1:
            power_txt = f"‚öî Power: {power_info['total_power']} ({' '.join(power_parts)})"
        else:
            power_txt = f"‚öî Power: {power_info['total_power']}"
        self.power_lbl.setText(power_txt)
        
        # Update stats label
        total_items = len(self.blocker.adhd_buster.get("inventory", []))
        total_collected = self.blocker.adhd_buster.get("total_collected", total_items)
        streak = self.blocker.stats.get("streak_days", 0)
        self.stats_lbl.setText(f"üì¶ {total_items} in bag  |  üéÅ {total_collected} collected  |  üî• {streak} day streak")
        
        # XP display is now handled by the XP ring widget in the timeline header
        # (Removed the large horizontal XP bar)
        
        # Update set bonuses display
        self._refresh_sets_display(power_info)
        
        # Update entity patrons display
        if hasattr(self, 'entity_patrons_section'):
            self._refresh_entity_patrons_display()
        
        # Update potential set bonuses from inventory
        if hasattr(self, 'potential_sets_section'):
            self._refresh_potential_sets_display()
        
        # Update lucky bonuses display
        if hasattr(self, 'lucky_bonuses_section'):
            self._refresh_lucky_bonuses_display()
        
        # Update speech bubble with latest diary entry
        if hasattr(self, 'speech_bubble'):
            diary_entries = self.blocker.adhd_buster.get("diary", [])
            if diary_entries:
                latest = diary_entries[-1]
                entry_text = latest.get("story", "No adventures yet...")
                date_str = latest.get("short_date", latest.get("date", ""))
                tier = latest.get("tier", "unknown")
                self.speech_bubble.setText(f'"{entry_text}"\n\n‚Äî {date_str} | Tier: {tier.title()}')
            else:
                self.speech_bubble.setText("No adventures yet... Start a focus session to write your story!")

    def _refresh_all_slot_combos(self) -> None:
        """Refresh all equipment slot combo boxes with current inventory."""
        inventory = self.blocker.adhd_buster.get("inventory", [])
        equipped = self.blocker.adhd_buster.get("equipped", {})
        
        # Rarity colors for visual distinction
        rarity_colors = {
            "Common": "#9e9e9e",
            "Uncommon": "#4caf50",
            "Rare": "#2196f3",
            "Epic": "#9c27b0",
            "Legendary": "#ff9800"
        }
        
        # Update slot labels with themed names (no rarity - shown in dropdown)
        active_story = self.blocker.adhd_buster.get("active_story", "warrior")
        for slot, label in self.slot_labels.items():
            display_name = get_slot_display_name(slot, active_story) if get_slot_display_name else slot
            label.setText(f"{display_name}:")
            label.setTextFormat(QtCore.Qt.PlainText)
        
        for slot, combo in self.slot_combos.items():
            # Block signals to prevent triggering _on_equip_change
            combo.blockSignals(True)
            combo.clear()
            combo.addItem("[Empty]")
            
            slot_items = [item for item in inventory if item.get("slot") == slot]
            for item in slot_items:
                item_name = item.get('name', 'Unknown')
                item_rarity = item.get('rarity', 'Common')
                item_color = rarity_colors.get(item_rarity, "#9e9e9e")
                power = item.get('power', 10)
                # Show full rarity name with color indicator
                display = f"{item_name} (+{power}) [{item_rarity}]"
                
                # Neighbor system removed - no longer showing indicators
                
                combo.addItem(display, item)
                # Set foreground color for this item
                idx = combo.count() - 1
                combo.setItemData(idx, QtGui.QColor(item_color), QtCore.Qt.ForegroundRole)
                
                # Build comprehensive tooltip for the item
                tooltip_parts = [f"<b style='color:{item_color};'>{item_name}</b>"]
                item_type = item.get("item_type", "")
                if item_type:
                    tooltip_parts.append(f"<i>{item_type}</i>")
                tooltip_parts.append(f"<br>‚öîÔ∏è Power: +{power}")
                tooltip_parts.append(f"<br>üé≠ Rarity: {item_rarity}")
                item_set = item.get("set")
                if item_set:
                    tooltip_parts.append(f"<br>üè∑Ô∏è Set: {item_set}")
                
                # Neighbor system removed - no longer showing neighbor slots
                
                # Special attributes section
                has_special = False
                special_parts = []
                
                lucky_options = item.get("lucky_options", {})
                if lucky_options and format_lucky_options:
                    try:
                        lucky_text = format_lucky_options(lucky_options)
                        if lucky_text:
                            special_parts.append(f"‚ú® Lucky: {lucky_text}")
                            has_special = True
                    except Exception:
                        pass
                
                if has_special:
                    tooltip_parts.append("<br><br><b>‚ú® Special Attributes:</b>")
                    for sp in special_parts:
                        tooltip_parts.append(f"<br>  {sp}")
                
                tooltip_html = "".join(tooltip_parts)
                combo.setItemData(idx, tooltip_html, QtCore.Qt.ToolTipRole)
            
            # Re-select current equipped item if it exists in inventory
            current = equipped.get(slot)
            if current:
                found = False
                current_id = current.get("item_id")
                current_ts = current.get("obtained_at")
                current_slot = current.get("slot")
                for i in range(1, combo.count()):
                    item_data = combo.itemData(i)
                    if not item_data:
                        continue
                    # Match by item_id first, then by timestamp+slot
                    item_id = item_data.get("item_id")
                    if current_id and item_id and current_id == item_id:
                        combo.setCurrentIndex(i)
                        found = True
                        break
                    elif not current_id and not item_id:
                        # Fallback: match by timestamp + slot
                        if item_data.get("obtained_at") == current_ts and item_data.get("slot") == current_slot:
                            combo.setCurrentIndex(i)
                            found = True
                            break
                if not found:
                    # Item no longer in inventory (merged/deleted) - auto-unequip it
                    equipped[slot] = None
                    self.blocker.adhd_buster["equipped"] = equipped
                    self.blocker.save_config()
                    combo.setCurrentIndex(0)
                    combo.setStyleSheet("QComboBox { color: #ffffff; }")
                else:
                    # Apply color to the combo box text for selected item
                    item_rarity = current.get("rarity", "Common")
                    item_color = rarity_colors.get(item_rarity, "#9e9e9e")
                    combo.setStyleSheet(f"QComboBox {{ color: {item_color}; font-weight: bold; }}")
            else:
                combo.setCurrentIndex(0)
                combo.setStyleSheet("QComboBox { color: #ffffff; }")  # White for empty slot
            
            combo.blockSignals(False)
    
    def _refresh_slot_combo(self, slot: str) -> None:
        """Refresh a single equipment slot combo box (for targeted updates)."""
        if slot not in self.slot_combos:
            return
        
        combo = self.slot_combos[slot]
        inventory = self.blocker.adhd_buster.get("inventory", [])
        equipped = self.blocker.adhd_buster.get("equipped", {})
        
        rarity_colors = {
            "Common": "#9e9e9e",
            "Uncommon": "#4caf50",
            "Rare": "#2196f3",
            "Epic": "#9c27b0",
            "Legendary": "#ff9800"
        }
        
        # Update slot label
        if slot in self.slot_labels:
            label = self.slot_labels[slot]
            active_story = self.blocker.adhd_buster.get("active_story", "warrior")
            display_name = get_slot_display_name(slot, active_story) if get_slot_display_name else slot
            current_item = equipped.get(slot)
            if current_item:
                rarity = current_item.get("rarity", "Common")
                color = rarity_colors.get(rarity, "#9e9e9e")
                label.setText(f'{display_name}: <span style="color:{color}; font-weight:bold;">[{rarity}]</span>')
                label.setTextFormat(QtCore.Qt.RichText)
            else:
                label.setText(f"{display_name}:")
                label.setTextFormat(QtCore.Qt.PlainText)
        
        # Refresh combo box
        combo.blockSignals(True)
        combo.clear()
        combo.addItem("[Empty]")
        
        slot_items = [item for item in inventory if item.get("slot") == slot]
        for item in slot_items:
            item_name = item.get('name', 'Unknown')
            item_rarity = item.get('rarity', 'Common')
            item_color = rarity_colors.get(item_rarity, "#9e9e9e")
            power = item.get('power', 10)
            display = f"{item_name} (+{power}) [{item_rarity}]"
            
            combo.addItem(display, item)
            idx = combo.count() - 1
            combo.setItemData(idx, QtGui.QColor(item_color), QtCore.Qt.ForegroundRole)
        
        # Select currently equipped item
        current = equipped.get(slot)
        if current:
            found = False
            current_id = current.get("item_id")
            current_ts = current.get("obtained_at")
            current_slot = current.get("slot")
            for i in range(1, combo.count()):
                item_data = combo.itemData(i)
                if not item_data:
                    continue
                # Match by item_id first, then by timestamp+slot
                item_id = item_data.get("item_id")
                if current_id and item_id and current_id == item_id:
                    combo.setCurrentIndex(i)
                    found = True
                    break
                elif not current_id and not item_id:
                    # Fallback: match by timestamp + slot
                    if item_data.get("obtained_at") == current_ts and item_data.get("slot") == current_slot:
                        combo.setCurrentIndex(i)
                        found = True
                        break
            if not found:
                # Item no longer in inventory (merged/deleted) - auto-unequip it
                equipped[slot] = None
                self.blocker.adhd_buster["equipped"] = equipped
                self.blocker.save_config()
                combo.setCurrentIndex(0)
                combo.setStyleSheet("QComboBox { color: #ffffff; }")
            else:
                item_rarity = current.get("rarity", "Common")
                item_color = rarity_colors.get(item_rarity, "#9e9e9e")
                combo.setStyleSheet(f"QComboBox {{ color: {item_color}; font-weight: bold; }}")
        else:
            combo.setCurrentIndex(0)
            combo.setStyleSheet("QComboBox { color: #ffffff; }")  # White for empty slot
        
        combo.blockSignals(False)

    def _is_item_equipped(self, item: dict, equipped: dict) -> bool:
        """Check if an item is currently equipped using multiple methods.
        
        Priority:
        1. item_id match (most reliable, unique per item)
        2. obtained_at timestamp match (for items without item_id)
        3. name+slot+rarity match (legacy fallback, only if both lack timestamps)
        """
        if not item or not equipped:
            return False
        
        item_id = item.get("item_id")
        item_ts = item.get("obtained_at")
        item_name = item.get("name", "")
        item_slot = item.get("slot", "")
        item_rarity = item.get("rarity", "")
        
        for slot, eq_item in equipped.items():
            if not eq_item:
                continue
            
            # Primary check: item_id match (unique identifier)
            eq_id = eq_item.get("item_id")
            if item_id and eq_id:
                if item_id == eq_id:
                    return True
                # Both have IDs but don't match = different items
                continue
            
            # Secondary check: timestamp match (both must have timestamps)
            eq_ts = eq_item.get("obtained_at")
            if item_ts and eq_ts:
                if item_ts == eq_ts:
                    # Timestamp match - but check slot to avoid false positives from batch generation
                    # Two items with same timestamp but different slots are different items
                    if eq_item.get("slot") == item_slot:
                        return True
                # If timestamps exist but don't match (or slots differ), continue checking
                continue
            
            # Fallback ONLY if BOTH items lack timestamps AND item_ids (legacy data):
            # Match by name, slot, and rarity
            if not item_ts and not eq_ts and not item_id and not eq_id:
                if (eq_item.get("name") == item_name and 
                    eq_item.get("slot") == item_slot and
                    eq_item.get("rarity") == item_rarity):
                    return True
        
        return False

    def _refresh_inventory(self) -> None:
        self.inv_table.setSortingEnabled(False)
        self.inv_table.setRowCount(0)
        self.merge_selected = []
        inventory = self.blocker.adhd_buster.get("inventory", [])
        equipped = self.blocker.adhd_buster.get("equipped", {})
        active_story = self.blocker.adhd_buster.get("active_story", "warrior")

        # Basic sorting for initial list (Table widget handles UI sorting)
        rarity_order = {"Common": 0, "Uncommon": 1, "Rare": 2, "Epic": 3, "Legendary": 4}
        rarity_colors = {
            "Common": "#9e9e9e",
            "Uncommon": "#4caf50",
            "Rare": "#2196f3",
            "Epic": "#9c27b0",
            "Legendary": "#ff9800"
        }
        sort_key = self.sort_combo.currentData() or "newest"
        indexed = list(enumerate(inventory))
        
        # Presort logic (optional now that table sorting is enabled)
        if sort_key == "rarity":
            indexed.sort(key=lambda x: rarity_order.get(x[1].get("rarity", "Common"), 0), reverse=True)
        elif sort_key == "slot":
            indexed.sort(key=lambda x: x[1].get("slot", ""))
        elif sort_key == "power":
            indexed.sort(key=lambda x: x[1].get("power", 10), reverse=True)
        elif sort_key == "lucky":
            def lucky_sort_key(item_tuple):
                item = item_tuple[1]
                lucky_opts = item.get("lucky_options", {})
                has_lucky = 1 if lucky_opts else 0
                num_opts = len(lucky_opts) if lucky_opts else 0
                power = item.get("power", 10)
                return (has_lucky, num_opts, power)
            indexed.sort(key=lucky_sort_key, reverse=True)
        else:
            indexed.reverse()

        # Update inventory stats
        lucky_items_count = sum(1 for item in inventory if item.get("lucky_options", {}))
        total_items = len(inventory)
        if hasattr(self, 'inv_stats_label'):
            # Get max capacity including entity perk bonuses
            from game_state import get_max_inventory_size
            max_capacity = get_max_inventory_size(getattr(self.blocker, 'adhd_buster', {}))
            base_capacity = 500  # Default max without perks
            bonus_slots = max_capacity - base_capacity
            
            if bonus_slots > 0:
                stats_text = f"üì¶ {total_items}/{max_capacity} (base 500 + üêæ {bonus_slots} entity bonus)"
            else:
                stats_text = f"üì¶ {total_items}/{max_capacity} capacity"
            if lucky_items_count > 0:
                stats_text += f" | ‚ú® Lucky: {lucky_items_count} ({lucky_items_count*100//total_items if total_items > 0 else 0}%)"
            self.inv_stats_label.setText(stats_text)

        self.inv_table.setRowCount(len(indexed))
        
        # Neighbor system removed - no longer needed

        for row, (orig_idx, item) in enumerate(indexed):
            is_eq = self._is_item_equipped(item, equipped)
            item_name = item.get("name", "Unknown Item")
            item_type = item.get("item_type", "")
            item_rarity = item.get("rarity", "Common")
            power = item.get("power", RARITY_POWER.get(item_rarity, 10))
            item_set = item.get("set", "")
            slot = item.get("slot", "Unknown")
            slot_display = get_slot_display_name(slot, active_story) if get_slot_display_name else slot
            rarity_color = rarity_colors.get(item_rarity, "#9e9e9e")
            
            lucky_options = item.get("lucky_options", {})
            coin_discount = lucky_options.get("coin_discount", 0)
            xp_bonus = lucky_options.get("xp_bonus", 0)
            merge_luck = lucky_options.get("merge_luck", 0)
            
            # Helper: Create read-only item
            def create_item(text, align=QtCore.Qt.AlignLeft):
                it = QtWidgets.QTableWidgetItem(str(text))
                it.setFlags(QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable)
                it.setTextAlignment(align)
                return it

            # 0: Merge checkbox - clickable for non-equipped items
            if is_eq:
                merge_check = create_item("üîí", QtCore.Qt.AlignCenter)
                merge_check.setToolTip("Equipped items cannot be merged")
                merge_check.setForeground(QtGui.QColor("#666666"))
            else:
                merge_check = create_item("‚òê", QtCore.Qt.AlignCenter)
                merge_check.setToolTip("Click to select for merge")
                merge_check.setForeground(QtGui.QColor("#888888"))
            merge_check.setData(QtCore.Qt.UserRole, orig_idx)
            merge_check.setData(QtCore.Qt.UserRole + 1, False)  # Store checked state
            merge_check.setData(QtCore.Qt.UserRole + 2, is_eq)  # Store equipped state
            self.inv_table.setItem(row, 0, merge_check)

            # 1: Equipped
            eq_item = create_item("‚úì" if is_eq else "", QtCore.Qt.AlignCenter)
            if is_eq:
                eq_item.setForeground(QtGui.QColor("#4caf50"))
            eq_item.setToolTip("Equipped" if is_eq else "Not Equipped")
            self.inv_table.setItem(row, 1, eq_item)
            
            # 2: Name
            name_prefix = "‚ú® " if lucky_options else ""
            name_item = create_item(f"{name_prefix}{item_name}")
            name_item.setForeground(QtGui.QColor(rarity_color))
            name_item.setData(QtCore.Qt.UserRole, orig_idx)
            name_item.setToolTip(f"{item_name}\nRarity: {item_rarity}\n{'Equipped' if is_eq else 'In Inventory'}")
            self.inv_table.setItem(row, 2, name_item)
            
            # 3: Slot
            slot_item = create_item(slot_display[:4], QtCore.Qt.AlignCenter)
            slot_item.setToolTip(f"Slot: {slot_display}")
            self.inv_table.setItem(row, 3, slot_item)
            
            # 4: Tier
            tier_item = create_item(item_rarity[:1], QtCore.Qt.AlignCenter)
            tier_item.setForeground(QtGui.QColor(rarity_color))
            tier_item.setToolTip(f"Rarity: {item_rarity}")
            self.inv_table.setItem(row, 4, tier_item)
            
            # 5: Power
            pwr_item = create_item(str(power), QtCore.Qt.AlignCenter)
            pwr_item.setToolTip(f"Power Level: {power}")
            self.inv_table.setItem(row, 5, pwr_item)
            
            # 6: Set
            set_item = create_item(item_set if item_set else "-", QtCore.Qt.AlignCenter)
            set_item.setToolTip(f"Set: {item_set}" if item_set else "No Set")
            self.inv_table.setItem(row, 6, set_item)
            
            # 7: Coin
            coin_text = f"{coin_discount}%" if coin_discount else ""
            coin_item = create_item(coin_text, QtCore.Qt.AlignCenter)
            if coin_discount: coin_item.setForeground(QtGui.QColor("#fbbf24"))
            coin_item.setToolTip(f"Coin Discount: {coin_discount}% off merge costs")
            self.inv_table.setItem(row, 7, coin_item)
            
            # 8: XP
            xp_text = f"{xp_bonus}%" if xp_bonus else ""
            xp_item = create_item(xp_text, QtCore.Qt.AlignCenter)
            if xp_bonus: xp_item.setForeground(QtGui.QColor("#8b5cf6"))
            xp_item.setToolTip(f"XP Bonus: +{xp_bonus}%")
            self.inv_table.setItem(row, 8, xp_item)
            
            # 9: Merge Luck
            merge_text = f"{merge_luck}%" if merge_luck else ""
            merge_item = create_item(merge_text, QtCore.Qt.AlignCenter)
            if merge_luck: merge_item.setForeground(QtGui.QColor("#06b6d4"))
            merge_item.setToolTip(f"Merge Luck: +{merge_luck}%")
            self.inv_table.setItem(row, 9, merge_item)
            
            self.inv_table.setRowHeight(row, 24)
            
        self.inv_table.setSortingEnabled(True)
        
        # Update merge button text to reflect cleared selection
        self._update_merge_selection()
        
        # Update entity perk display for bonus inventory slots
        self._update_inventory_entity_perks()

    def _update_inventory_entity_perks(self) -> None:
        """Update the entity perk display showing bonus inventory slots from entities."""
        try:
            if not hasattr(self, 'inv_entity_perk_container'):
                return
                
            adhd_data = getattr(self.blocker, 'adhd_buster', {})
            if not adhd_data:
                self.inv_entity_perk_container.setVisible(False)
                return
            
            from gamification import get_entity_qol_perk_contributors
            qol_perks = get_entity_qol_perk_contributors(adhd_data)
            total_slots = qol_perks.get("total_inventory_slots", 0)
            contributors = [c for c in qol_perks.get("contributors", []) 
                          if c.get("perk_type") == "inventory"]
            
            # Hide if no bonus slots
            if total_slots <= 0 or not contributors:
                self.inv_entity_perk_container.setVisible(False)
                return
            
            # Clear existing content
            while self.inv_entity_perk_layout.count():
                child = self.inv_entity_perk_layout.takeAt(0)
                if child.widget():
                    child.widget().deleteLater()
            
            # Try to import entity icon resolver
            try:
                from entitidex_tab import _resolve_entity_svg_path
                from entitidex.entity_pools import get_entity_by_id as get_entity
                from PySide6.QtSvg import QSvgRenderer
                has_svg_support = True
            except ImportError:
                has_svg_support = False
            
            # Add perk icon and summary label
            summary_lbl = QtWidgets.QLabel(f"üì¶ +{total_slots} slots from:")
            summary_lbl.setStyleSheet("color: #7986cb; font-size: 10px; font-weight: bold;")
            summary_lbl.setToolTip(f"Entity perks provide +{total_slots} bonus inventory slots")
            self.inv_entity_perk_layout.addWidget(summary_lbl)
            
            # Create mini entity cards
            for entity_data in contributors:
                card = QtWidgets.QFrame()
                is_exceptional = entity_data.get("is_exceptional", False)
                
                card.setStyleSheet("""
                    QFrame {
                        background-color: #2a2a2a;
                        border: 1px solid #444;
                        border-radius: 4px;
                        padding: 2px;
                    }
                    QFrame:hover {
                        border-color: #7986cb;
                    }
                """)
                
                card_layout = QtWidgets.QHBoxLayout(card)
                card_layout.setContentsMargins(4, 2, 4, 2)
                card_layout.setSpacing(4)
                
                # Try to load entity SVG icon (24x24 mini)
                entity_id = entity_data.get("entity_id", "")
                icon_loaded = False
                
                if has_svg_support and entity_id:
                    try:
                        entity_obj = get_entity(entity_id)
                        if entity_obj:
                            svg_path = _resolve_entity_svg_path(entity_obj, is_exceptional)
                            if svg_path:
                                renderer = QSvgRenderer(svg_path)
                                if renderer.isValid():
                                    icon_size = 24
                                    pixmap = QtGui.QPixmap(icon_size, icon_size)
                                    pixmap.fill(QtCore.Qt.transparent)
                                    painter = QtGui.QPainter(pixmap)
                                    renderer.render(painter)
                                    painter.end()
                                    
                                    icon_lbl = QtWidgets.QLabel()
                                    icon_lbl.setPixmap(pixmap)
                                    icon_lbl.setFixedSize(icon_size, icon_size)
                                    card_layout.addWidget(icon_lbl)
                                    icon_loaded = True
                    except Exception:
                        pass
                
                # Entity name and bonus
                name = entity_data.get("name", "Unknown")
                value = entity_data.get("value", 0)
                display_name = name[:12] + "..." if len(name) > 12 else name
                
                if is_exceptional:
                    name_style = "color: #ffd700; font-weight: bold; font-size: 9px;"
                    prefix = "‚≠ê " if not icon_loaded else ""
                else:
                    name_style = "color: #ccc; font-size: 9px;"
                    prefix = ""
                
                text_lbl = QtWidgets.QLabel(f"{prefix}{display_name} (+{value})")
                text_lbl.setStyleSheet(name_style)
                text_lbl.setToolTip(f"{name}\n{entity_data.get('description', '')}")
                card_layout.addWidget(text_lbl)
                
                self.inv_entity_perk_layout.addWidget(card)
            
            self.inv_entity_perk_layout.addStretch()
            self.inv_entity_perk_container.setVisible(True)
            
        except Exception as e:
            print(f"[Gear Tab] Error updating inventory entity perks: {e}")
            if hasattr(self, 'inv_entity_perk_container'):
                self.inv_entity_perk_container.setVisible(False)

    def refresh_gear_combos(self) -> None:
        """Refresh gear dropdown combos to reflect new inventory items.
        
        This is called externally (e.g., after item drops), so it uses
        the comprehensive refresh_all() method.
        """
        self.refresh_all()

    def _on_inventory_cell_clicked(self, row: int, col: int) -> None:
        """Handle clicks on inventory table cells - toggle merge checkbox."""
        # Get the checkbox item in column 0
        check_item = self.inv_table.item(row, 0)
        if not check_item:
            return
            
        # Check if item is equipped (can't merge equipped items)
        is_eq = check_item.data(QtCore.Qt.UserRole + 2)
        if is_eq:
            return  # Can't toggle equipped items
            
        # Toggle the checked state
        is_checked = check_item.data(QtCore.Qt.UserRole + 1)
        new_checked = not is_checked
        check_item.setData(QtCore.Qt.UserRole + 1, new_checked)
        
        # Update visual appearance
        if new_checked:
            check_item.setText("‚úÖ")
            check_item.setForeground(QtGui.QColor("#00ff00"))
            check_item.setToolTip("Selected for merge - click to deselect")
            # Highlight the entire row
            for c in range(self.inv_table.columnCount()):
                cell = self.inv_table.item(row, c)
                if cell:
                    cell.setBackground(QtGui.QColor("#2a4a2a"))  # Green tint
        else:
            check_item.setText("‚òê")
            check_item.setForeground(QtGui.QColor("#888888"))
            check_item.setToolTip("Click to select for merge")
            # Remove row highlight
            for c in range(self.inv_table.columnCount()):
                cell = self.inv_table.item(row, c)
                if cell:
                    cell.setBackground(QtGui.QColor("transparent"))
        
        # Update merge selection
        self._update_merge_selection()

    def _update_merge_selection(self) -> None:
        # Get selected indices from checkbox states (column 0)
        self.merge_selected = []
        for row in range(self.inv_table.rowCount()):
            check_item = self.inv_table.item(row, 0)
            if check_item and check_item.data(QtCore.Qt.UserRole + 1):  # Is checked
                idx = check_item.data(QtCore.Qt.UserRole)  # Original inventory index
                if idx is not None and isinstance(idx, int):
                    self.merge_selected.append(idx)
        
        inventory = self.blocker.adhd_buster.get("inventory", [])
        equipped = self.blocker.adhd_buster.get("equipped", {})
        
        # Filter to only valid indices within inventory bounds
        valid_indices = [idx for idx in self.merge_selected if 0 <= idx < len(inventory)]
        count = len(valid_indices)
        
        self.merge_btn.setText(f"üé≤ Merge Selected ({count})")
        
        # Never enable merge during active session
        if self._session_active:
            self.merge_btn.setEnabled(False)
            self.merge_rate_lbl.setText("üîí Merging disabled during focus session")
            return
        
        if count >= 2 and GAMIFICATION_AVAILABLE:
            items = [inventory[idx] for idx in valid_indices]
            
            # Check if any selected items are equipped (using robust check)
            equipped_selected = [i for i in items if self._is_item_equipped(i, equipped)]
            if equipped_selected:
                self.merge_btn.setEnabled(False)
                self.merge_rate_lbl.setText("‚ö†Ô∏è Cannot merge equipped items!")
                return
            
            worthwhile, reason = is_merge_worthwhile(items)
            if not worthwhile:
                self.merge_btn.setEnabled(False)
                self.merge_rate_lbl.setText(f"‚ö†Ô∏è {reason}")
            else:
                # Calculate the discounted merge cost to check affordability
                from gamification import COIN_COSTS, calculate_merge_discount, apply_coin_discount, apply_coin_flat_reduction, get_entity_merge_perk_contributors
                from city import get_city_bonuses
                current_coins = self.blocker.adhd_buster.get("coins", 0)
                discount_pct = calculate_merge_discount(items)
                
                # Get city coin discount (Market building)
                city_coin_discount = 0
                try:
                    city_bonuses = get_city_bonuses(self.blocker.adhd_buster)
                    city_coin_discount = city_bonuses.get("coin_discount", 0)
                except Exception:
                    pass
                
                # Combine item + city discounts (cap at 90%)
                total_discount_pct = min(discount_pct + city_coin_discount, 90)
                
                # Get entity flat coin reduction
                entity_perks = get_entity_merge_perk_contributors(self.blocker.adhd_buster)
                entity_coin_flat = entity_perks.get("total_coin_discount", 0)
                
                # Calculate actual cost after discounts
                base_cost = COIN_COSTS.get("merge_base", 50)
                discounted_cost = apply_coin_flat_reduction(
                    apply_coin_discount(base_cost, total_discount_pct),
                    entity_coin_flat
                )
                
                # Update cost warning label to show discounted price
                if discounted_cost < base_cost:
                    discount_info = f" (Base: {base_cost}ü™ô)"
                    self.merge_warn_lbl.setText(f"‚ö†Ô∏è 25% base success (items lost on fail!) ‚Ä¢ Cost: {discounted_cost}ü™ô{discount_info}")
                    self.merge_warn_lbl.setStyleSheet("color: #4caf50; font-size: 10px;")  # Green for discount
                else:
                    self.merge_warn_lbl.setText(f"‚ö†Ô∏è 25% base success (items lost on fail!) ‚Ä¢ Cost: {discounted_cost}ü™ô")
                    self.merge_warn_lbl.setStyleSheet("color: #d32f2f; font-size: 10px;")  # Red for regular
                
                # Check if player can afford the merge
                if current_coins < discounted_cost:
                    self.merge_btn.setEnabled(False)
                    self.merge_rate_lbl.setText(f"‚ö†Ô∏è Need {discounted_cost} coins (you have {current_coins})")
                    return
                
                self.merge_btn.setEnabled(True)
                
                # Calculate merge luck from items being merged (not equipped gear)
                # This encourages sacrificing items with merge_luck for better odds
                items_merge_luck = 0
                for item in items:
                    if item and isinstance(item, dict):
                        lucky_opts = item.get("lucky_options", {})
                        if isinstance(lucky_opts, dict):
                            items_merge_luck += lucky_opts.get("merge_luck", 0)
                
                # Get city bonus for merge success (Forge building)
                city_merge_bonus = 0
                try:
                    from gamification import get_all_perk_bonuses
                    all_bonuses = get_all_perk_bonuses(self.blocker.adhd_buster)
                    city_merge_bonus = all_bonuses.get("merge_success", 0)
                except Exception:
                    pass
                
                rate = calculate_merge_success_rate(items, items_merge_luck=items_merge_luck, city_bonus=city_merge_bonus)
                result_rarity = get_merge_result_rarity(items)
                all_legendary = all(i.get("rarity") == "Legendary" for i in items)
                if all_legendary:
                    # Legendary-only merges act as a reroll to a new legendary item/slot.
                    if items_merge_luck > 0:
                        self.merge_rate_lbl.setText(
                            f"Legendary reroll: {rate*100:.0f}% (+{items_merge_luck}% from items) ‚Üí Legendary item"
                        )
                    else:
                        self.merge_rate_lbl.setText(
                            f"Legendary reroll: {rate*100:.0f}% ‚Üí Legendary item"
                        )
                else:
                    if items_merge_luck > 0:
                        self.merge_rate_lbl.setText(f"Success rate: {rate*100:.0f}% (+{items_merge_luck}% from items) ‚Üí {result_rarity} item")
                    else:
                        self.merge_rate_lbl.setText(f"Success rate: {rate*100:.0f}% ‚Üí {result_rarity} item")
        else:
            self.merge_btn.setEnabled(False)
            self.merge_rate_lbl.setText("Select 2+ items to merge")
            # Reset cost label to base cost when no items selected
            self.merge_warn_lbl.setText("‚ö†Ô∏è 25% base success (items lost on fail!) ‚Ä¢ Cost: 50ü™ô")
            self.merge_warn_lbl.setStyleSheet("color: #d32f2f; font-size: 10px;")

    def _do_merge(self) -> None:
        if len(self.merge_selected) < 2:
            return
        if not GAMIFICATION_AVAILABLE:
            show_warning(self, "Feature Unavailable", "Gamification features are not available.")
            return
        
        # Re-fetch inventory fresh to avoid stale indices
        inventory = self.blocker.adhd_buster.get("inventory", [])
        
        # Validate indices are integers and within bounds
        valid_indices = [idx for idx in self.merge_selected if isinstance(idx, int) and 0 <= idx < len(inventory)]
        if len(valid_indices) < 2:
            show_warning(self, "Invalid Selection", 
                "Selected items are no longer valid. Please refresh and try again.")
            self._refresh_inventory()
            return

        # Check if player has enough coins for the discounted base merge cost
        from gamification import COIN_COSTS, calculate_merge_discount, apply_coin_discount, apply_coin_flat_reduction, get_entity_merge_perk_contributors
        from city import get_city_bonuses
        current_coins = self.blocker.adhd_buster.get("coins", 0)
        temp_discount = calculate_merge_discount([inventory[idx] for idx in valid_indices])
        
        # Get city coin discount (Market building)
        city_coin_discount = 0
        try:
            city_bonuses = get_city_bonuses(self.blocker.adhd_buster)
            city_coin_discount = city_bonuses.get("coin_discount", 0)
        except Exception:
            pass
        
        # Combine item + city discounts (cap at 90%)
        total_temp_discount = min(temp_discount + city_coin_discount, 90)
        
        # Get entity flat coin reduction
        entity_perks = get_entity_merge_perk_contributors(self.blocker.adhd_buster)
        entity_coin_flat = entity_perks.get("total_coin_discount", 0)
        
        temp_base_cost = apply_coin_flat_reduction(
            apply_coin_discount(COIN_COSTS.get("merge_base", 50), total_temp_discount),
            entity_coin_flat
        )
        if current_coins < temp_base_cost:
            show_warning(self, "Not Enough Coins", 
                f"Lucky Merge base cost is {temp_base_cost} coins after discount.\n\n"
                f"You have: {current_coins} coins\n"
                f"You need: {temp_base_cost - current_coins} more coins\n\n"
                f"Complete focus sessions to earn more coins!")
            return
        
        items = [inventory[idx] for idx in valid_indices]
        
        # Check for items without timestamps (data integrity issue)
        items_without_ts = [i for i in items if not i.get("obtained_at")]
        if items_without_ts:
            # Add timestamps to fix data integrity
            for item in items_without_ts:
                item["obtained_at"] = datetime.now().isoformat()
            self.blocker.save_config()
        
        equipped = self.blocker.adhd_buster.get("equipped", {})
        
        # Calculate coin discount from items being merged (not equipped)
        from gamification import calculate_merge_discount
        coin_discount = calculate_merge_discount(items)
        
        # Show new professional merge dialog with player coins for boost option
        from merge_dialog import LuckyMergeDialog
        dialog = LuckyMergeDialog(items, 0, equipped, parent=self, player_coins=current_coins, 
                                  coin_discount=coin_discount, entity_perks=entity_perks,
                                  adhd_buster=self.blocker.adhd_buster)
        if dialog.exec() != QtWidgets.QDialog.Accepted:
            return
        
        # Get result from dialog
        result = dialog.merge_result
        if not result:
            return
        
        # Calculate total cost (base + optional boost + tier upgrade) using centralized costs
        from gamification import COIN_COSTS, apply_coin_discount, apply_coin_flat_reduction
        from city import get_city_bonuses
        boost_enabled = getattr(dialog, 'boost_enabled', False)
        tier_upgrade_enabled = getattr(dialog, 'tier_upgrade_enabled', False)
        
        # Calculate discount from ITEMS BEING MERGED (not equipped)
        discount_pct = calculate_merge_discount(items)
        
        # Get city coin discount (Market building)
        city_coin_discount = 0
        try:
            city_bonuses = get_city_bonuses(self.blocker.adhd_buster)
            city_coin_discount = city_bonuses.get("coin_discount", 0)
        except Exception:
            pass
        
        # Combine item + city discounts (cap at 90%)
        total_discount_pct = min(discount_pct + city_coin_discount, 90)
        
        # Get entity flat coin reduction from dialog
        entity_coin_flat = getattr(dialog, 'entity_coin_flat', 0)
        
        # Calculate costs: percentage discount first, then flat reduction
        base_cost = apply_coin_flat_reduction(apply_coin_discount(COIN_COSTS.get("merge_base", 50), total_discount_pct), entity_coin_flat)
        boost_cost = apply_coin_flat_reduction(apply_coin_discount(COIN_COSTS.get("merge_boost", 50), total_discount_pct), entity_coin_flat) if boost_enabled else 0
        tier_upgrade_cost = apply_coin_flat_reduction(apply_coin_discount(COIN_COSTS.get("merge_tier_upgrade", 50), total_discount_pct), entity_coin_flat) if tier_upgrade_enabled else 0
        # Add retry costs if any
        retry_cost = getattr(dialog, 'retry_cost_accumulated', 0)
        
        # Add claim cost if item was claimed via near-miss recovery (discounted)
        claim_cost = 0
        if result.get("claimed_with_coins"):
            claim_cost = apply_coin_flat_reduction(apply_coin_discount(COIN_COSTS.get("merge_claim", 100), total_discount_pct), entity_coin_flat)
            
        total_cost = base_cost + boost_cost + tier_upgrade_cost + retry_cost + claim_cost
        
        # Re-validate inventory state BEFORE spending coins
        inventory = self.blocker.adhd_buster.get("inventory", [])
        if not all(0 <= idx < len(inventory) for idx in valid_indices):
            show_warning(self, "Inventory Changed", 
                "Inventory changed during merge. Please try again.")
            self._refresh_inventory()
            return
        
        # Re-fetch items with fresh inventory
        items = [inventory[idx] for idx in valid_indices]
        
        # Final safety check: ensure no equipped items are being merged (using robust check)
        equipped = self.blocker.adhd_buster.get("equipped", {})
        equipped_in_merge = [i for i in items if self._is_item_equipped(i, equipped)]
        if equipped_in_merge:
            show_warning(
                self, "Cannot Merge",
                f"Cannot merge equipped items! Unequip them first.\n\n"
                f"Equipped items selected: {len(equipped_in_merge)}"
            )
            return
        
        # Spend coins for the merge attempt (AFTER all validation passes)
        # total_cost includes base cost + optional boost
        if self._game_state:
            if not self._game_state.spend_coins(total_cost):
                show_warning(self, "Error", f"Failed to spend {total_cost} coins for merge.")
                return
        else:
            # Fallback: directly deduct coins if no game state manager
            current_coins = self.blocker.adhd_buster.get("coins", 0)
            if current_coins < total_cost:
                show_warning(self, "Error", f"Not enough coins for merge (need {total_cost}).")
                return
            self.blocker.adhd_buster["coins"] = current_coins - total_cost
            self.blocker.save_config()
        
        # Check for salvage (player paid to save one random item)
        salvaged_item = result.get("salvaged_item")
        salvage_cost = result.get("salvage_cost", 0)
        if salvaged_item and salvage_cost > 0:
            # Deduct salvage cost
            if self._game_state:
                self._game_state.spend_coins(salvage_cost)
            else:
                current_coins = self.blocker.adhd_buster.get("coins", 0)
                self.blocker.adhd_buster["coins"] = max(0, current_coins - salvage_cost)
                self.blocker.save_config()
            
            # Remove the salvaged item from the items to be deleted
            # Use item_id for matching, fallback to timestamp+slot
            salvage_id = salvaged_item.get("item_id")
            salvage_ts = salvaged_item.get("obtained_at")
            salvage_slot = salvaged_item.get("slot")
            items = [
                i for i in items 
                if not (
                    (salvage_id and i.get("item_id") == salvage_id) or
                    (not salvage_id and i.get("obtained_at") == salvage_ts and i.get("slot") == salvage_slot)
                )
            ]
        
        # Use GameState manager to perform the merge atomically
        if self._game_state:
            self._game_state.perform_merge(items, result.get("result_item"), result["success"])
            # Sync changes to active hero
            if GAMIFICATION_AVAILABLE:
                sync_hero_data(self.blocker.adhd_buster)
            
            # Award scrap (leftovers from merging)
            scrap_earned = result.get("scrap_earned", 0)
            if scrap_earned > 0:
                self._game_state.add_scrap(scrap_earned)
        else:
            show_warning(self, "Error", "Game State Manager not initialized. Cannot merge.")
            return
        
        # Result feedback already shown by dialog
        # Clear merge selection
        self.merge_selected = []
        
        # Show perk toast if entity perks contributed to the merge
        if entity_perks.get("total_coin_discount", 0) > 0 or entity_perks.get("total_merge_luck", 0) > 0:
            perk_parts = []
            if entity_perks.get("total_coin_discount", 0) > 0:
                perk_parts.append(f"-{entity_perks['total_coin_discount']} coins")
            if entity_perks.get("total_merge_luck", 0) > 0:
                perk_parts.append(f"+{entity_perks['total_merge_luck']}% luck")
            if perk_parts:
                show_perk_toast(f"Entity Perks: {', '.join(perk_parts)}", "‚ú®", self)
        
        # Only do manual refresh if GameState not available
        if not self._game_state:
            self.refresh_all()

    def _save_inventory_state(self) -> None:
        """Save inventory table column configuration."""
        try:
            settings = QtCore.QSettings("PersonalFreedom", "FocusBlocker")
            header_state = self.inv_table.horizontalHeader().saveState()
            settings.setValue("inventory_header_state", header_state)
        except Exception as e:
            print(f"Error saving inventory state: {e}")

    def _load_inventory_state(self) -> None:
        """Load inventory table column configuration."""
        try:
            settings = QtCore.QSettings("PersonalFreedom", "FocusBlocker")
            header_state = settings.value("inventory_header_state")
            if header_state:
                self.inv_table.horizontalHeader().restoreState(header_state)
        except Exception as e:
            print(f"Error loading inventory state: {e}")

    def _save_hero_splitter_state(self) -> None:
        """Save hero/equipment splitter position."""
        try:
            if hasattr(self, 'char_equip_splitter'):
                settings = QtCore.QSettings("PersonalFreedom", "FocusBlocker")
                settings.setValue("hero_splitter_state", self.char_equip_splitter.saveState())
                settings.setValue("hero_splitter_sizes", self.char_equip_splitter.sizes())
        except Exception as e:
            print(f"Error saving hero splitter state: {e}")

    def _load_hero_splitter_state(self) -> None:
        """Load hero/equipment splitter position."""
        try:
            settings = QtCore.QSettings("PersonalFreedom", "FocusBlocker")
            splitter_state = settings.value("hero_splitter_state")
            if splitter_state:
                self.char_equip_splitter.restoreState(splitter_state)
            else:
                # Default: give hero ~40% and equipment ~60%
                self.char_equip_splitter.setSizes([180, 270])
        except Exception as e:
            print(f"Error loading hero splitter state: {e}")
            # Fallback to default sizes
            self.char_equip_splitter.setSizes([180, 270])

    def _open_diary(self) -> None:
        dialog = DiaryDialog(self.blocker, self)
        dialog.exec()
        dialog.hide()  # Explicitly hide before deletion
        dialog.deleteLater()
    
    def _go_to_story_tab(self) -> None:
        """Navigate to the Story tab."""
        # Find parent FocusBlockerWindow and switch to Story tab
        parent = self.parent()
        while parent is not None:
            if hasattr(parent, 'tabs') and hasattr(parent, 'story_tab'):
                for i in range(parent.tabs.count()):
                    if parent.tabs.widget(i) == parent.story_tab:
                        parent.tabs.setCurrentIndex(i)
                        return
            parent = parent.parent()
    
    def _update_story_indicator(self) -> None:
        """Update the story indicator label with current story name."""
        if not GAMIFICATION_AVAILABLE or not hasattr(self, 'story_indicator_lbl'):
            return
        from gamification import AVAILABLE_STORIES, get_selected_story
        current_story = get_selected_story(self.blocker.adhd_buster)
        story_info = AVAILABLE_STORIES.get(current_story, {})
        self.story_indicator_lbl.setText(f"üìú Current Story: <b>{story_info.get('title', current_story)}</b>")

    def _optimize_gear(self) -> None:
        """Automatically equip the best gear based on user criteria."""
        if not GAMIFICATION_AVAILABLE:
            show_warning(self, "Optimize Gear", "Gamification module not available!")
            return
        
        # Check if player has enough coins (use centralized costs with entity perk)
        from gamification import COIN_COSTS, get_entity_optimize_gear_cost
        optimize_perk = get_entity_optimize_gear_cost(self.blocker.adhd_buster)
        OPTIMIZE_COST = optimize_perk["cost"]
        current_coins = self.blocker.adhd_buster.get("coins", 0)
        
        # Only check coins if cost > 0
        if OPTIMIZE_COST > 0 and current_coins < OPTIMIZE_COST:
            show_warning(self, "Not Enough Coins", 
                f"Optimize Gear costs {OPTIMIZE_COST} coins.\n\n"
                f"You have: {current_coins} coins\n"
                f"You need: {OPTIMIZE_COST - current_coins} more coins")
            return
        
        inventory = self.blocker.adhd_buster.get("inventory", [])
        equipped = self.blocker.adhd_buster.get("equipped", {})
        
        if not inventory and not any(equipped.values()):
            show_info(self, "Optimize Gear", "No gear available to optimize!")
            return

        # Show styled dialog for optimization criteria
        from styled_dialog import OptimizeGearDialog
        dialog = OptimizeGearDialog(
            parent=self,
            current_coins=current_coins,
            optimize_cost=OPTIMIZE_COST,
            has_entity_perk=optimize_perk["has_perk"],
            perk_description=optimize_perk.get("description", "")
        )
        
        if dialog.exec() != QtWidgets.QDialog.Accepted:
            return
        
        mode, target_opt = dialog.get_selections()
        
        # Calculate optimal gear
        result = optimize_equipped_gear(
            self.blocker.adhd_buster, 
            mode=mode, 
            target_opt=target_opt
        )
        
        if not result["changes"]:
            show_info(
                self, "Optimize Gear",
                "Your gear is already optimized for this strategy! ‚öîÔ∏è\n\n"
                f"Current power: {result['old_power']}"
            )
            return
        
        # Show preview of changes
        changes_text = "\n".join(f"  ‚Ä¢ {c}" for c in result["changes"]) if result["changes"] else "  No changes needed"
        
        # Calculate lucky bonuses difference
        lucky_summary = ""
        if calculate_total_lucky_bonuses:  # BUG FIX #36: Check function exists
            try:
                old_bonuses = calculate_total_lucky_bonuses(equipped)
                new_bonuses = calculate_total_lucky_bonuses(result["new_equipped"])
                
                bonus_changes = []
                for bonus_type in ["coin_discount", "xp_bonus", "merge_luck"]:
                    old_val = old_bonuses.get(bonus_type, 0)
                    new_val = new_bonuses.get(bonus_type, 0)
                    if old_val != new_val:
                        diff = new_val - old_val
                        sign = "+" if diff > 0 else ""
                        names = {"coin_discount": "Merge Discount", "xp_bonus": "XP", "merge_luck": "Merge Success"}
                        bonus_changes.append(f"{names[bonus_type]}: {old_val}% ‚Üí {new_val}% ({sign}{diff}%)")
                
                if bonus_changes:
                    lucky_summary = "\n\nBonuses Changes:\n" + "\n".join(f"  ‚Ä¢ {c}" for c in bonus_changes)
            except Exception:
                # Silently ignore if calculation fails
                pass

        # BUG FIX #28: Show appropriate strategy description
        strategy_desc = mode.title()
        if mode != "power" and target_opt != "all":
            strategy_desc += f" ({target_opt.replace('_', ' ').title()})"
        elif mode != "power":
            strategy_desc += " (All Bonuses)"
        
        # Show cost based on entity perk (Robo Rat = FREE)
        if OPTIMIZE_COST == 0:
            cost_str = "ü§ñ FREE (Robo Rat)"
        elif OPTIMIZE_COST == 1:
            cost_str = "üêÄ 1 coin (Hobo Rat)"
        else:
            cost_str = f"üí∞ {OPTIMIZE_COST} coins"
            
        msg = (
            f"Found a better gear configuration!\n"
            f"Strategy: {strategy_desc}\n\n"
            f"Power Gain: {result['power_gain']:+d} ({result['old_power']} ‚Üí {result['new_power']})\n\n"
            f"Changes:\n{changes_text}"
            f"{lucky_summary}\n\n"
            f"{cost_str}\n\n"
            "Do you want to equip this gear?"
        )
        
        reply = show_question(
            self, "Optimize Gear", msg,
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            QtWidgets.QMessageBox.Yes
        )
        
        if reply == QtWidgets.QMessageBox.Yes:
            # Spend coins for optimization (use same cost from earlier check)
            # Skip spending if cost is 0 (Robo Rat perk)
            if OPTIMIZE_COST > 0:
                if self._game_state:
                    if not self._game_state.spend_coins(OPTIMIZE_COST):
                        show_warning(self, "Error", "Failed to spend coins for optimization.")
                        return
                else:
                    # Fallback: directly deduct coins if no game state manager
                    current_coins = self.blocker.adhd_buster.get("coins", 0)
                    if current_coins < OPTIMIZE_COST:
                        show_warning(self, "Error", "Not enough coins for optimization.")
                        return
                    self.blocker.adhd_buster["coins"] = current_coins - OPTIMIZE_COST
            
            # Apply changes via GameStateManager for proper deep copying and signals
            if self._game_state:
                self._game_state.set_all_equipped(result["new_equipped"])
                # Sync to hero
                if GAMIFICATION_AVAILABLE:
                    sync_hero_data(self.blocker.adhd_buster)
            else:
                # Fallback: directly update equipped if no game state manager
                self.blocker.adhd_buster["equipped"] = result["new_equipped"]
                self.blocker.save_config()
                if GAMIFICATION_AVAILABLE:
                    sync_hero_data(self.blocker.adhd_buster)
            
            # Show result message
            if result["power_gain"] > 0:
                show_info(
                    self, "Gear Optimized! ‚ö°",
                    f"Power increased from {result['old_power']} to {result['new_power']}!\n"
                    f"(+{result['power_gain']} power)"
                )
            else:
                show_info(
                    self, "Gear Updated! ‚öîÔ∏è",
                    f"Gear configuration updated.\nPower: {result['new_power']}"
                )
            
            # Play sound if available
            if hasattr(self, "_play_sound"):
                self._play_sound("equip")
                
            self.refresh_all()

    def _sell_items(self) -> None:
        """Open the sell items dialog."""
        if not self._game_state:
            styled_warning(self, "Error", "Game State Manager not initialized. Cannot sell items.")
            return
        
        dialog = SellItemsDialog(self.blocker, self._game_state, self)
        dialog.exec()



class SellItemsDialog(StyledDialog):
    """Dialog for selling items by tier or by selection."""

    def __init__(self, blocker: BlockerCore, game_state, parent: Optional[QtWidgets.QWidget] = None) -> None:
        self.blocker = blocker
        self.game_state = game_state
        
        super().__init__(
            parent=parent,
            title="Sell Items",
            header_icon="üí∞",
            min_width=450,
            max_width=550,
        )
        self.resize(500, 450)

    def _build_content(self, layout: QtWidgets.QVBoxLayout) -> None:
        # Tier selection buttons
        tier_group = QtWidgets.QGroupBox("Sell by Tier")
        tier_layout = QtWidgets.QVBoxLayout(tier_group)
        tier_layout.setSpacing(5)

        rarities = [
            ("Common", "#808080"),
            ("Uncommon", "#4caf50"),
            ("Rare", "#2196f3"),
            ("Epic", "#9c27b0"),
            ("Legendary", "#ff9800")
        ]

        for rarity, color in rarities:
            btn = QtWidgets.QPushButton(f"Sell All {rarity} Items")
            btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: {color};
                    color: white;
                    font-weight: bold;
                    padding: 8px;
                    border-radius: 4px;
                }}
                QPushButton:hover {{
                    background-color: {self._darken_color(color)};
                }}
            """)
            btn.clicked.connect(lambda checked=False, r=rarity: self._sell_by_tier(r))
            tier_layout.addWidget(btn)

        layout.addWidget(tier_group)

        # Selection mode button
        select_btn = QtWidgets.QPushButton("üìã Select Specific Items to Sell")
        select_btn.setStyleSheet("""
            QPushButton {
                background-color: #607d8b;
                color: white;
                font-weight: bold;
                padding: 10px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #455a64;
            }
        """)
        select_btn.clicked.connect(self._sell_by_selection)
        layout.addWidget(select_btn)

        # ü™ë Entity Perk Card (Office Chair sell bonus)
        self._add_sell_perk_display(layout)

        # Info label
        info_label = QtWidgets.QLabel("üí° Earn 1 coin per item + all % from lucky options")
        info_label.setStyleSheet("color: #666; font-style: italic; font-size: 10px;")
        info_label.setAlignment(QtCore.Qt.AlignCenter)
        layout.addWidget(info_label)

        # Close button
        close_btn = QtWidgets.QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        layout.addWidget(close_btn)

    def _darken_color(self, hex_color: str) -> str:
        """Darken a hex color by 20% for hover effects."""
        try:
            hex_color = hex_color.lstrip('#')
            if len(hex_color) < 6:
                return "#666666"  # Fallback for invalid color
            r, g, b = int(hex_color[0:2], 16), int(hex_color[2:4], 16), int(hex_color[4:6], 16)
            r, g, b = max(0, int(r * 0.8)), max(0, int(g * 0.8)), max(0, int(b * 0.8))
            return f"#{r:02x}{g:02x}{b:02x}"
        except (ValueError, IndexError):
            return "#666666"  # Fallback for invalid color

    def _add_sell_perk_display(self, layout: QtWidgets.QVBoxLayout) -> None:
        """Add entity perk display card for sell bonuses (Office Chair) - matches ADHD Buster patron style."""
        try:
            from gamification import get_entity_sell_perks
            sell_perks = get_entity_sell_perks(self.blocker.adhd_buster)
            
            if not sell_perks.get("has_perk"):
                return  # No perk to display
            
            is_exceptional = sell_perks.get("is_exceptional", False)
            
            # Create perk card frame - dark gradient style matching ADHD Buster patron cards
            perk_card = QtWidgets.QFrame()
            if is_exceptional:
                # Purple exceptional variant
                perk_card.setStyleSheet("""
                    QFrame {
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 #3d2e4a, stop:1 #251a2f);
                        border: 2px solid #9c27b0;
                        border-radius: 8px;
                        padding: 6px;
                    }
                """)
                text_color = "#ce93d8"
            else:
                # Orange normal variant
                perk_card.setStyleSheet("""
                    QFrame {
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 #4a3d2e, stop:1 #2f251a);
                        border: 2px solid #ff9800;
                        border-radius: 8px;
                        padding: 6px;
                    }
                """)
                text_color = "#ffcc80"
            
            card_layout = QtWidgets.QHBoxLayout(perk_card)
            card_layout.setContentsMargins(8, 4, 8, 4)
            card_layout.setSpacing(10)
            
            # SVG Icon
            svg_label = QtWidgets.QLabel()
            svg_label.setFixedSize(40, 40)
            svg_label.setStyleSheet("background: transparent;")
            icon_path = sell_perks.get("icon_path", "")
            if icon_path and os.path.exists(icon_path):
                try:
                    from PySide6.QtSvg import QSvgRenderer
                    from PySide6.QtGui import QPixmap, QPainter
                    renderer = QSvgRenderer(icon_path)
                    if renderer.isValid():
                        pixmap = QPixmap(40, 40)
                        pixmap.fill(QtCore.Qt.transparent)
                        painter = QPainter(pixmap)
                        renderer.render(painter)
                        painter.end()
                        svg_label.setPixmap(pixmap)
                except Exception:
                    svg_label.setText("ü™ë")
                    svg_label.setStyleSheet("font-size: 24px; background: transparent;")
            else:
                svg_label.setText("ü™ë")
                svg_label.setStyleSheet("font-size: 24px; background: transparent;")
            card_layout.addWidget(svg_label)
            
            # Perk description
            desc_label = QtWidgets.QLabel(sell_perks.get("description", ""))
            desc_label.setStyleSheet(f"""
                font-size: 12px;
                font-weight: bold;
                color: {text_color};
                background: transparent;
            """)
            desc_label.setWordWrap(True)
            card_layout.addWidget(desc_label, 1)
            
            layout.addWidget(perk_card)
            
        except Exception as e:
            print(f"[SellItemsDialog] Error adding perk display: {e}")

    def _calculate_coin_value(self, item: dict, sell_perks: dict = None) -> int:
        """Calculate coin value: 1 base + sum of all % bonuses in lucky options + entity bonuses.
        
        Args:
            item: The item dict to calculate value for
            sell_perks: Pre-fetched sell perks dict (optional, for efficiency)
        """
        coins = 1
        # Add all % values from lucky options
        lucky_options = item.get("lucky_options", {})
        coins += lucky_options.get("coin_discount", 0)
        coins += lucky_options.get("xp_bonus", 0)
        coins += lucky_options.get("merge_luck", 0)
        
        # ‚ú® ENTITY PERK BONUS: Add salvage bonus from collected entities
        try:
            from gamification import get_entity_coin_perks
            coin_perks = get_entity_coin_perks(self.blocker.adhd_buster, source="salvage")
            salvage_bonus = coin_perks.get("salvage_bonus", 0)
            coins += salvage_bonus
        except Exception:
            pass  # Silently ignore if perks unavailable
        
        # ü™ë OFFICE CHAIR PERK: Apply rarity multiplier for Epic/Legendary items
        try:
            # Use pre-fetched perks if available (more efficient)
            if sell_perks is None:
                from gamification import get_entity_sell_perks
                sell_perks = get_entity_sell_perks(self.blocker.adhd_buster)
            
            if sell_perks.get("has_perk"):
                item_rarity = item.get("rarity", "Common")
                if item_rarity == "Epic" and sell_perks.get("epic_bonus", 1.0) > 1.0:
                    # Apply 25% bonus - minimum +1 coin for qualifying items
                    bonus_coins = max(1, int(coins * (sell_perks.get("epic_bonus", 1.0) - 1.0) + 0.5))
                    coins += bonus_coins
                elif item_rarity == "Legendary" and sell_perks.get("legendary_bonus", 1.0) > 1.0:
                    # Apply 25% bonus - minimum +1 coin for qualifying items
                    bonus_coins = max(1, int(coins * (sell_perks.get("legendary_bonus", 1.0) - 1.0) + 0.5))
                    coins += bonus_coins
        except Exception:
            pass  # Silently ignore if perks unavailable
        
        return coins

    def _sell_by_tier(self, rarity: str) -> None:
        """Sell all items of a specific rarity."""
        inventory = self.blocker.adhd_buster.get("inventory", [])
        equipped = self.blocker.adhd_buster.get("equipped", {})
        
        if not inventory:
            show_info(self, "Sell Items", "No items to sell!")
            return

        # Get equipped item identifiers (item_id preferred, fallback to timestamp+slot tuple)
        equipped_ids = set()
        for eq in equipped.values():
            if eq:
                if eq.get("item_id"):
                    equipped_ids.add(("id", eq.get("item_id")))
                else:
                    equipped_ids.add(("ts_slot", eq.get("obtained_at"), eq.get("slot")))

        # Find items of this rarity that are not equipped
        def is_equipped(item):
            if item.get("item_id"):
                return ("id", item.get("item_id")) in equipped_ids
            return ("ts_slot", item.get("obtained_at"), item.get("slot")) in equipped_ids
        
        to_sell = [
            item for item in inventory
            if item.get("rarity") == rarity and not is_equipped(item)
        ]

        if not to_sell:
            show_info(self, "Sell Items", f"No {rarity} items to sell!")
            return

        # Cache sell perks for efficiency
        try:
            from gamification import get_entity_sell_perks
            sell_perks = get_entity_sell_perks(self.blocker.adhd_buster)
        except Exception:
            sell_perks = None

        # Calculate total coins
        total_coins = sum(self._calculate_coin_value(item, sell_perks) for item in to_sell)

        # Confirm
        if show_question(
            self, f"Sell {rarity} Items",
            f"Sell {len(to_sell)} {rarity} items for {total_coins} coins?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return

        # Sell items
        self.game_state.bulk_remove_items(to_sell)
        new_coins = self.game_state.add_coins(total_coins)
        
        # Sync to hero data
        if GAMIFICATION_AVAILABLE:
            sync_hero_data(self.blocker.adhd_buster)

        show_info(self, "Sold!", f"‚ú® Sold {len(to_sell)} items!\nüí∞ Coins earned: +{total_coins} (Total: {new_coins})")
        
        # Refresh parent UI
        if self.parent():
            self.parent().refresh_all()

    def _sell_by_selection(self) -> None:
        """Open a selection dialog to choose specific items to sell."""
        inventory = self.blocker.adhd_buster.get("inventory", [])
        equipped = self.blocker.adhd_buster.get("equipped", {})
        
        if not inventory:
            show_info(self, "Sell Items", "No items to sell!")
            return

        # Get equipped item identifiers (item_id preferred, fallback to timestamp+slot tuple)
        equipped_ids = set()
        for eq in equipped.values():
            if eq:
                if eq.get("item_id"):
                    equipped_ids.add(("id", eq.get("item_id")))
                else:
                    equipped_ids.add(("ts_slot", eq.get("obtained_at"), eq.get("slot")))

        # Filter out equipped items
        def is_equipped(item):
            if item.get("item_id"):
                return ("id", item.get("item_id")) in equipped_ids
            return ("ts_slot", item.get("obtained_at"), item.get("slot")) in equipped_ids
        
        sellable_items = [item for item in inventory if not is_equipped(item)]

        if not sellable_items:
            show_info(self, "Sell Items", "No sellable items (all are equipped)!")
            return

        # Create selection dialog
        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("Select Items to Sell")
        dialog.resize(600, 500)

        layout = QtWidgets.QVBoxLayout(dialog)

        # Instructions
        info = QtWidgets.QLabel("Select items to sell. Equipped items cannot be sold.")
        info.setStyleSheet("font-weight: bold; color: #333;")
        layout.addWidget(info)

        # Scroll area for items
        scroll = QtWidgets.QScrollArea()
        scroll.setWidgetResizable(True)
        scroll_widget = QtWidgets.QWidget()
        scroll_layout = QtWidgets.QVBoxLayout(scroll_widget)

        # Cache sell perks for efficiency
        try:
            from gamification import get_entity_sell_perks
            sell_perks = get_entity_sell_perks(self.blocker.adhd_buster)
        except Exception:
            sell_perks = None

        # Get story ID for themed slot names
        story_id = get_selected_story(self.blocker.adhd_buster) if get_selected_story else None
        
        checkboxes = []
        for item in sellable_items:
            cb = QtWidgets.QCheckBox()
            rarity_color = item.get("color", "#999")
            name = item.get("name", "Unknown")
            power = item.get("power", 10)
            slot = item.get("slot", "Unknown")
            display_slot = get_slot_display_name(slot, story_id) if get_slot_display_name and slot != "Unknown" else slot
            rarity = item.get("rarity", "Common")
            coin_value = self._calculate_coin_value(item, sell_perks)
            
            cb.setText(f"{name} [{rarity} {display_slot}] +{power} Power ‚Üí {coin_value} coins")
            cb.setStyleSheet(f"color: {rarity_color}; font-weight: bold;")
            cb.item_data = item
            checkboxes.append(cb)
            scroll_layout.addWidget(cb)

        scroll.setWidget(scroll_widget)
        layout.addWidget(scroll)

        # Coin preview with breakdown tooltip
        coin_preview = QtWidgets.QLabel("Selected: 0 items ‚Üí 0 coins")
        coin_preview.setStyleSheet("font-weight: bold; color: #ff9800; font-size: 12px;")
        layout.addWidget(coin_preview)
        
        # Get current coin balance for running total
        current_coins = self.blocker.adhd_buster.get("coins", 0)

        def update_preview():
            selected = [cb for cb in checkboxes if cb.isChecked()]
            total_coins = sum(self._calculate_coin_value(cb.item_data, sell_perks) for cb in selected)
            coin_preview.setText(f"Selected: {len(selected)} items ‚Üí +{total_coins} ü™ô")
            
            # Build breakdown tooltip
            if selected:
                # Group by rarity for summary
                rarity_counts = {}
                for cb in selected:
                    rarity = cb.item_data.get("rarity", "Common")
                    rarity_counts[rarity] = rarity_counts.get(rarity, 0) + 1
                
                breakdown = ["üí∞ Sell Breakdown:", "‚îÄ" * 20]
                for rarity in ["Legendary", "Epic", "Rare", "Uncommon", "Common"]:
                    if rarity in rarity_counts:
                        breakdown.append(f"{rarity}: {rarity_counts[rarity]} items")
                breakdown.append("‚îÄ" * 20)
                breakdown.append(f"Total: +{total_coins} coins")
                breakdown.append(f"After sale: {current_coins + total_coins} ü™ô")
                
                coin_preview.setToolTip("\n".join(breakdown))
            else:
                coin_preview.setToolTip("Select items to see breakdown")

        for cb in checkboxes:
            cb.stateChanged.connect(update_preview)

        # Buttons
        btn_layout = QtWidgets.QHBoxLayout()
        
        select_all_btn = QtWidgets.QPushButton("Select All")
        select_all_btn.clicked.connect(lambda: [cb.setChecked(True) for cb in checkboxes])
        btn_layout.addWidget(select_all_btn)

        deselect_all_btn = QtWidgets.QPushButton("Deselect All")
        deselect_all_btn.clicked.connect(lambda: [cb.setChecked(False) for cb in checkboxes])
        btn_layout.addWidget(deselect_all_btn)

        btn_layout.addStretch()

        sell_btn = QtWidgets.QPushButton("Sell Selected")
        sell_btn.setStyleSheet("background-color: #4caf50; color: white; font-weight: bold; padding: 8px;")
        sell_btn.clicked.connect(lambda: self._confirm_sell_selected([cb.item_data for cb in checkboxes if cb.isChecked()], dialog))
        btn_layout.addWidget(sell_btn)

        cancel_btn = QtWidgets.QPushButton("Cancel")
        cancel_btn.clicked.connect(dialog.reject)
        btn_layout.addWidget(cancel_btn)

        layout.addLayout(btn_layout)

        dialog.exec()

    def _confirm_sell_selected(self, items: list, dialog: QtWidgets.QDialog) -> None:
        """Confirm and sell selected items."""
        if not items:
            show_info(self, "Sell Items", "No items selected!")
            return

        # Cache sell perks for efficiency
        try:
            from gamification import get_entity_sell_perks
            sell_perks = get_entity_sell_perks(self.blocker.adhd_buster)
        except Exception:
            sell_perks = None

        total_coins = sum(self._calculate_coin_value(item, sell_perks) for item in items)

        if show_question(
            self, "Sell Items",
            f"Sell {len(items)} selected items for {total_coins} coins?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        ) != QtWidgets.QMessageBox.Yes:
            return

        # Sell items
        self.game_state.bulk_remove_items(items)
        new_coins = self.game_state.add_coins(total_coins)
        
        # Sync to hero data
        if GAMIFICATION_AVAILABLE:
            sync_hero_data(self.blocker.adhd_buster)

        show_info(self, "Sold!", f"‚ú® Sold {len(items)} items!\nüí∞ Coins earned: +{total_coins} (Total: {new_coins})")
        
        # Close selection dialog
        dialog.accept()
        
        # Refresh parent UI
        if self.parent():
            self.parent().refresh_all()


class DiaryDialog(StyledDialog):
    """Dialog for viewing the ADHD Buster's adventure diary."""

    def __init__(self, blocker: BlockerCore, parent: Optional[QtWidgets.QWidget] = None) -> None:
        self.blocker = blocker
        self._auto_generated_today = False
        self._auto_generate_todays_entry()
        
        super().__init__(
            parent=parent,
            title="Adventure Diary",
            header_icon="üìñ",
            min_width=600,
            max_width=750,
        )
        self.resize(650, 600)

    def _auto_generate_todays_entry(self) -> None:
        """Auto-generate today's diary entry if one doesn't exist yet."""
        if not GAMIFICATION_AVAILABLE:
            return
        today = datetime.now().strftime("%Y-%m-%d")
        diary = self.blocker.adhd_buster.get("diary", [])
        today_entries = [e for e in diary if e.get("date") == today]
        if today_entries:
            return  # Already have an entry for today
        
        # Generate today's entry
        power = calculate_character_power(self.blocker.adhd_buster)
        equipped = self.blocker.adhd_buster.get("equipped", {})
        active_story = self.blocker.adhd_buster.get("active_story", "warrior")
        entry = generate_diary_entry(power, session_minutes=0, equipped_items=equipped,
                                     story_id=active_story)
        entry["story"] = "[Auto] " + entry["story"]
        entry["is_new"] = True  # Mark as new for display
        
        if "diary" not in self.blocker.adhd_buster:
            self.blocker.adhd_buster["diary"] = []
        self.blocker.adhd_buster["diary"].append(entry)
        if len(self.blocker.adhd_buster["diary"]) > 100:
            self.blocker.adhd_buster["diary"] = self.blocker.adhd_buster["diary"][-100:]
        
        # Sync changes to active hero before saving
        sync_hero_data(self.blocker.adhd_buster)
        self.blocker.save_config()
        self._auto_generated_today = True

    def _build_content(self, layout: QtWidgets.QVBoxLayout) -> None:
        power = calculate_character_power(self.blocker.adhd_buster) if GAMIFICATION_AVAILABLE else 0
        tier = get_diary_power_tier(power) if GAMIFICATION_AVAILABLE else "pathetic"

        header = QtWidgets.QHBoxLayout()
        title_lbl = QtWidgets.QLabel("The Adventures of ADHD Buster")
        title_lbl.setStyleSheet("font-size: 14px; font-weight: bold; color: #E0E0E0;")
        header.addWidget(title_lbl)
        header.addStretch()
        tier_lbl = QtWidgets.QLabel(f"‚öî Power: {power} ({tier.capitalize()} Tier)")
        tier_lbl.setStyleSheet("font-weight: bold; color: #FFD700;")
        header.addWidget(tier_lbl)
        layout.addLayout(header)

        entries = self.blocker.adhd_buster.get("diary", [])
        if entries:
            stats_lbl = QtWidgets.QLabel(f"üìö {len(entries)} adventures | üóìÔ∏è Latest: {entries[-1].get('short_date', 'Unknown')}")
            stats_lbl.setStyleSheet("color: #888888;")
            layout.addWidget(stats_lbl)

        self.diary_text = QtWidgets.QTextEdit()
        self.diary_text.setReadOnly(True)
        self.diary_text.setMinimumHeight(350)
        new_entries_cleared = False
        if entries:
            for entry in reversed(entries):
                date = entry.get("short_date", entry.get("date", "Unknown"))
                story = entry.get("story", "...")
                pwr = entry.get("power_at_time", 0)
                mins = entry.get("session_minutes", 0)
                tr = entry.get("tier", "pathetic")
                # Show NEW badge for new entries
                new_badge = ""
                if entry.get("is_new"):
                    new_badge = "<span style='background-color:#4CAF50;color:white;padding:2px 6px;border-radius:3px;font-size:11px;margin-left:8px;'>‚ú® NEW</span>"
                    entry["is_new"] = False  # Clear the new flag after display
                    new_entries_cleared = True
                self.diary_text.append(f"<b style='color:#FFD700;'>{date}</b>{new_badge}<br><span style='color:#E0E0E0;'>{story}</span><br>"
                                       f"<span style='color:#888;'>Power: {pwr} | Focus: {mins} min | Tier: {tr.capitalize()}</span><br><hr>")
        else:
            self.diary_text.setPlainText("üì≠ No adventures recorded yet!\n\nComplete focus sessions to record your epic adventures.")
        layout.addWidget(self.diary_text)
        
        # Save if we cleared new flags
        if new_entries_cleared:
            if GAMIFICATION_AVAILABLE:
                sync_hero_data(self.blocker.adhd_buster)
            self.blocker.save_config()

        btn_layout = QtWidgets.QHBoxLayout()
        if entries:
            clear_btn = QtWidgets.QPushButton("üóëÔ∏è Clear All")
            clear_btn.setObjectName("dangerButton")
            clear_btn.clicked.connect(self._clear_diary)
            btn_layout.addWidget(clear_btn)
        write_btn = QtWidgets.QPushButton("‚úçÔ∏è Write Entry")
        write_btn.clicked.connect(self._write_entry)
        btn_layout.addWidget(write_btn)
        btn_layout.addStretch()
        close_btn = QtWidgets.QPushButton("Close")
        close_btn.setObjectName("primaryButton")
        close_btn.clicked.connect(self.accept)
        btn_layout.addWidget(close_btn)
        layout.addLayout(btn_layout)

    def _clear_diary(self) -> None:
        result = styled_question(self, "Clear Diary", "Clear all diary entries?", ["Cancel", "Clear All"])
        if result == "Clear All":
            self.blocker.adhd_buster["diary"] = []
            # Sync changes to active hero before saving
            if GAMIFICATION_AVAILABLE:
                sync_hero_data(self.blocker.adhd_buster)
            self.blocker.save_config()
            self.accept()

    def _write_entry(self) -> None:
        if not GAMIFICATION_AVAILABLE:
            show_warning(self, "Diary", "Gamification not available")
            return
        today = datetime.now().strftime("%Y-%m-%d")
        diary = self.blocker.adhd_buster.get("diary", [])
        bonus_today = [e for e in diary if e.get("date") == today and e.get("story", "").startswith("[Bonus Entry]")]
        if bonus_today:
            show_info(self, "Diary", "You already wrote a bonus entry today!")
            return
        power = calculate_character_power(self.blocker.adhd_buster)
        equipped = self.blocker.adhd_buster.get("equipped", {})
        active_story = self.blocker.adhd_buster.get("active_story", "warrior")
        entry = generate_diary_entry(power, session_minutes=0, equipped_items=equipped,
                                     story_id=active_story)
        entry["story"] = "[Bonus Entry] " + entry["story"]
        if "diary" not in self.blocker.adhd_buster:
            self.blocker.adhd_buster["diary"] = []
        self.blocker.adhd_buster["diary"].append(entry)
        if len(self.blocker.adhd_buster["diary"]) > 100:
            self.blocker.adhd_buster["diary"] = self.blocker.adhd_buster["diary"][-100:]
        # Sync changes to active hero before saving
        if GAMIFICATION_AVAILABLE:
            sync_hero_data(self.blocker.adhd_buster)
        self.blocker.save_config()
        self.accept()


# Legacy LevelUpCelebrationDialog removed to prevent confusion with EnhancedLevelUpDialog
        self.level_lbl.setStyleSheet(
            "font-size: 48px; font-weight: bold; color: white; "
            "text-shadow: 3px 3px 6px rgba(0,0,0,0.4);"
        )
        layout.addWidget(self.level_lbl)
        
        # Title display
        if self.new_title:
            title_prefix = "NEW TITLE: " if self.title_changed else ""
            self.title_lbl = QtWidgets.QLabel(f"{title_prefix}{self.new_title}")
            self.title_lbl.setAlignment(QtCore.Qt.AlignCenter)
            style = "font-size: 20px; font-weight: bold; color: #fff8e1;"
            if self.title_changed:
                style += " text-shadow: 0 0 10px #ffd700, 0 0 20px #ffd700;"
            self.title_lbl.setStyleSheet(style)
            layout.addWidget(self.title_lbl)
        
        # XP earned info
        if self.xp_earned > 0:
            xp_lbl = QtWidgets.QLabel(f"+{self.xp_earned:,} XP")
            xp_lbl.setAlignment(QtCore.Qt.AlignCenter)
            xp_lbl.setStyleSheet("font-size: 18px; color: #e1f5fe;")
            layout.addWidget(xp_lbl)
        
        # Progress to next level
        progress = self.level_info.get("progress", 0)
        xp_in = self.level_info.get("xp_in_level", 0)
        xp_needed = self.level_info.get("xp_needed", 100)
        
        progress_frame = QtWidgets.QFrame()
        progress_frame.setStyleSheet("background: rgba(255,255,255,0.2); border-radius: 10px;")
        progress_layout = QtWidgets.QVBoxLayout(progress_frame)
        progress_layout.setContentsMargins(15, 10, 15, 10)
        
        next_lbl = QtWidgets.QLabel(f"Progress to Level {self.new_level + 1}")
        next_lbl.setStyleSheet("color: white; font-size: 12px;")
        next_lbl.setAlignment(QtCore.Qt.AlignCenter)
        progress_layout.addWidget(next_lbl)
        
        progress_bar = QtWidgets.QProgressBar()
        progress_bar.setMaximum(100)
        progress_bar.setValue(int(progress))
        progress_bar.setTextVisible(False)
        progress_bar.setFixedHeight(20)
        progress_bar.setStyleSheet(
            f"QProgressBar {{ background: rgba(0,0,0,0.3); border-radius: 10px; }}"
            f"QProgressBar::chunk {{ background: {accent}; border-radius: 10px; }}"
        )
        progress_layout.addWidget(progress_bar)
        
        xp_text = QtWidgets.QLabel(f"{xp_in:,} / {xp_needed:,} XP")
        xp_text.setStyleSheet("color: white; font-size: 11px;")
        xp_text.setAlignment(QtCore.Qt.AlignCenter)
        progress_layout.addWidget(xp_text)
        
        layout.addWidget(progress_frame)
        
        # Motivational message
        messages = [
            "Your focus powers grow stronger! üí™",
            "The path to mastery continues! üåü",
            "You're becoming unstoppable! üöÄ",
            "Champions are made through dedication! üèÜ",
            "Every level brings new strength! ‚ö°",
        ]
        if self.new_level >= 50:
            messages = ["LEGENDARY STATUS! You're a focus god! üëë", "The legends speak of your discipline! ‚ö°"]
        elif self.new_level >= 30:
            messages = ["Master level focus achieved! üîÆ", "Your willpower is legendary! ‚ú®"]
        
        msg_lbl = QtWidgets.QLabel(random.choice(messages))
        msg_lbl.setAlignment(QtCore.Qt.AlignCenter)
        msg_lbl.setStyleSheet("font-size: 14px; color: white; font-style: italic;")
        layout.addWidget(msg_lbl)
        
        # Click to dismiss
        dismiss_lbl = QtWidgets.QLabel("(Click anywhere to continue)")
        dismiss_lbl.setAlignment(QtCore.Qt.AlignCenter)
        dismiss_lbl.setStyleSheet("color: rgba(255,255,255,0.7); font-size: 10px;")
        layout.addWidget(dismiss_lbl)

    def _start_celebration(self) -> None:
        """Start the celebration animation."""
        # Pulse animation for header
        self._animation_timer = QtCore.QTimer(self)
        self._animation_timer.timeout.connect(self._animate_step)
        self._animation_timer.start(150)
        
        # Play victory sound using lottery sound system
        try:
            from lottery_sounds import play_win_sound
            play_win_sound()
        except Exception:
            pass

    def _animate_step(self) -> None:
        """Animate the celebration."""
        self._animation_step += 1
        
        # Pulse the header with different emojis
        emojis = ["üéâ", "‚≠ê", "üåü", "‚ú®", "üéä", "üí´"]
        emoji = emojis[self._animation_step % len(emojis)]
        
        if self.levels_gained > 1:
            self.header_lbl.setText(f"{emoji} MULTI LEVEL UP! {emoji}")
        else:
            self.header_lbl.setText(f"{emoji} LEVEL UP! {emoji}")
        
        # Stop after a while
        if self._animation_step >= 40:
            self._animation_timer.stop()

    def mousePressEvent(self, event) -> None:
        if hasattr(self, '_animation_timer'):
            self._animation_timer.stop()
        self.accept()

    def closeEvent(self, event) -> None:
        if hasattr(self, '_animation_timer'):
            self._animation_timer.stop()
        super().closeEvent(event)


# NOTE: The old ItemDropDialog class with light backgrounds (Common: #f5f5f5, Uncommon: #e8f5e9)
# has been removed. Use ItemRewardDialog from styled_dialog.py or EnhancedItemDropDialog 
# from item_drop_dialog.py instead. These use the consistent dark theme.


class DiaryEntryRevealDialog(StyledDialog):
    """Dramatic reveal dialog for the daily diary entry."""

    def __init__(self, blocker: BlockerCore, entry: dict, session_minutes: int = 0,
                 parent: Optional[QtWidgets.QWidget] = None) -> None:
        self.blocker = blocker
        self.entry = entry
        self.session_minutes = session_minutes
        self.tier = entry.get("tier", "pathetic")
        
        # Get tier-specific emoji for header
        tier_emojis = {
            "pathetic": "üå±", "modest": "üõ°Ô∏è", "decent": "üí™",
            "heroic": "üî•", "epic": "‚ö°", "legendary": "‚≠ê", "godlike": "üåü"
        }
        emoji = tier_emojis.get(self.tier, "üìñ")
        
        super().__init__(parent, "Today's Adventure", emoji, 480, 520, closable=True)

    def _build_content(self, layout: QtWidgets.QVBoxLayout) -> None:
        tier = self.tier
        tier_styles = {
            "pathetic": {"accent": "#9e9e9e", "emoji": "üå±"},
            "modest": {"accent": "#8bc34a", "emoji": "üõ°Ô∏è"},
            "decent": {"accent": "#4caf50", "emoji": "üí™"},
            "heroic": {"accent": "#2196f3", "emoji": "üî•"},
            "epic": {"accent": "#9c27b0", "emoji": "‚ö°"},
            "legendary": {"accent": "#ff9800", "emoji": "‚≠ê"},
            "godlike": {"accent": "#ffc107", "emoji": "üåü"}
        }
        style = tier_styles.get(tier, tier_styles["pathetic"])

        tier_boosted = self.entry.get("tier_boosted", False)
        if tier_boosted:
            header_text = f"{style['emoji']} Lucky Adventure! {style['emoji']}"
            subheader = f"Your {self.session_minutes}+ min focus earned a bonus tier!"
        else:
            header_text = f"{style['emoji']} Today's Adventure {style['emoji']}"
            subheader = self.entry.get("short_date", "")
            
        header_lbl = QtWidgets.QLabel(header_text)
        header_lbl.setStyleSheet(f"font-size: 18px; font-weight: bold; color: {style['accent']};")
        header_lbl.setAlignment(QtCore.Qt.AlignCenter)
        layout.addWidget(header_lbl)
        
        sub_lbl = QtWidgets.QLabel(subheader)
        sub_lbl.setStyleSheet("color: #999;")
        sub_lbl.setAlignment(QtCore.Qt.AlignCenter)
        layout.addWidget(sub_lbl)

        # Separator line
        line = QtWidgets.QFrame()
        line.setFrameShape(QtWidgets.QFrame.HLine)
        line.setStyleSheet(f"background-color: {style['accent']}; max-height: 2px;")
        layout.addWidget(line)
        layout.addSpacing(10)

        # Story content in a styled container
        story = self.entry.get("story", "A mysterious adventure occurred...")
        story_container = QtWidgets.QWidget()
        story_container.setStyleSheet("background-color: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px;")
        story_layout = QtWidgets.QVBoxLayout(story_container)
        story_lbl = QtWidgets.QLabel(story)
        story_lbl.setWordWrap(True)
        story_lbl.setStyleSheet("font-size: 13px; color: #E0E0E0; line-height: 1.5;")
        story_layout.addWidget(story_lbl)
        layout.addWidget(story_container)
        layout.addSpacing(10)

        # Separator line
        line2 = QtWidgets.QFrame()
        line2.setFrameShape(QtWidgets.QFrame.HLine)
        line2.setStyleSheet(f"background-color: {style['accent']}; max-height: 2px;")
        layout.addWidget(line2)
        layout.addSpacing(10)

        # Power and tier info
        power = self.entry.get("power_at_time", 0)
        tier_display = tier.capitalize()
        if tier_boosted:
            base_tier = self.entry.get("base_tier", tier)
            power_text = f"‚öî Power: {power}  |  üé≠ {base_tier.capitalize()} ‚Üí {tier_display} (bonus!)"
        else:
            power_text = f"‚öî Power: {power}  |  üé≠ {tier_display} Tier"
        pwr_lbl = QtWidgets.QLabel(power_text)
        pwr_lbl.setStyleSheet(f"font-weight: bold; color: {style['accent']}; font-size: 14px;")
        pwr_lbl.setAlignment(QtCore.Qt.AlignCenter)
        layout.addWidget(pwr_lbl)
        
        mins_lbl = QtWidgets.QLabel(f"‚è±Ô∏è {self.session_minutes} min focus session")
        mins_lbl.setStyleSheet("color: #999;")
        mins_lbl.setAlignment(QtCore.Qt.AlignCenter)
        layout.addWidget(mins_lbl)
        
        layout.addSpacing(10)
        self.add_button_row(layout, [("Continue", "primary", self.accept)])

    def mousePressEvent(self, event) -> None:
        # Allow clicking anywhere to dismiss
        self.accept()


# ============================================================================
# Priority Management Dialogs (Qt Implementation)
# ============================================================================

class PriorityTimeLogDialog(StyledDialog):
    """Dialog for logging time to priorities after a focus session."""

    def __init__(self, blocker: BlockerCore, session_minutes: int,
                 parent: Optional[QtWidgets.QWidget] = None) -> None:
        self.blocker = blocker
        self.session_minutes = session_minutes
        self.time_spins: list = []
        self.priority_indices: list = []
        super().__init__(parent, "Log Priority Time", "üìä", 450, 500, closable=True)

    def _build_content(self, layout: QtWidgets.QVBoxLayout) -> None:
        header = QtWidgets.QLabel(f"<b>You completed a {self.session_minutes} minute focus session.</b>")
        header.setStyleSheet("color: #E0E0E0; font-size: 13px;")
        layout.addWidget(header)
        layout.addSpacing(10)

        today = datetime.now().strftime("%A")
        
        # Priorities container
        priorities_container = QtWidgets.QWidget()
        priorities_container.setStyleSheet("background-color: rgba(0,0,0,0.2); border-radius: 8px;")
        p_layout = QtWidgets.QVBoxLayout(priorities_container)
        p_layout.setContentsMargins(15, 10, 15, 10)
        
        header_lbl = QtWidgets.QLabel("Today's Priorities")
        header_lbl.setStyleSheet("font-weight: bold; color: #FFD700; font-size: 14px;")
        p_layout.addWidget(header_lbl)

        has_priorities = False
        for i, priority in enumerate(self.blocker.priorities):
            title = priority.get("title", "").strip()
            days = priority.get("days", [])
            if title and (not days or today in days):
                has_priorities = True
                row = QtWidgets.QHBoxLayout()
                lbl = QtWidgets.QLabel(f"#{i+1}: {title}")
                lbl.setStyleSheet("color: #E0E0E0;")
                row.addWidget(lbl, 1)
                spin = NoScrollSpinBox()
                spin.setRange(0, self.session_minutes)
                spin.setValue(0)
                spin.setSuffix(" min")
                spin.setMinimumWidth(100)
                row.addWidget(spin)
                p_layout.addLayout(row)
                self.time_spins.append(spin)
                self.priority_indices.append(i)

        if not has_priorities:
            no_pri_lbl = QtWidgets.QLabel("No active priorities for today.")
            no_pri_lbl.setStyleSheet("color: #888; font-style: italic;")
            p_layout.addWidget(no_pri_lbl)
        layout.addWidget(priorities_container)
        layout.addSpacing(10)

        if has_priorities:
            # Quick options
            quick_container = QtWidgets.QWidget()
            quick_container.setStyleSheet("background-color: rgba(0,0,0,0.2); border-radius: 8px;")
            q_layout = QtWidgets.QVBoxLayout(quick_container)
            q_layout.setContentsMargins(15, 10, 15, 10)
            
            quick_lbl = QtWidgets.QLabel("Quick Options")
            quick_lbl.setStyleSheet("font-weight: bold; color: #FFD700; font-size: 12px;")
            q_layout.addWidget(quick_lbl)
            
            btn_row = QtWidgets.QHBoxLayout()
            all_first_btn = QtWidgets.QPushButton(f"All {self.session_minutes} min to first")
            all_first_btn.clicked.connect(self._log_all_to_first)
            btn_row.addWidget(all_first_btn)
            split_btn = QtWidgets.QPushButton("Split evenly")
            split_btn.clicked.connect(self._split_evenly)
            btn_row.addWidget(split_btn)
            q_layout.addLayout(btn_row)
            layout.addWidget(quick_container)

        layout.addStretch()
        self.add_button_row(layout, [
            ("üíæ Save & Close", "primary", self._save_and_close),
            ("Skip", "default", self.reject)
        ])

    def _log_all_to_first(self) -> None:
        if self.time_spins:
            self.time_spins[0].setValue(self.session_minutes)
            for spin in self.time_spins[1:]:
                spin.setValue(0)

    def _split_evenly(self) -> None:
        if self.time_spins and len(self.time_spins) > 0:
            per = self.session_minutes // len(self.time_spins)
            for spin in self.time_spins:
                spin.setValue(per)

    def _save_and_close(self) -> None:
        for spin, idx in zip(self.time_spins, self.priority_indices):
            minutes = spin.value()
            if minutes > 0:
                hours = minutes / 60.0
                cur = self.blocker.priorities[idx].get("logged_hours", 0)
                self.blocker.priorities[idx]["logged_hours"] = cur + hours
        self.blocker.save_config()
        self.accept()


class PriorityCheckinDialog(StyledDialog):
    """Dialog shown during a session to ask if user is working on priorities."""

    def __init__(self, blocker: BlockerCore, today_priorities: list, session_minutes: int = 0,
                 parent: Optional[QtWidgets.QWidget] = None) -> None:
        self.blocker = blocker
        self.today_priorities = today_priorities
        self.session_minutes = session_minutes
        self.result: Optional[bool] = None
        
        super().__init__(
            parent=parent,
            title="Priority Check-in",
            header_icon="‚è∞",
            min_width=400,
            max_width=500,
        )

    def _build_content(self, layout: QtWidgets.QVBoxLayout) -> None:
        q_lbl = QtWidgets.QLabel("Are you currently working on your priority tasks?")
        q_lbl.setStyleSheet("color: #E0E0E0; font-size: 13px;")
        layout.addWidget(q_lbl)

        if GAMIFICATION_AVAILABLE:
            streak = self.blocker.stats.get("streak_days", 0)
            bonuses = calculate_rarity_bonuses(self.session_minutes, streak)
            bonus_parts = []
            if bonuses["session_bonus"] > 0:
                bonus_parts.append(f"‚è±Ô∏è+{bonuses['session_bonus']}%")
            if bonuses["streak_bonus"] > 0:
                bonus_parts.append(f"üî•+{bonuses['streak_bonus']}%")
            if bonus_parts:
                bonus_lbl = QtWidgets.QLabel(f"‚ú® Loot bonuses: {' '.join(bonus_parts)}")
                bonus_lbl.setStyleSheet("color: #FFD700;")
                layout.addWidget(bonus_lbl)

        p_box = QtWidgets.QGroupBox("üìå Today's Priorities")
        p_layout = QtWidgets.QVBoxLayout(p_box)
        text = "\n".join([f"‚Ä¢ {p.get('title', '')}" for p in self.today_priorities])
        p_lbl = QtWidgets.QLabel(text if text.strip() else "No priorities set")
        p_lbl.setStyleSheet("color: #E0E0E0;")
        p_layout.addWidget(p_lbl)
        layout.addWidget(p_box)

        btn_layout = QtWidgets.QHBoxLayout()
        no_btn = QtWidgets.QPushButton("‚ö† Need to refocus")
        no_btn.clicked.connect(self._confirm_off_task)
        btn_layout.addWidget(no_btn)
        btn_layout.addStretch()
        yes_btn = QtWidgets.QPushButton("‚úÖ Yes, I'm on task!")
        yes_btn.setObjectName("primaryButton")
        yes_btn.clicked.connect(self._confirm_on_task)
        btn_layout.addWidget(yes_btn)
        layout.addLayout(btn_layout)

        dismiss_btn = QtWidgets.QPushButton("Dismiss")
        dismiss_btn.setStyleSheet("color: #888888; background: transparent; border: none;")
        dismiss_btn.clicked.connect(self.reject)
        layout.addWidget(dismiss_btn, alignment=QtCore.Qt.AlignCenter)

    def _confirm_on_task(self) -> None:
        self.result = True
        self.accept()

    def _confirm_off_task(self) -> None:
        self.result = False
        styled_info(self, "Time to refocus!", "Take a breath and get back to your priorities.\nYou've got this! üí™")
        self.accept()


class PrioritySessionStartDialog(StyledDialog):
    """Dialog to ask user which priority to work on when starting a session."""

    def __init__(self, blocker: BlockerCore, parent: Optional[QtWidgets.QWidget] = None) -> None:
        self.blocker = blocker
        self.selected_priority: Optional[str] = None
        self.is_strategic: bool = False
        
        super().__init__(
            parent=parent,
            title="Focus on a Priority?",
            header_icon="üéØ",
            min_width=450,
            max_width=550,
        )
        self.resize(500, 400)

    def _build_content(self, layout: QtWidgets.QVBoxLayout) -> None:
        # Get today's priorities
        today = datetime.now().strftime("%A")
        today_priorities = []
        for p in self.blocker.priorities:
            title = p.get("title", "").strip()
            days = p.get("days", [])
            if title and (not days or today in days):
                today_priorities.append({
                    "title": title,
                    "strategic": p.get("strategic", False),
                    "logged_hours": p.get("logged_hours", 0)
                })
        
        if today_priorities:
            desc = QtWidgets.QLabel("Select a priority to work on during this session:")
            desc.setStyleSheet("color: #E0E0E0; font-size: 13px;")
            desc.setWordWrap(True)
            layout.addWidget(desc)
            
            # Scroll area for priorities
            scroll = QtWidgets.QScrollArea()
            scroll.setWidgetResizable(True)
            scroll.setMaximumHeight(220)
            scroll.setStyleSheet("""
                QScrollArea { background: transparent; border: none; }
                QScrollArea > QWidget > QWidget { background: transparent; }
            """)
            
            container = QtWidgets.QWidget()
            container_layout = QtWidgets.QVBoxLayout(container)
            container_layout.setSpacing(8)
            container_layout.setContentsMargins(0, 0, 10, 0)
            
            self.priority_buttons = []
            for i, p in enumerate(today_priorities):
                btn = QtWidgets.QPushButton()
                strategic_badge = " üí∞" if p["strategic"] else ""
                hours_info = f" ({p['logged_hours']:.1f}h logged)" if p["logged_hours"] > 0 else ""
                btn.setText(f"üéØ {p['title']}{strategic_badge}{hours_info}")
                btn.setStyleSheet("""
                    QPushButton {
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 #2A2A4A, stop:1 #1A1A3A);
                        color: #FFD700;
                        border: 1px solid #444466;
                        border-radius: 8px;
                        padding: 12px 16px;
                        text-align: left;
                        font-size: 13px;
                    }
                    QPushButton:hover {
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 #3A3A5A, stop:1 #2A2A4A);
                        border-color: #FFD700;
                    }
                """)
                btn.clicked.connect(lambda checked, idx=i: self._select_priority(idx))
                container_layout.addWidget(btn)
                self.priority_buttons.append((btn, p))
            
            container_layout.addStretch()
            scroll.setWidget(container)
            layout.addWidget(scroll)
            
            # Strategic bonus info
            has_strategic = any(p["strategic"] for p in today_priorities)
            if has_strategic:
                strategic_info = QtWidgets.QLabel("üí∞ Strategic priorities earn 2.5x coins!")
                strategic_info.setStyleSheet("color: #FFD700; font-size: 11px;")
                strategic_info.setAlignment(QtCore.Qt.AlignCenter)
                layout.addWidget(strategic_info)
        else:
            no_priorities = QtWidgets.QLabel(
                "üìù No priorities set for today.\n\n"
                "You can still start a session, or go to\n"
                "My Priorities to add tasks for today."
            )
            no_priorities.setStyleSheet("color: #E0E0E0; font-size: 13px;")
            no_priorities.setAlignment(QtCore.Qt.AlignCenter)
            no_priorities.setWordWrap(True)
            layout.addWidget(no_priorities)
            layout.addStretch()
        
        # Divider
        line = QtWidgets.QFrame()
        line.setFrameShape(QtWidgets.QFrame.HLine)
        line.setStyleSheet("background: #333344;")
        layout.addWidget(line)
        
        # Buttons
        btn_layout = QtWidgets.QHBoxLayout()
        
        skip_btn = QtWidgets.QPushButton("Skip - Start Without Priority")
        skip_btn.setStyleSheet("""
            QPushButton {
                background: transparent;
                color: #888888;
                border: 1px solid #444444;
                border-radius: 8px;
                padding: 10px 16px;
            }
            QPushButton:hover {
                color: #AAAAAA;
                border-color: #666666;
            }
        """)
        skip_btn.clicked.connect(self._skip)
        btn_layout.addWidget(skip_btn)
        
        btn_layout.addStretch()
        
        cancel_btn = QtWidgets.QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(cancel_btn)
        
        layout.addLayout(btn_layout)
        
        # Don't ask again checkbox
        self.dont_ask_check = QtWidgets.QCheckBox("Don't ask me again (can re-enable in Priorities)")
        self.dont_ask_check.setStyleSheet("color: #888888; font-size: 11px;")
        layout.addWidget(self.dont_ask_check)

    def _select_priority(self, index: int) -> None:
        """Select a priority and close dialog."""
        btn, priority = self.priority_buttons[index]
        self.selected_priority = priority["title"]
        self.is_strategic = priority["strategic"]
        self._save_dont_ask()
        self.accept()

    def _skip(self) -> None:
        """Skip priority selection but proceed with session."""
        self.selected_priority = None
        self.is_strategic = False
        self._save_dont_ask()
        self.accept()

    def _save_dont_ask(self) -> None:
        """Save the don't ask again preference."""
        if self.dont_ask_check.isChecked():
            self.blocker.ask_priority_on_session_start = False
            self.blocker.save_config()


class PrioritiesDialog(StyledDialog):
    """Dialog for managing daily priorities with day-of-week reminders."""

    DAYS = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]

    def __init__(self, blocker: BlockerCore, on_start_callback=None,
                 parent: Optional[QtWidgets.QWidget] = None) -> None:
        self.blocker = blocker
        self.on_start_callback = on_start_callback
        self.priorities = copy.deepcopy(self.blocker.priorities) if self.blocker.priorities else []
        # Mark loaded priorities as existing (locked strategic status)
        for p in self.priorities:
            p["_existing"] = True

        if not self.priorities:
            self.priorities.append(self._empty_priority())
        self.title_edits: List[QtWidgets.QLineEdit] = []
        self.day_checks: List[List[tuple]] = []
        self.planned_spins: List[QtWidgets.QDoubleSpinBox] = []
        self.strategic_checks: List[QtWidgets.QCheckBox] = []
        self.priority_list_layout: Optional[QtWidgets.QVBoxLayout] = None
        self.add_priority_btn: Optional[QtWidgets.QPushButton] = None
        self.strategic_group: Optional[QtWidgets.QButtonGroup] = None
        
        super().__init__(
            parent=parent,
            title="My Priorities",
            header_icon="üéØ",
            min_width=550,
            max_width=700,
        )
        self.resize(600, 650)

    def _empty_priority(self) -> dict:
        """Return a placeholder priority record."""
        return {
            "title": "",
            "days": [],
            "active": False,
            "planned_hours": 0,
            "logged_hours": 0,
            "strategic": False,
        }

    def _build_content(self, layout: QtWidgets.QVBoxLayout) -> None:
        header = QtWidgets.QHBoxLayout()
        today = datetime.now().strftime("%A, %B %d")
        today_lbl = QtWidgets.QLabel(today)
        today_lbl.setStyleSheet("color: #888888;")
        header.addWidget(today_lbl)
        header.addStretch()
        layout.addLayout(header)

        desc_lbl = QtWidgets.QLabel("Set as many priority tasks as you need. These can span multiple days.")
        desc_lbl.setStyleSheet("color: #E0E0E0;")
        layout.addWidget(desc_lbl)

        self.scroll_area = QtWidgets.QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setMinimumHeight(200)
        self.priority_list_container = QtWidgets.QWidget()
        self.priority_list_layout = QtWidgets.QVBoxLayout(self.priority_list_container)
        self.priority_list_layout.setContentsMargins(0, 0, 0, 0)
        self.priority_list_layout.setSpacing(12)
        self.priority_list_layout.setAlignment(QtCore.Qt.AlignTop)
        self.scroll_area.setWidget(self.priority_list_container)
        layout.addWidget(self.scroll_area)

        self.add_priority_btn = QtWidgets.QPushButton("‚ûï Add Priority")
        self.add_priority_btn.clicked.connect(self._add_priority)
        layout.addWidget(self.add_priority_btn)

        # Today's Focus
        today_box = QtWidgets.QGroupBox("üìå Today's Focus")
        today_layout = QtWidgets.QVBoxLayout(today_box)
        self.today_lbl = QtWidgets.QLabel()
        today_layout.addWidget(self.today_lbl)
        layout.addWidget(today_box)

        self._rebuild_priority_rows()
        self._refresh_today_focus()

        btn_layout = QtWidgets.QHBoxLayout()
        save_btn = QtWidgets.QPushButton("üíæ Save")
        save_btn.setObjectName("primaryButton")
        save_btn.clicked.connect(self._save_priorities)
        btn_layout.addWidget(save_btn)
        if self.on_start_callback:
            start_btn = QtWidgets.QPushButton("‚ñ∂ Start Session")
            start_btn.clicked.connect(self._start_session)
            btn_layout.addWidget(start_btn)
        btn_layout.addStretch()
        close_btn = QtWidgets.QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        btn_layout.addWidget(close_btn)
        layout.addLayout(btn_layout)

        # Settings section
        settings_box = QtWidgets.QGroupBox("‚öôÔ∏è Settings")
        settings_layout = QtWidgets.QVBoxLayout(settings_box)
        
        # Startup toggle
        self.startup_check = QtWidgets.QCheckBox("Show this dialog when the app starts")
        self.startup_check.setChecked(self.blocker.show_priorities_on_startup)
        self.startup_check.toggled.connect(self._toggle_startup)
        settings_layout.addWidget(self.startup_check)
        
        # Ask on session start toggle
        self.ask_on_start_check = QtWidgets.QCheckBox("Ask which priority to work on when starting a session")
        self.ask_on_start_check.setChecked(self.blocker.ask_priority_on_session_start)
        self.ask_on_start_check.toggled.connect(self._toggle_ask_on_start)
        settings_layout.addWidget(self.ask_on_start_check)
        
        # Check-in settings
        checkin_layout = QtWidgets.QHBoxLayout()
        self.checkin_enabled = QtWidgets.QCheckBox("Ask if I'm working on priorities every")
        self.checkin_enabled.setChecked(self.blocker.priority_checkin_enabled)
        self.checkin_enabled.toggled.connect(self._toggle_checkin)
        checkin_layout.addWidget(self.checkin_enabled)
        
        self.checkin_interval_spin = NoScrollSpinBox()
        self.checkin_interval_spin.setRange(5, 120)
        self.checkin_interval_spin.setValue(self.blocker.priority_checkin_interval)
        self.checkin_interval_spin.valueChanged.connect(self._update_checkin_interval)
        checkin_layout.addWidget(self.checkin_interval_spin)
        
        checkin_layout.addWidget(QtWidgets.QLabel("minutes during sessions"))
        checkin_layout.addStretch()
        settings_layout.addLayout(checkin_layout)
        
        layout.addWidget(settings_box)

    def _create_priority_row(self, index: int) -> None:
        priority = self.priorities[index]
        group = QtWidgets.QGroupBox(f"Priority #{index + 1}")
        g_layout = QtWidgets.QVBoxLayout(group)

        # Title row with actions
        title_row = QtWidgets.QHBoxLayout()
        title_edit = QtWidgets.QLineEdit(priority.get("title", ""))
        title_edit.setPlaceholderText("Enter priority title...")
        title_row.addWidget(title_edit)

        # Strategic Priority Checkbox
        strategic_chk = QtWidgets.QCheckBox("Strategic (+50% XP)")
        is_strategic = priority.get("strategic", False)
        strategic_chk.setChecked(is_strategic)

        # Strategic checkbox is always enabled - user can change which priority is strategic
        strategic_chk.setToolTip("Sessions focused on this priority grant +50% XP. Only one priority can be strategic at a time.")
        strategic_chk.toggled.connect(lambda checked, idx=index: self._on_strategic_toggled(idx, checked))

        title_row.addWidget(strategic_chk)
        self.strategic_checks.append(strategic_chk)

        complete_btn = QtWidgets.QPushButton("‚úÖ Complete")
        complete_btn.setToolTip("Mark this priority as complete and roll for a Lucky Gift!")
        complete_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold;")
        complete_btn.clicked.connect(lambda checked=False, idx=index: self._complete_priority(idx))
        title_row.addWidget(complete_btn)

        remove_btn = QtWidgets.QPushButton("üóë Remove")
        remove_btn.setToolTip("Remove this priority entry")
        remove_btn.clicked.connect(lambda checked=False, idx=index: self._remove_priority(idx))
        remove_btn.setEnabled(len(self.priorities) > 1)
        title_row.addWidget(remove_btn)

        g_layout.addLayout(title_row)
        self.title_edits.append(title_edit)

        days_layout = QtWidgets.QHBoxLayout()
        days_layout.addWidget(QtWidgets.QLabel("Days:"))
        day_checks = []
        saved_days = priority.get("days", [])
        for day in self.DAYS:
            cb = QtWidgets.QCheckBox(day[:3])
            cb.setChecked(day in saved_days)
            days_layout.addWidget(cb)
            day_checks.append((day, cb))
        self.day_checks.append(day_checks)
        g_layout.addLayout(days_layout)

        planned_layout = QtWidgets.QHBoxLayout()
        planned_layout.addWidget(QtWidgets.QLabel("Planned hours:"))
        planned_spin = NoScrollDoubleSpinBox()
        planned_spin.setRange(0, 100)
        planned_spin.setValue(priority.get("planned_hours", 0))
        planned_layout.addWidget(planned_spin)
        self.planned_spins.append(planned_spin)
        
        logged = priority.get("logged_hours", 0)
        planned = priority.get("planned_hours", 0)
        
        if planned > 0:
            p_bar = QtWidgets.QProgressBar()
            p_bar.setMaximum(100)
            pct = min(100, int((logged / planned) * 100)) if planned else 0
            p_bar.setValue(pct)
            p_bar.setFormat(f"{logged:.1f}/{planned:.1f} hrs ({pct}%)")
            p_bar.setFixedWidth(160)
            planned_layout.addWidget(p_bar)
            
        g_layout.addLayout(planned_layout)
        self.priority_list_layout.addWidget(group)

    def _on_strategic_toggled(self, index: int, checked: bool) -> None:
        """Handle strategic status changes with exclusivity."""
        if not checked:
            return

        # If this one is checked, uncheck all OTHER NEW strategic checkboxes
        for i, chk in enumerate(self.strategic_checks):
            if i != index and chk.isEnabled() and chk.isChecked():
                chk.setChecked(False)

    def _sync_ui_into_priorities(self) -> None:
        """Sync current UI widget values back into self.priorities data."""
        for i in range(len(self.priorities)):
            if i < len(self.title_edits):
                self.priorities[i]["title"] = self.title_edits[i].text().strip()
            if i < len(self.day_checks):
                days = [day for day, cb in self.day_checks[i] if cb.isChecked()]
                self.priorities[i]["days"] = days
            if i < len(self.planned_spins):
                self.priorities[i]["planned_hours"] = self.planned_spins[i].value()
            if i < len(self.strategic_checks):
                self.priorities[i]["strategic"] = self.strategic_checks[i].isChecked()

    def _rebuild_priority_rows(self) -> None:
        """Recreate the priority row widgets to reflect current data."""
        if self.priority_list_layout is None:
            return

        # Ensure only one strategic priority is marked
        strategic_seen = False
        for priority in self.priorities:
            if priority.get("strategic") and not strategic_seen:
                strategic_seen = True
            else:
                priority["strategic"] = False

        # Clean up existing widgets
        while self.priority_list_layout.count():
            item = self.priority_list_layout.takeAt(0)
            widget = item.widget()
            if widget is not None:
                widget.deleteLater()

        # Reset widget tracking lists
        self.title_edits = []
        self.day_checks = []
        self.planned_spins = []
        self.strategic_checks = []

        # Ensure at least one priority exists
        if not self.priorities:
            self.priorities.append(self._empty_priority())

        # Create row widgets for each priority
        for idx in range(len(self.priorities)):
            self._create_priority_row(idx)

    def _add_priority(self) -> None:
        """Append a new blank priority entry."""
        self._sync_ui_into_priorities()
        self.priorities.append(self._empty_priority())
        self._rebuild_priority_rows()
        self._refresh_today_focus()

    def _remove_priority(self, index: int) -> None:
        """Remove a priority by index or clear the final remaining entry."""
        self._sync_ui_into_priorities()
        if index < 0 or index >= len(self.priorities):
            return
        if len(self.priorities) <= 1:
            self.priorities[0] = self._empty_priority()
        else:
            self.priorities.pop(index)
        self._rebuild_priority_rows()
        self._refresh_today_focus()

    def _refresh_today_focus(self) -> None:
        today = datetime.now().strftime("%A")
        today_priorities = []
        for i, p in enumerate(self.priorities):
            title = p.get("title", "").strip()
            days = p.get("days", [])
            if title and (not days or today in days):
                today_priorities.append(f"#{i+1}: {title}")
        if today_priorities:
            self.today_lbl.setText("\n".join(today_priorities))
        else:
            self.today_lbl.setText("No priorities set for today.")

    def _save_priorities(self) -> None:
        self._sync_ui_into_priorities()
        self.blocker.priorities = copy.deepcopy(self.priorities)
        self.blocker.save_config()
        self._rebuild_priority_rows()
        self._refresh_today_focus()
        show_info(self, "Saved", "Priorities saved!")

    def _start_session(self) -> None:
        self._save_priorities()
        
        # Find the first priority for today
        today = datetime.now().strftime("%A")
        target_priority = None
        
        for p in self.priorities:
            if p.get("title", "").strip() and (not p.get("days") or today in p.get("days", [])):
                target_priority = p.get("title")
                break
        
        if target_priority:
            self.accept()
            if self.on_start_callback:
                self.on_start_callback(target_priority)
        else:
            show_warning(self, "No Priority", 
                                  "No priority task found for today!\n"
                                  "Add a task above and ensure today is selected.")

    def _toggle_startup(self, checked: bool) -> None:
        self.blocker.show_priorities_on_startup = checked
        self.blocker.save_config()

    def _toggle_ask_on_start(self, checked: bool) -> None:
        self.blocker.ask_priority_on_session_start = checked
        self.blocker.save_config()

    def _toggle_checkin(self, checked: bool) -> None:
        self.blocker.priority_checkin_enabled = checked
        self.blocker.save_config()

    def _update_checkin_interval(self, value: int) -> None:
        if 5 <= value <= 120:
            self.blocker.priority_checkin_interval = value
            self.blocker.save_config()

    def _complete_priority(self, index: int) -> None:
        """Mark a priority as complete and roll for a lucky gift reward."""
        self._sync_ui_into_priorities()
        title = self.title_edits[index].text().strip()
        if not title:
            show_warning(self, "No Priority", 
                "This priority slot is empty. Enter a title first!")
            return
        
        # Get logged hours for this priority
        logged_hours = self.priorities[index].get("logged_hours", 0)
        
        # Calculate chance for display
        if logged_hours >= 20:
            chance = 99
        elif logged_hours > 0:
            chance = min(99, int(15 + (logged_hours / 20) * 84))
        else:
            chance = 15
        
        # Confirm completion
        reply = show_question(
            self, "Complete Priority?",
            f"üéØ Mark '{title}' as COMPLETE?\n\n"
            f"You'll get a chance to win a Lucky Gift!\n"
            f"(üé∞ {chance}% chance based on {logged_hours:.1f}h logged)",
            QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No
        )
        
        if reply != QtWidgets.QMessageBox.StandardButton.Yes:
            return
        
        # Show animated lottery dialog for priority completion
        active_story = self.blocker.adhd_buster.get("active_story", "warrior")
        
        from lottery_animation import PriorityLotteryDialog
        lottery = PriorityLotteryDialog(
            win_chance=chance / 100.0,
            priority_title=title,
            logged_hours=logged_hours,
            story_id=active_story,
            parent=self
        )
        lottery.exec()
        
        # Get results from lottery
        won, rarity, item = lottery.get_results()
        
        # Prepare items and coins for batch award
        items_earned = []
        coins_earned = 100  # Base coins for completing a priority
        
        if won and item:
            # Ensure item has all required fields
            if "obtained_at" not in item:
                item["obtained_at"] = datetime.now().isoformat()
            items_earned.append(item)
        
        # Use GameState manager for reactive updates
        main_window = self.window()
        game_state = getattr(main_window, 'game_state', None)
        if not game_state:
            logger.error("GameStateManager not available - cannot award priority completion rewards")
            return
        
        # Get equipped before awarding for comparison
        equipped = self.blocker.adhd_buster.get("equipped", {})
        
        # Use batch award - handles inventory, auto-equip, coins, save, and signals
        game_state.award_items_batch(items_earned, coins=coins_earned, auto_equip=True, source="priority_completion")
        
        # Sync changes to active hero
        if GAMIFICATION_AVAILABLE:
            sync_hero_data(self.blocker.adhd_buster)
            self.blocker.save_config()
        
        # Show ItemRewardDialog with comparison if items were earned
        if items_earned:
            from styled_dialog import ItemRewardDialog
            dialog = ItemRewardDialog(
                parent=self,
                title="‚úÖ Priority Complete!",
                header_emoji="‚úÖ",
                source_label="Priority Completion Reward",
                items_earned=items_earned,
                equipped=equipped,
                coins_earned=coins_earned,
                game_state=game_state  # For themed slot names
            )
            dialog.exec()
        
        # Remove the completed priority from the list
        if len(self.priorities) <= 1:
            # Keep at least one slot, just clear it
            self.priorities[0] = self._empty_priority()
        else:
            self.priorities.pop(index)
        
        # Save and refresh
        self.blocker.priorities = copy.deepcopy(self.priorities)
        self.blocker.save_config()
        self._rebuild_priority_rows()
        self._refresh_today_focus()
        
        # Update coin display in main window
        main_window = self.parent()
        while main_window and not isinstance(main_window, QtWidgets.QMainWindow):
            main_window = main_window.parent()
        if main_window and hasattr(main_window, '_update_coin_display'):
            main_window._update_coin_display()


class AISessionCompleteDialog(StyledDialog):
    """AI-powered session completion dialog with ratings, notes, and break suggestions."""

    def __init__(self, blocker: BlockerCore, session_duration: int,
                 parent: Optional[QtWidgets.QWidget] = None) -> None:
        self.blocker = blocker
        self.session_duration = session_duration
        self.selected_rating = ""
        
        super().__init__(
            parent=parent,
            title="Session Complete!",
            header_icon="üéâ",
            min_width=480,
            max_width=600,
        )
        self.resize(520, 550)

    def _build_content(self, layout: QtWidgets.QVBoxLayout) -> None:
        duration_label = QtWidgets.QLabel(f"üéØ You focused for {self.session_duration // 60} minutes")
        duration_label.setAlignment(QtCore.Qt.AlignCenter)
        duration_label.setStyleSheet("font-size: 14px; color: #E0E0E0;")
        layout.addWidget(duration_label)

        # Rating section
        rating_group = QtWidgets.QGroupBox("üìù How was your focus? (optional)")
        rating_layout = QtWidgets.QVBoxLayout(rating_group)

        rate_lbl = QtWidgets.QLabel("Rate your session:")
        rate_lbl.setStyleSheet("color: #E0E0E0;")
        rating_layout.addWidget(rate_lbl)

        btn_layout = QtWidgets.QHBoxLayout()
        ratings = [
            ("üò´", "Struggled to concentrate, many distractions"),
            ("üòê", "Decent session, some distractions"),
            ("üòä", "Good session, stayed mostly focused"),
            ("üåü", "Amazing session! In the zone!")
        ]
        self.rating_buttons = []
        for emoji, description in ratings:
            btn = QtWidgets.QPushButton(emoji)
            btn.setProperty("rating_desc", description)
            btn.setCheckable(True)
            btn.setMinimumWidth(50)
            btn.clicked.connect(lambda checked, d=description, b=btn: self._select_rating(d, b))
            btn_layout.addWidget(btn)
            self.rating_buttons.append(btn)
        rating_layout.addLayout(btn_layout)

        notes_lbl = QtWidgets.QLabel("Or write your own notes:")
        notes_lbl.setStyleSheet("color: #E0E0E0;")
        rating_layout.addWidget(notes_lbl)
        self.notes_edit = QtWidgets.QTextEdit()
        self.notes_edit.setMaximumHeight(80)
        self.notes_edit.setPlaceholderText("How did the session go?")
        rating_layout.addWidget(self.notes_edit)

        # AI analysis display
        self.analysis_label = QtWidgets.QLabel("")
        self.analysis_label.setStyleSheet("color: #FFD700; font-style: italic;")
        self.analysis_label.setWordWrap(True)
        rating_layout.addWidget(self.analysis_label)

        layout.addWidget(rating_group)

        # Break suggestions
        suggestion_group = QtWidgets.QGroupBox("üí° Suggested Break Activities")
        suggestion_layout = QtWidgets.QVBoxLayout(suggestion_group)
        self.suggestions_label = QtWidgets.QLabel()
        self.suggestions_label.setWordWrap(True)
        self.suggestions_label.setStyleSheet("color: #E0E0E0;")
        suggestion_layout.addWidget(self.suggestions_label)
        layout.addWidget(suggestion_group)

        # Generate suggestions
        self._generate_suggestions()

        # Buttons
        btn_layout2 = QtWidgets.QHBoxLayout()
        skip_btn = QtWidgets.QPushButton("Skip")
        skip_btn.clicked.connect(self.accept)
        btn_layout2.addWidget(skip_btn)
        btn_layout2.addStretch()
        save_btn = QtWidgets.QPushButton("üíæ Save & Continue")
        save_btn.setObjectName("primaryButton")
        save_btn.clicked.connect(self._save_and_close)
        btn_layout2.addWidget(save_btn)
        layout.addLayout(btn_layout2)

    def _select_rating(self, description: str, clicked_btn: QtWidgets.QPushButton) -> None:
        self.selected_rating = description
        for btn in self.rating_buttons:
            btn.setChecked(btn == clicked_btn)

    def _generate_suggestions(self) -> None:
        """Generate break activity suggestions based on session duration."""
        session_mins = self.session_duration // 60
        
        # Generate suggestions based on session length (same logic as LocalAI.suggest_break_activity)
        if session_mins > 60:  # Long session
            suggestions = [
                "üö∂ Take a 10-minute walk to refresh",
                "üíß Drink water and do light stretching",
                "üå≥ Step outside for fresh air"
            ]
        elif session_mins > 30:
            suggestions = [
                "‚òï Quick coffee/tea break",
                "üßò 5-minute breathing exercises",
                "üëÄ Look away from screen, rest eyes"
            ]
        else:
            suggestions = [
                "‚ö° Brief 2-minute stretch",
                "üí™ Do 10 pushups for energy",
                "üéµ Listen to one song"
            ]
        
        text = "\n".join(f"  {i}. {s}" for i, s in enumerate(suggestions, 1))
        self.suggestions_label.setText(text)

    def _save_and_close(self) -> None:
        note = self.notes_edit.toPlainText().strip()
        if not note and self.selected_rating:
            note = self.selected_rating

        if note:
            self._save_session_note(note)

        self.accept()

    def _save_session_note(self, note: str) -> None:
        """Save session note to stats."""
        session_notes = self.blocker.stats.get("session_notes", [])
        session_notes.append({
            "timestamp": datetime.now().isoformat(),
            "duration_seconds": self.session_duration,
            "note": note
        })
        # Keep last 50 notes
        self.blocker.stats["session_notes"] = session_notes[-50:]
        self.blocker.save_stats()


# ============================================================================
# Daily Timeline Widgets
# ============================================================================

class WaterRingWidget(QtWidgets.QWidget):
    """Circular progress bar for daily hydration goal."""
    clicked = QtCore.Signal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.percentage = 0.0
        self.current = 0
        self.goal = 5
        self.setMinimumSize(60, 60)
        self.setCursor(QtCore.Qt.CursorShape.PointingHandCursor)

    def set_progress(self, current: int, goal: int = 5):
        """Set water progress (glasses consumed / goal)."""
        goal = max(1, goal)  # Avoid division by zero
        self.percentage = min(current / goal, 1.0)
        self.current = current
        self.goal = goal
        self.repaint()  # Force immediate repaint

    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        
        rect = self.rect().adjusted(5, 5, -5, -5)
        
        # Background Track
        pen = QtGui.QPen(QtGui.QColor("#1a3a5c"), 6)
        pen.setCapStyle(QtCore.Qt.RoundCap)
        painter.setPen(pen)
        painter.drawEllipse(rect)
        
        # Progress Arc (cyan/blue for water)
        pen.setColor(QtGui.QColor("#4fc3f7"))
        painter.setPen(pen)
        
        start_angle = 90 * 16
        span_angle = -int(self.percentage * 360 * 16)
        painter.drawArc(rect, start_angle, span_angle)
        
        # Main text: glasses count with emoji
        painter.setPen(QtGui.QColor("#ffffff"))
        font = painter.font()
        font.setPixelSize(14)
        font.setBold(True)
        painter.setFont(font)
        
        main_rect = QtCore.QRectF(rect)
        painter.drawText(main_rect, QtCore.Qt.AlignmentFlag.AlignCenter, f"üíß{self.current}")
        
        # Subtext: "of 8" label
        font.setPixelSize(10)
        font.setBold(False)
        painter.setFont(font)
        sub_rect = QtCore.QRectF(rect.adjusted(0, 20, 0, 0))
        painter.setPen(QtGui.QColor("#4fc3f7"))
        painter.drawText(sub_rect, QtCore.Qt.AlignmentFlag.AlignCenter, f"of {self.goal}")

    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.MouseButton.LeftButton:
            self.clicked.emit()
        super().mousePressEvent(event)


class ChapterRingWidget(QtWidgets.QWidget):
    """Circular progress bar for story chapter progress (power-based)."""
    clicked = QtCore.Signal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.percentage = 0.0
        self.unlocked = 0
        self.total = 7
        self.is_complete = False
        self.setMinimumSize(60, 60)
        self.setCursor(QtCore.Qt.CursorShape.PointingHandCursor)

    def set_progress(self, unlocked_chapters: int, progress_pct: float, total_chapters: int = 7, is_complete: bool = False):
        """Set chapter progress.
        
        Args:
            unlocked_chapters: Number of chapters currently unlocked
            progress_pct: Progress percentage toward next chapter (0-100)
            total_chapters: Total chapters in story
            is_complete: Whether all chapters are unlocked
        """
        self.percentage = min(max(progress_pct / 100.0, 0.0), 1.0)
        self.unlocked = unlocked_chapters
        self.total = total_chapters
        self.is_complete = is_complete
        self.repaint()  # Force immediate repaint

    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        
        rect = self.rect().adjusted(5, 5, -5, -5)
        
        # Background Track
        pen = QtGui.QPen(QtGui.QColor("#2a3a2a"), 6)
        pen.setCapStyle(QtCore.Qt.RoundCap)
        painter.setPen(pen)
        painter.drawEllipse(rect)
        
        # Progress Arc (green for story progress, gold if complete)
        arc_color = "#ffd700" if self.is_complete else "#8bc34a"
        pen.setColor(QtGui.QColor(arc_color))
        painter.setPen(pen)
        
        start_angle = 90 * 16
        span_angle = -int(self.percentage * 360 * 16)
        painter.drawArc(rect, start_angle, span_angle)
        
        # Main text: "üìñ X/Y" chapters
        painter.setPen(QtGui.QColor("#ffffff"))
        font = painter.font()
        font.setPixelSize(13)
        font.setBold(True)
        painter.setFont(font)
        
        main_rect = QtCore.QRectF(rect)
        painter.drawText(main_rect, QtCore.Qt.AlignmentFlag.AlignCenter, f"üìñ{self.unlocked}/{self.total}")
        
        # Subtext: progress percentage or "Done!"
        font.setPixelSize(10)
        font.setBold(False)
        painter.setFont(font)
        sub_rect = QtCore.QRectF(rect.adjusted(0, 20, 0, 0))
        painter.setPen(QtGui.QColor(arc_color))
        
        if self.is_complete:
            painter.drawText(sub_rect, QtCore.Qt.AlignmentFlag.AlignCenter, "‚ú®Done")
        else:
            pct = int(self.percentage * 100)
            painter.drawText(sub_rect, QtCore.Qt.AlignmentFlag.AlignCenter, f"{pct}%")

    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.MouseButton.LeftButton:
            self.clicked.emit()
        super().mousePressEvent(event)


class EyeRingWidget(QtWidgets.QWidget):
    """Circular progress bar for daily eye routines."""
    clicked = QtCore.Signal()
    
    # Vision progression: blind animals ‚Üí sharp-eyed predators
    EYE_CATEGORIES = [
        (0, "ü¶î Mole", "#ff6b6b"),       # 0 routines - nearly blind
        (1, "ü¶á Bat", "#ff8c42"),        # 1 routine - uses echolocation
        (3, "üêÅ Mouse", "#ffa726"),      # 3+ routines - poor vision
        (5, "üê∂ Pup", "#ffca28"),        # 5+ routines - decent
        (8, "üê± Cat", "#9ccc65"),        # 8+ routines - good night vision
        (12, "ü¶â Owl", "#66bb6a"),       # 12+ routines - excellent
        (16, "ü¶Ö Eagle", "#26c6da"),     # 16+ routines - 8x human vision
        (20, "ü¶Ö Hawk", "#ab47bc"),      # 20+ routines - the best!
    ]
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.percentage = 0.0
        self.text = "0"
        self.subtext = "üëÄ Screen Zombie"
        self.ring_color = "#00bcd4"  # Cyan for eye theme
        self.setMinimumSize(60, 60)
        self.setCursor(QtCore.Qt.CursorShape.PointingHandCursor)
        self.setToolTip("Eyes Routine\nClick to open Eyes tab")

    def set_progress(self, current: int, daily_cap: int):
        """Set eye routine progress."""
        daily_cap = max(1, daily_cap)  # Avoid division by zero
        self.percentage = min(current / daily_cap, 1.0)
        self.text = f"üëÅÔ∏è{current}"
        
        # Find appropriate category
        category_text = self.EYE_CATEGORIES[0][1]
        self.ring_color = self.EYE_CATEGORIES[0][2]
        
        for threshold, label, color in self.EYE_CATEGORIES:
            if current >= threshold:
                category_text = label
                self.ring_color = color
        
        self.subtext = category_text
        self.repaint()  # Force immediate repaint

    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        
        # Adjust rect to ensure stroke doesn't clip
        rect = self.rect().adjusted(5, 5, -5, -5)
        
        # Draw Background Track
        pen = QtGui.QPen(QtGui.QColor("#2a2a4a"), 6)
        pen.setCapStyle(QtCore.Qt.RoundCap)
        painter.setPen(pen)
        painter.drawEllipse(rect)
        
        # Draw Progress Arc (dynamic color based on category)
        pen.setColor(QtGui.QColor(self.ring_color))
        painter.setPen(pen)
        
        start_angle = 90 * 16
        span_angle = -int(self.percentage * 360 * 16)
        painter.drawArc(rect, start_angle, span_angle)
        
        # Draw count text
        painter.setPen(QtGui.QColor("#ffffff"))
        font = painter.font()
        font.setPixelSize(12)
        font.setBold(True)
        painter.setFont(font)
        
        text_rect = QtCore.QRectF(rect)
        painter.drawText(text_rect, QtCore.Qt.AlignmentFlag.AlignCenter, self.text)
        
        # Draw category subtext below
        font.setPixelSize(8)
        font.setBold(False)
        painter.setFont(font)
        sub_rect = QtCore.QRectF(rect.adjusted(-5, 22, 5, 0))
        painter.setPen(QtGui.QColor(self.ring_color))
        
        # Truncate long labels
        subtext = self.subtext
        if len(subtext) > 14:
            subtext = subtext[:12] + "‚Ä¶"
        painter.drawText(sub_rect, QtCore.Qt.AlignmentFlag.AlignCenter, subtext)

    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.MouseButton.LeftButton:
            self.clicked.emit()
        super().mousePressEvent(event)


class XPRingWidget(QtWidgets.QWidget):
    """Circular progress bar for XP to next level."""
    clicked = QtCore.Signal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.percentage = 0.0
        self.text = "Lv.1"
        self.subtext = "Novice"
        self.setMinimumSize(60, 60)
        self.setCursor(QtCore.Qt.CursorShape.PointingHandCursor)

    def set_progress(self, level: int, xp_in_level: int, xp_needed: int, total_xp: int):
        """Set XP progress toward next level."""
        xp_needed = max(1, xp_needed)  # Avoid division by zero
        self.percentage = min(xp_in_level / xp_needed, 1.0)
        self.text = f"Lv.{level}"
        
        # Get level title name
        try:
            from gamification import get_level_title
            title, emoji = get_level_title(level)
            self.subtext = title
        except Exception:
            self.subtext = "Novice"
        
        # Force repaint to show new values
        self.repaint()

    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        
        # Adjust rect to ensure stroke doesn't clip
        rect = self.rect().adjusted(5, 5, -5, -5)
        
        # Draw Background Track
        pen = QtGui.QPen(QtGui.QColor("#2a2a4a"), 6)
        pen.setCapStyle(QtCore.Qt.RoundCap)
        painter.setPen(pen)
        painter.drawEllipse(rect)
        
        # Draw Progress Arc (gold/yellow for XP)
        pen.setColor(QtGui.QColor("#ffd700"))
        painter.setPen(pen)
        
        start_angle = 90 * 16
        span_angle = -int(self.percentage * 360 * 16)
        painter.drawArc(rect, start_angle, span_angle)
        
        # Draw Level Text
        painter.setPen(QtGui.QColor("#ffffff"))
        font = painter.font()
        font.setPixelSize(13)
        font.setBold(True)
        painter.setFont(font)
        
        text_rect = QtCore.QRectF(rect)
        painter.drawText(text_rect, QtCore.Qt.AlignmentFlag.AlignCenter, self.text)
        
        # Draw XP subtext below
        font.setPixelSize(10)
        font.setBold(False)
        painter.setFont(font)
        sub_rect = QtCore.QRectF(rect.adjusted(0, 20, 0, 0))
        painter.setPen(QtGui.QColor("#ffd700"))
        painter.drawText(sub_rect, QtCore.Qt.AlignmentFlag.AlignCenter, self.subtext)

    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.MouseButton.LeftButton:
            self.clicked.emit()
        super().mousePressEvent(event)


class FocusRingWidget(QtWidgets.QWidget):
    """Circular progress bar for daily focus goal."""
    clicked = QtCore.Signal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.percentage = 0.0
        self.text = "0%"
        self.subtext = "Focus"
        self.setMinimumSize(60, 60)
        self.setCursor(QtCore.Qt.CursorShape.PointingHandCursor)

    def set_progress(self, current_seconds, goal_seconds):
        # Guard against negative values
        current_seconds = max(0, current_seconds)
        goal_seconds = max(1, goal_seconds)  # Minimum 1 to avoid division by zero
        
        self.percentage = min(current_seconds / goal_seconds, 1.0)
            
        hours = int(current_seconds // 3600)
        mins = int((current_seconds % 3600) // 60)
        
        # If less than an hour, show minutes only or "0h 30m"
        if hours > 0:
            self.text = f"{hours}h {mins}m"
        else:
            self.text = f"{mins}m"
            
        self.repaint()  # Force immediate repaint

    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        
        # Adjust rect to ensure stroke doesn't clip
        rect = self.rect().adjusted(5, 5, -5, -5)
        
        # Draw Background Track
        pen = QtGui.QPen(QtGui.QColor("#2a2a4a"), 6)
        pen.setCapStyle(QtCore.Qt.RoundCap)
        painter.setPen(pen)
        painter.drawEllipse(rect)
        
        # Draw Progress Arc
        # QPainter draws arcs in 1/16th of a degree
        # 0 degrees is 3 o'clock. We want to start at 12 o'clock (90 degrees)
        # Positive span is counter-clockwise? No, generic is counter-clockwise.
        # But wait, 90 is 12 o'clock. 
        # To draw clockwise, we need negative span.
        
        pen.setColor(QtGui.QColor("#6366f1"))
        painter.setPen(pen)
        
        start_angle = 90 * 16
        span_angle = -int(self.percentage * 360 * 16)
        
        # If full circle, draw ellipse to avoid artifact? Arc is fine.
        painter.drawArc(rect, start_angle, span_angle)
        
        # Draw Text
        painter.setPen(QtGui.QColor("#ffffff"))
        
        # Center Text
        font = painter.font()
        font.setPixelSize(13)
        font.setBold(True)
        painter.setFont(font)
        
        # Draw main text in center
        text_rect = QtCore.QRectF(rect)
        painter.drawText(text_rect, QtCore.Qt.AlignmentFlag.AlignCenter, self.text)
        
        # Draw subtext below
        font.setPixelSize(10)
        font.setBold(False)
        painter.setFont(font)
        sub_rect = QtCore.QRectF(rect.adjusted(0, 20, 0, 0))
        painter.setPen(QtGui.QColor("#aaaaaa"))
        painter.drawText(sub_rect, QtCore.Qt.AlignmentFlag.AlignCenter, self.subtext)

    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.MouseButton.LeftButton:
            self.clicked.emit()
        super().mousePressEvent(event)


class EntitiesRingWidget(QtWidgets.QWidget):
    """Circular progress bar for entities bonded (Entitidex collection)."""
    clicked = QtCore.Signal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.percentage = 0.0
        self.normal_count = 0
        self.exceptional_count = 0
        self.total_possible = 45  # 9 entities √ó 5 story pools
        self.setMinimumSize(60, 60)
        self.setCursor(QtCore.Qt.CursorShape.PointingHandCursor)

    def set_progress(self, normal_count: int, exceptional_count: int, total_possible: int = 45):
        """Set entities bonded progress.
        
        Args:
            normal_count: Number of normal entities collected
            exceptional_count: Number of exceptional entities collected
            total_possible: Total entities that can be collected
        """
        self.normal_count = normal_count
        self.exceptional_count = exceptional_count
        self.total_possible = max(1, total_possible)
        total_bonded = normal_count + exceptional_count
        self.percentage = min(total_bonded / self.total_possible, 1.0)
        self.repaint()  # Force immediate repaint

    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        
        rect = self.rect().adjusted(5, 5, -5, -5)
        
        # Background Track
        pen = QtGui.QPen(QtGui.QColor("#2a2a3a"), 6)
        pen.setCapStyle(QtCore.Qt.RoundCap)
        painter.setPen(pen)
        painter.drawEllipse(rect)
        
        # Progress Arc (purple/magenta for entities)
        # Golden glow if we have any exceptional entities
        if self.exceptional_count > 0:
            arc_color = "#ba68c8"  # Purple for exceptional
        else:
            arc_color = "#9c27b0"  # Darker purple for normal only
        
        pen.setColor(QtGui.QColor(arc_color))
        painter.setPen(pen)
        
        start_angle = 90 * 16
        span_angle = -int(self.percentage * 360 * 16)
        painter.drawArc(rect, start_angle, span_angle)
        
        # Main text: total count with star emoji, exceptional part in brighter color
        total_bonded = self.normal_count + self.exceptional_count
        font = painter.font()
        font.setPixelSize(14)
        font.setBold(True)
        painter.setFont(font)
        
        main_rect = QtCore.QRectF(rect)
        
        # Draw the count with exceptional part highlighted
        if self.exceptional_count > 0 and self.normal_count > 0:
            # Format: ‚≠ênormal+exceptional where exceptional is brighter
            text = f"‚≠ê{self.normal_count}"
            exc_text = f"+{self.exceptional_count}"
            
            # Calculate positions for centered text
            fm = QtGui.QFontMetrics(font)
            full_text = text + exc_text
            total_width = fm.horizontalAdvance(full_text)
            center_x = main_rect.center().x()
            start_x = center_x - total_width / 2
            text_y = main_rect.center().y() + fm.ascent() / 2 - 2
            
            # Draw normal part in white
            painter.setPen(QtGui.QColor("#ffffff"))
            painter.drawText(QtCore.QPointF(start_x, text_y), text)
            
            # Draw exceptional part in bright gold
            painter.setPen(QtGui.QColor("#ffd700"))
            painter.drawText(QtCore.QPointF(start_x + fm.horizontalAdvance(text), text_y), exc_text)
        else:
            # Just show total in appropriate color
            if self.exceptional_count > 0:
                painter.setPen(QtGui.QColor("#ffd700"))  # All exceptional - gold
            else:
                painter.setPen(QtGui.QColor("#ffffff"))  # Normal only - white
            painter.drawText(main_rect, QtCore.Qt.AlignmentFlag.AlignCenter, f"‚≠ê{total_bonded}")
        
        # Subtext: "Bonded" or show exceptional count if any
        font.setPixelSize(10)
        font.setBold(False)
        painter.setFont(font)
        sub_rect = QtCore.QRectF(rect.adjusted(0, 20, 0, 0))
        painter.setPen(QtGui.QColor(arc_color))
        
        if self.exceptional_count > 0:
            painter.drawText(sub_rect, QtCore.Qt.AlignmentFlag.AlignCenter, f"‚ú®{self.exceptional_count}")
        else:
            painter.drawText(sub_rect, QtCore.Qt.AlignmentFlag.AlignCenter, "Bonded")

    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.MouseButton.LeftButton:
            self.clicked.emit()
        super().mousePressEvent(event)


class MiniHeroWidget(QtWidgets.QWidget):
    """Wrapper widget that renders CharacterCanvas at full size and scales it down.
    
    Uses signal-based updates instead of polling for efficiency.
    Caches the pixmap and only re-renders when data actually changes.
    """
    clicked = QtCore.Signal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedSize(70, 90)
        self.setCursor(QtCore.Qt.CursorShape.PointingHandCursor)
        self.setToolTip("Your Hero - Click to view Hero tab")
        
        # Store hero data for change detection
        self._equipped = {}
        self._power = 0
        self._story_theme = "warrior"
        self._cached_pixmap = None
        self._last_data_hash = None  # For detecting actual changes
    
    def _compute_data_hash(self) -> str:
        """Compute a hash of current data to detect changes."""
        # Create a simple hash from equipped items + power + theme
        equipped_str = str(sorted((k, v.get("id", k) if v else None) 
                                   for k, v in self._equipped.items()))
        return f"{equipped_str}|{self._power}|{self._story_theme}"
    
    def set_hero_data(self, equipped: dict, power: int, story_theme: str = "warrior"):
        """Update hero display only if data actually changed."""
        self._equipped = equipped or {}
        self._power = power
        self._story_theme = story_theme
        
        # Check if data actually changed
        new_hash = self._compute_data_hash()
        if new_hash == self._last_data_hash and self._cached_pixmap:
            return  # No change, skip expensive re-render
        
        self._last_data_hash = new_hash
        
        # Create CharacterCanvas for its drawing logic (not for display)
        full_canvas = CharacterCanvas(self._equipped, self._power, 
                                       width=CharacterCanvas.BASE_W, 
                                       height=CharacterCanvas.BASE_H, 
                                       story_theme=self._story_theme)
        
        # Use QImage for robust offscreen rendering
        image = QtGui.QImage(CharacterCanvas.BASE_W, CharacterCanvas.BASE_H, 
                             QtGui.QImage.Format.Format_ARGB32_Premultiplied)
        image.fill(QtCore.Qt.GlobalColor.transparent)
        
        painter = QtGui.QPainter(image)
        if not painter.isActive():
            print("[DEBUG] QPainter failed to activate on QImage!")
            return
        
        try:
            # Critical state resets before any drawing
            painter.setOpacity(1.0)
            painter.setCompositionMode(QtGui.QPainter.CompositionMode.CompositionMode_SourceOver)
            painter.setClipping(False)
            painter.setRenderHint(QtGui.QPainter.RenderHint.Antialiasing)
            painter.setRenderHint(QtGui.QPainter.RenderHint.TextAntialiasing)
            painter.setRenderHint(QtGui.QPainter.RenderHint.SmoothPixmapTransform)
            
            # render_content draws using canonical BASE_W x BASE_H coordinates
            full_canvas.render_content(painter)
        finally:
            painter.end()
        
        # DEBUG: Save the image to verify content
        debug_path = "F:/_DEV/PersonalFreedom/debug_hero_render.png"
        saved = image.save(debug_path)
        print(f"[DEBUG] Hero image saved: {saved}, size: {image.width()}x{image.height()}, isNull: {image.isNull()}")
        
        # Convert QImage to QPixmap for display
        self._cached_pixmap = QtGui.QPixmap.fromImage(image)
        print(f"[DEBUG] Cached pixmap isNull: {self._cached_pixmap.isNull()}, size: {self._cached_pixmap.width()}x{self._cached_pixmap.height()}")
        
        # Update tooltip
        tier = "pathetic"
        if GAMIFICATION_AVAILABLE and get_diary_power_tier:
            tier = get_diary_power_tier(power)
        self.setToolTip(f"‚öî Power: {power} ({tier.title()})\nClick to view Hero tab")
        
        self.update()
    
    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        try:
            painter.setRenderHint(QtGui.QPainter.RenderHint.Antialiasing)
            # Reset painter state to ensure visibility
            painter.setOpacity(1.0)
            painter.setCompositionMode(QtGui.QPainter.CompositionMode.CompositionMode_SourceOver)
            painter.setClipping(False)
            
            # Fill background to match timeline
            painter.fillRect(self.rect(), QtGui.QColor("#1a1a2e"))
            
            pm = self._cached_pixmap
            if pm and not pm.isNull():
                # Scale to fit widget while keeping aspect ratio
                scaled = pm.scaled(self.size(),
                                   QtCore.Qt.AspectRatioMode.KeepAspectRatio,
                                   QtCore.Qt.TransformationMode.SmoothTransformation)
                x = (self.width() - scaled.width()) // 2
                y = (self.height() - scaled.height()) // 2
                painter.drawPixmap(x, y, scaled)
        finally:
            painter.end()
    
    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.MouseButton.LeftButton:
            self.clicked.emit()
        super().mousePressEvent(event)


class ChronoStreamWidget(QtWidgets.QWidget):
    """Timeline visualization for 24h events."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.events = []  # List of dicts with 'start', 'end', 'color', 'label'
        self.setMinimumHeight(60)
        
        # Update current time indicator periodically
        self.timer = QtCore.QTimer(self)
        self.timer.timeout.connect(self.update) # Just repaint
        self.timer.start(60000) # Every minute
        self.destroyed.connect(self._cleanup_timer)
    
    def _cleanup_timer(self):
        """Stop timer when widget is destroyed."""
        if self.timer:
            self.timer.stop()

    def set_events(self, events):
        self.events = events
        self.update()

    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        
        rect = self.rect()
        width = rect.width()
        height = rect.height()
        
        # Guard against zero/invalid dimensions
        if width < 10 or height < 10:
            return
        
        # Colors
        bg_color = QtGui.QColor("#16213e")
        line_color = QtGui.QColor("#4a4a6a")
        text_color = QtGui.QColor("#8888aa")
        
        # Background
        painter.fillRect(rect, bg_color)
        
        # Geometry
        # Top half: Visualization blocks
        # Bottom half: Ruler
        ruler_y = int(height * 0.7)
        block_y = int(height * 0.2)
        block_h = int(height * 0.4)
        
        # Draw Ruler Line
        pen = QtGui.QPen(line_color)
        painter.setPen(pen)
        painter.drawLine(0, ruler_y, width, ruler_y)
        
        # Draw Hour Markers
        painter.setFont(QtGui.QFont("Segoe UI", 8))
        for h in range(0, 25, 4): # 0, 4, 8, 12...
            x = int((h / 24.0) * width)
            
            # Tick
            painter.drawLine(x, ruler_y, x, ruler_y + 5)
            
            # Label
            # Adjust x for text centering
            label = f"{h:02}"
            text_rect = QtCore.QRect(x - 15, ruler_y + 8, 30, 20)
            painter.setPen(text_color)
            painter.drawText(text_rect, QtCore.Qt.AlignmentFlag.AlignCenter, label)
            painter.setPen(line_color) # Reset for next line

        # Draw Events
        for evt in self.events:
            start = evt.get('start', 0)
            end = evt.get('end', 0)
            color = evt.get('color', QtGui.QColor("#4caf50"))
            
            # Validate and clamp values to 0-24 range
            start = max(0.0, min(24.0, start))
            end = max(0.0, min(24.0, end))
            
            # Skip if start == end (zero duration)
            if abs(end - start) < 0.01:
                continue
            
            # Normalize to 0-24
            # Handle wrapping
            blocks = []
            if end < start:
                blocks.append((start, 24.0))
                blocks.append((0.0, end))
            else:
                blocks.append((start, end))
                
            painter.setBrush(QtGui.QBrush(color))
            painter.setPen(QtCore.Qt.PenStyle.NoPen)
            
            for s, e in blocks:
                # Calculate coords
                x = (s / 24.0) * width
                w = ((e - s) / 24.0) * width
                
                block_rect = QtCore.QRectF(x, block_y, w, block_h)
                painter.drawRoundedRect(block_rect, 4, 4)

        # Draw Current Time Indicator
        now = datetime.now()
        curr_h = now.hour + now.minute / 60.0
        cx = int((curr_h / 24.0) * width)
        
        pen_curr = QtGui.QPen(QtGui.QColor("#ff5252"), 2)
        painter.setPen(pen_curr)
        painter.drawLine(cx, 0, cx, height)
        
        # Draw "Now" bubble
        bubble_rect = QtCore.QRectF(cx - 16, 5, 32, 16)
        painter.setBrush(QtGui.QBrush(QtGui.QColor("#ff5252")))
        painter.setPen(QtCore.Qt.PenStyle.NoPen)
        painter.drawRoundedRect(bubble_rect, 8, 8)
        
        painter.setPen(QtGui.QColor("#ffffff"))
        font = painter.font()
        font.setPixelSize(9)
        font.setBold(True)
        painter.setFont(font)
        painter.drawText(bubble_rect, QtCore.Qt.AlignmentFlag.AlignCenter, "NOW")


class DailyTimelineWidget(QtWidgets.QFrame):
    """Container widget for the Daily Timeline (Hybrid View)."""
    
    # Signals emitted when ring widgets are clicked
    water_clicked = QtCore.Signal()
    chapter_clicked = QtCore.Signal()
    focus_clicked = QtCore.Signal()
    xp_clicked = QtCore.Signal()
    entities_clicked = QtCore.Signal()
    hero_clicked = QtCore.Signal()
    eye_clicked = QtCore.Signal()
    
    def __init__(self, blocker: 'BlockerCore', parent=None):
        super().__init__(parent)
        self.blocker = blocker
        self.setObjectName("DailyTimeline")
        self.setStyleSheet("""
            #DailyTimeline {
                background-color: #1a1a2e;
                border-bottom: 1px solid #2a2a4a;
            }
        """)
        self.setFixedHeight(110)
        
        self._init_ui()
        
        # Timer for fallback periodic updates (reduced frequency since signals handle most updates)
        self.timer = QtCore.QTimer(self)
        self.timer.timeout.connect(self._update_timeline_events)  # Only update timeline events on timer
        self.timer.start(60000)  # Every 60 seconds (just for timeline events)
        self.destroyed.connect(self._cleanup_timer)
        
        # Connect to GameState signals for efficient updates
        self._connect_game_state_signals()
        
        # CRITICAL: Immediately populate data from blocker (sync call)
        # This ensures rings show correct values even if window starts hidden
        self._do_immediate_data_load()
        
        # Also schedule a delayed update as backup (in case data wasn't fully ready)
        QtCore.QTimer.singleShot(500, self.update_data)
        QtCore.QTimer.singleShot(1500, self.update_data)  # Second backup
    
    def _do_immediate_data_load(self):
        """Load data immediately during init - synchronous, no visibility check."""
        try:
            # Water
            self._update_water_ring()
            # Focus
            self._update_focus_ring()
            # Chapter
            self._update_chapter_ring()
            # XP
            self._update_xp_ring()
            # Entities
            self._update_entities_ring()
            # Eye
            self._update_eye_ring()
        except Exception as e:
            logger.error(f"[Timeline] _do_immediate_data_load error: {e}")
    
    
    def _connect_game_state_signals(self):
        """Connect to GameState signals for instant ring updates."""
        try:
            from game_state import get_game_state
            game_state = get_game_state()
            if game_state:
                # Store reference for later disconnect
                self._game_state = game_state
                
                # Hero updates
                game_state.equipment_changed.connect(self._update_mini_hero)
                game_state.power_changed.connect(self._update_mini_hero)
                game_state.story_changed.connect(self._update_mini_hero)
                
                # XP ring updates
                game_state.xp_changed.connect(self._update_xp_ring)
                
                # Chapter ring updates (power changes can unlock chapters)
                game_state.power_changed.connect(self._update_chapter_ring)
                game_state.story_changed.connect(self._update_chapter_ring)
                
                # Water ring updates
                game_state.water_changed.connect(self._update_water_ring)
                
                # Focus ring updates
                game_state.focus_time_changed.connect(self._update_focus_ring)
                game_state.session_reward_earned.connect(self._update_focus_ring)
                
                # Entities ring updates (only entities_changed to avoid double updates
                # since notify_entity_collected emits both entity_collected and entities_changed)
                game_state.entities_changed.connect(self._update_entities_ring)
                
                # Eye ring updates
                game_state.eye_routine_changed.connect(self._update_eye_ring)
                
                # Full refresh fallback
                game_state.full_refresh_required.connect(self.update_data)
        except Exception:
            pass  # Fall back to timer-based updates
    
    def _disconnect_game_state_signals(self):
        """Disconnect from old game state signals (for user switching)."""
        try:
            if hasattr(self, '_game_state') and self._game_state:
                gs = self._game_state
                gs.equipment_changed.disconnect(self._update_mini_hero)
                gs.power_changed.disconnect(self._update_mini_hero)
                gs.story_changed.disconnect(self._update_mini_hero)
                gs.xp_changed.disconnect(self._update_xp_ring)
                gs.power_changed.disconnect(self._update_chapter_ring)
                gs.story_changed.disconnect(self._update_chapter_ring)
                gs.water_changed.disconnect(self._update_water_ring)
                gs.focus_time_changed.disconnect(self._update_focus_ring)
                gs.session_reward_earned.disconnect(self._update_focus_ring)
                gs.entities_changed.disconnect(self._update_entities_ring)
                gs.eye_routine_changed.disconnect(self._update_eye_ring)
                gs.full_refresh_required.disconnect(self.update_data)
                self._game_state = None
        except Exception:
            pass
    
    def reconnect_game_state(self):
        """Reconnect to new game state after user switch."""
        self._disconnect_game_state_signals()
        self._connect_game_state_signals()
        self.update_data()

    def _update_mini_hero(self, *args):
        """Update the mini hero widget with current data."""
        try:
            if hasattr(self, 'mini_hero') and hasattr(self.blocker, 'adhd_buster') and self.blocker.adhd_buster:
                equipped = self.blocker.adhd_buster.get("equipped", {})
                active_story = self.blocker.adhd_buster.get("active_story", "warrior")
                if GAMIFICATION_AVAILABLE and calculate_character_power:
                    power = calculate_character_power(self.blocker.adhd_buster)
                else:
                    power = sum(item.get("power", 0) for item in equipped.values() if item)
                self.mini_hero.set_hero_data(equipped, power, active_story)
        except Exception as e:
            logger.debug(f"[Timeline] _update_mini_hero error: {e}")
    
    def _update_focus_ring(self, *args):
        """Update focus ring from signal."""
        try:
            from app_utils import get_activity_date
            # Use activity date (5 AM cutoff) for daily tracking
            today = get_activity_date()
            daily_stats = self.blocker.stats.get("daily_stats", {}).get(today, {})
            focus_sec = daily_stats.get("focus_time", 0)
            weekly_goal_hours = float(self.blocker.stats.get("weekly_goal_hours", 10))
            goal_sec = int((weekly_goal_hours / 7) * 3600)
            self.focus_ring.set_progress(focus_sec, goal_sec)
        except Exception as e:
            logger.debug(f"[Timeline] _update_focus_ring error: {e}")
    
    def _update_water_ring(self, *args):
        """Update water ring from signal."""
        try:
            from app_utils import get_activity_date
            activity_date = get_activity_date()
            water_entries = getattr(self.blocker, 'water_entries', [])
            today_water = sum(1 for e in water_entries if e.get('date') == activity_date)
            daily_cap = 8
            if hasattr(self.blocker, 'adhd_buster') and self.blocker.adhd_buster:
                try:
                    from gamification import get_hydration_daily_cap
                    daily_cap = get_hydration_daily_cap(self.blocker.adhd_buster)
                except Exception:
                    pass
            self.water_ring.set_progress(today_water, daily_cap)
        except Exception as e:
            logger.debug(f"[Timeline] _update_water_ring error: {e}")
    
    def _update_chapter_ring(self, *args):
        """Update chapter ring from signal."""
        try:
            if hasattr(self.blocker, 'adhd_buster') and self.blocker.adhd_buster:
                from gamification import get_story_progress
                story = get_story_progress(self.blocker.adhd_buster)
                unlocked = len(story.get('unlocked_chapters', []))
                total = story.get('total_chapters', 7)
                if story.get('next_threshold'):
                    prev_threshold = story.get('prev_threshold', 0)
                    next_threshold = story['next_threshold']
                    current_power = story.get('power', 0)
                    range_size = next_threshold - prev_threshold
                    if range_size > 0:
                        progress_in_range = current_power - prev_threshold
                        chapter_progress = (progress_in_range / range_size) * 100
                        chapter_progress = max(0, min(100, chapter_progress))
                    else:
                        chapter_progress = 100.0
                    is_complete = False
                else:
                    chapter_progress = 100.0
                    is_complete = True
                self.chapter_ring.set_progress(unlocked, chapter_progress, total, is_complete)
        except Exception as e:
            logger.debug(f"[Timeline] _update_chapter_ring error: {e}")
    
    def _update_xp_ring(self, *args):
        """Update XP ring from signal."""
        try:
            if hasattr(self.blocker, 'adhd_buster') and self.blocker.adhd_buster:
                total_xp = self.blocker.adhd_buster.get("total_xp", 0)
                if get_level_from_xp:
                    level, xp_in_level, xp_needed, progress = get_level_from_xp(total_xp)
                    self.xp_ring.set_progress(level, xp_in_level, xp_needed, total_xp)
                    self.xp_ring.setVisible(True)
        except Exception as e:
            logger.debug(f"[Timeline] _update_xp_ring error: {e}")
    
    def _update_entities_ring(self, *args):
        """Update entities ring from signal."""
        try:
            if hasattr(self.blocker, 'adhd_buster') and self.blocker.adhd_buster:
                entitidex_data = self.blocker.adhd_buster.get("entitidex", {})
                collected = set(entitidex_data.get("collected_entity_ids", []))
                exceptional_entities = entitidex_data.get("exceptional_entities", {})
                exceptional_ids = set(exceptional_entities.keys()) if isinstance(exceptional_entities, dict) else set(exceptional_entities)
                
                # Count normal and exceptional correctly (they're independent)
                normal_count = len(collected)
                exceptional_count = len(exceptional_ids)
                total_possible = 45  # Total entities per theme (9 entities * 5 themes)
                self.entities_ring.set_progress(normal_count, exceptional_count, total_possible)
                self.entities_ring.setVisible(True)
        except Exception as e:
            logger.debug(f"[Timeline] _update_entities_ring error: {e}")
    
    def _update_eye_ring(self, *args):
        """Update eye ring from signal or timer."""
        try:
            from app_utils import get_activity_date
            from eye_protection_tab import BASE_EYE_REST_CAP
            
            # Get current daily count using 5 AM cutoff (same logic as eye_protection_tab)
            eye_stats = self.blocker.stats.get("eye_protection", {})
            
            # Parse the saved datetime
            last_date_str = eye_stats.get("last_date", "")
            current_count = 0
            
            if last_date_str:
                try:
                    from datetime import datetime, timedelta
                    last_dt = datetime.fromisoformat(last_date_str)
                    now = datetime.now()
                    
                    # Calculate 5 AM cutoff for today (or yesterday if before 5 AM)
                    if now.hour < 5:
                        current_day_start = now.replace(hour=5, minute=0, second=0, microsecond=0) - timedelta(days=1)
                    else:
                        current_day_start = now.replace(hour=5, minute=0, second=0, microsecond=0)
                    
                    # If last routine was within current "activity day", show the count
                    if last_dt >= current_day_start:
                        current_count = eye_stats.get("daily_count", 0)
                except (ValueError, TypeError):
                    current_count = 0
            
            # Calculate daily cap (base + entity perk bonus)
            daily_cap = BASE_EYE_REST_CAP
            if hasattr(self.blocker, 'adhd_buster') and self.blocker.adhd_buster:
                try:
                    from gamification import get_qol_perks_summary
                    qol_perks = get_qol_perks_summary(self.blocker.adhd_buster)
                    daily_cap += qol_perks.get("eye_rest_cap", 0)
                except Exception:
                    pass
            
            self.eye_ring.set_progress(current_count, daily_cap)
            self.eye_ring.setVisible(True)
        except Exception as e:
            logger.debug(f"[Timeline] _update_eye_ring error: {e}")
    
    def _update_timeline_events(self):
        """Update just the timeline events (called on timer)."""
        if not self.isVisible():
            return
        self._refresh_timeline_events()
    
    def _cleanup_timer(self):
        """Stop timer and disconnect signals when widget is destroyed."""
        if hasattr(self, 'timer') and self.timer:
            self.timer.stop()
        # Disconnect from stored game state reference
        self._disconnect_game_state_signals()

    def _init_ui(self):
        layout = QtWidgets.QHBoxLayout(self)
        layout.setContentsMargins(15, 10, 15, 10)
        layout.setSpacing(12)
        
        # Mini Hero Widget (first element - shows equipped character)
        self.mini_hero = MiniHeroWidget()
        self.mini_hero.setFixedSize(70, 90)
        self.mini_hero.clicked.connect(self.hero_clicked.emit)
        layout.addWidget(self.mini_hero)
        
        # Separator between hero and rings
        hero_sep = QtWidgets.QFrame()
        hero_sep.setFrameShape(QtWidgets.QFrame.Shape.VLine)
        hero_sep.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        hero_sep.setStyleSheet("background-color: #3a3a5a;")
        layout.addWidget(hero_sep)
        
        # Ring widgets in order: Water, Chapter, Focus, Entities, XP
        
        # Water Ring
        self.water_ring = WaterRingWidget()
        self.water_ring.setFixedSize(70, 70)
        self.water_ring.clicked.connect(self.water_clicked.emit)
        layout.addWidget(self.water_ring)
        
        # Chapter Ring
        self.chapter_ring = ChapterRingWidget()
        self.chapter_ring.setFixedSize(70, 70)
        self.chapter_ring.clicked.connect(self.chapter_clicked.emit)
        layout.addWidget(self.chapter_ring)
        
        # Focus Ring
        self.focus_ring = FocusRingWidget()
        self.focus_ring.setFixedSize(70, 70)
        self.focus_ring.clicked.connect(self.focus_clicked.emit)
        layout.addWidget(self.focus_ring)
        
        # Entities Ring (Entitidex bonded count)
        self.entities_ring = EntitiesRingWidget()
        self.entities_ring.setFixedSize(70, 70)
        self.entities_ring.clicked.connect(self.entities_clicked.emit)
        layout.addWidget(self.entities_ring)
        
        # XP Ring
        self.xp_ring = XPRingWidget()
        self.xp_ring.setFixedSize(70, 70)
        self.xp_ring.clicked.connect(self.xp_clicked.emit)
        layout.addWidget(self.xp_ring)
        
        # Eye Ring (Eye & Breath routines)
        self.eye_ring = EyeRingWidget()
        self.eye_ring.setFixedSize(70, 70)
        self.eye_ring.clicked.connect(self.eye_clicked.emit)
        layout.addWidget(self.eye_ring)
        
        # Separator
        line = QtWidgets.QFrame()
        line.setFrameShape(QtWidgets.QFrame.Shape.VLine)
        line.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        line.setStyleSheet("background-color: #2a2a4a;")
        layout.addWidget(line)
        
        # 2. Chrono-Stream
        self.timeline = ChronoStreamWidget()
        layout.addWidget(self.timeline, stretch=1)

    def showEvent(self, event):
        """Refresh data when widget becomes visible."""
        super().showEvent(event)
        # Force update when shown to ensure no stale data from startup/minimized state
        QtCore.QTimer.singleShot(0, self.update_data)

    def update_data(self):
        """Update all timeline data. Called on initial load and full refresh.
        
        Individual rings are updated via GameState signals for efficiency.
        This method is for initial load and full refresh fallback.
        """
        # Debug logging to trace when updates happen
        logger.debug("[Timeline] update_data called")
        
        # Verify blocker data is loaded
        if not hasattr(self, 'blocker') or not self.blocker:
            logger.warning("[Timeline] update_data called but blocker not available")
            return
        
        # Log data state for debugging
        adhd_buster = getattr(self.blocker, 'adhd_buster', None)
        if adhd_buster:
            logger.debug(f"[Timeline] adhd_buster keys: {list(adhd_buster.keys())}")
            logger.debug(f"[Timeline] total_xp={adhd_buster.get('total_xp', 0)}, coins={adhd_buster.get('coins', 0)}")
            entitidex = adhd_buster.get('entitidex', {})
            logger.debug(f"[Timeline] entitidex collected_entity_ids count: {len(entitidex.get('collected_entity_ids', []))}")
        else:
            logger.warning("[Timeline] adhd_buster is None or missing")
        
        # Update all rings (initial load / fallback)
        self._update_mini_hero()
        self._update_focus_ring()
        self._update_water_ring()
        self._update_chapter_ring()
        self._update_xp_ring()
        self._update_entities_ring()
        self._update_eye_ring()
        self._refresh_timeline_events()
    
    def _refresh_timeline_events(self):
        """Refresh the timeline events (sleep, water, focus sessions)."""
        events = []
        
        today_date = datetime.now().date()
        yesterday_date = today_date - timedelta(days=1)
        today_str = today_date.strftime("%Y-%m-%d")
        yesterday_str = yesterday_date.strftime("%Y-%m-%d")

        # Add sleep events
        try:
            sleep_entries = getattr(self.blocker, 'sleep_entries', [])
            for entry in sleep_entries:
                entry_date = entry.get('date')
                bedtime_str = entry.get('bedtime')
                waketime_str = entry.get('wake_time')
                
                if not (bedtime_str and waketime_str): 
                    continue
                    
                # Convert times to floats
                try:
                    bh, bm = map(int, bedtime_str.split(':'))
                    wh, wm = map(int, waketime_str.split(':'))
                    
                    # Validate time ranges
                    if not (0 <= bh <= 23 and 0 <= bm <= 59 and 0 <= wh <= 23 and 0 <= wm <= 59):
                        continue
                    
                    b_float = bh + bm/60.0
                    w_float = wh + wm/60.0
                except (ValueError, AttributeError, TypeError):
                    continue

                if entry_date == yesterday_str:
                    # Sleep started yesterday. Ends today?
                    if w_float < b_float:
                        # Ends today (standard sleep)
                        events.append({
                            'start': 0.0,
                            'end': w_float,
                            'color': QtGui.QColor("#3949ab"), # Indigo
                            'label': 'Sleep'
                        })
                
                elif entry_date == today_str:
                    # Sleep starts today
                    if w_float < b_float:
                        # Wraps to tomorrow
                        events.append({
                            'start': b_float,
                            'end': 24.0,
                            'color': QtGui.QColor("#3949ab"),
                            'label': 'Sleep'
                        })
                    else:
                        # Nap
                        events.append({
                            'start': b_float,
                            'end': w_float,
                            'color': QtGui.QColor("#3949ab"),
                            'label': 'Nap'
                        })
        except Exception as e:
            pass 

        # Add water events (mark moments when water was logged)
        try:
            water_entries = getattr(self.blocker, 'water_entries', [])
            for entry in water_entries:
                entry_date = entry.get('date')
                entry_time = entry.get('time')
                
                if entry_date == today_str and entry_time:
                    try:
                        # Parse time
                        h, m = map(int, entry_time.split(':'))
                        if 0 <= h <= 23 and 0 <= m <= 59:
                            time_float = h + m/60.0
                            # Show as a 5-minute block
                            events.append({
                                'start': time_float,
                                'end': min(time_float + 5/60.0, 24.0),
                                'color': QtGui.QColor("#4fc3f7"), # Cyan
                                'label': 'üíß Water'
                            })
                    except (ValueError, AttributeError, TypeError):
                        continue
        except Exception:
            pass

        # Add active focus session (if currently running)
        try:
            if hasattr(self.blocker, 'session_start') and self.blocker.session_start:
                session_start_ts = self.blocker.session_start
                now_ts = QtCore.QDateTime.currentDateTime().toSecsSinceEpoch()
                
                # Convert to datetime objects
                session_start_dt = datetime.fromtimestamp(session_start_ts)
                now_dt = datetime.fromtimestamp(now_ts)
                
                # Check if session started today
                if session_start_dt.date() == today_date:
                    start_hour = session_start_dt.hour + session_start_dt.minute / 60.0
                    end_hour = now_dt.hour + now_dt.minute / 60.0
                    
                    # Handle sessions that cross midnight
                    if end_hour < start_hour:
                        # Session continues past midnight - show until end of day
                        events.append({
                            'start': start_hour,
                            'end': 24.0,
                            'color': QtGui.QColor("#4caf50"), # Green for active session
                            'label': 'üéØ Focus Session (Active)'
                        })
                    else:
                        events.append({
                            'start': start_hour,
                            'end': end_hour,
                            'color': QtGui.QColor("#4caf50"), # Green for active session
                            'label': 'üéØ Focus Session (Active)'
                        })
        except Exception:
            pass

        self.timeline.set_events(events)


class StoryTab(QtWidgets.QWidget):
    """Tab for story mode, chapter selection, and story progress tracking."""

    def __init__(self, blocker, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.blocker = blocker
        
        # Connect to game state manager for reactive updates
        self._game_state = get_game_state()
        if self._game_state:
            self._game_state.story_changed.connect(self._on_story_changed)
            self._game_state.power_changed.connect(self._on_power_changed)
        
        self._build_ui()
        self._refresh_all()
    
    def _build_ui(self) -> None:
        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(15)
        
        # === Story Mode Selection ===
        mode_group = QtWidgets.QGroupBox("üìú Story Mode")
        mode_layout = QtWidgets.QVBoxLayout(mode_group)
        
        if GAMIFICATION_AVAILABLE:
            mode_bar = QtWidgets.QHBoxLayout()
            mode_bar.addWidget(QtWidgets.QLabel("Mode:"))
            self.mode_story_radio = QtWidgets.QRadioButton("Story")
            self.mode_hero_radio = QtWidgets.QRadioButton("Hero Only")
            self.mode_disabled_radio = QtWidgets.QRadioButton("Disabled")
            mode_group_btns = QtWidgets.QButtonGroup(self)
            for btn in (self.mode_story_radio, self.mode_hero_radio, self.mode_disabled_radio):
                mode_group_btns.addButton(btn)
                mode_bar.addWidget(btn)
            
            # Set current mode
            current_mode = get_story_mode(self.blocker.adhd_buster)
            if current_mode == STORY_MODE_HERO_ONLY:
                self.mode_hero_radio.setChecked(True)
            elif current_mode == STORY_MODE_DISABLED:
                self.mode_disabled_radio.setChecked(True)
            else:
                self.mode_story_radio.setChecked(True)
            
            # Connect signals
            self.mode_story_radio.toggled.connect(lambda checked: checked and self._on_mode_radio_changed())
            self.mode_hero_radio.toggled.connect(lambda checked: checked and self._on_mode_radio_changed())
            self.mode_disabled_radio.toggled.connect(lambda checked: checked and self._on_mode_radio_changed())
            mode_bar.addStretch()
            mode_layout.addLayout(mode_bar)
            
            # Mode description
            mode_desc = QtWidgets.QLabel(
                "<i>Story: Full story progression with chapters ‚Ä¢ "
                "Hero Only: Just the character and gear ‚Ä¢ "
                "Disabled: No gamification features</i>"
            )
            mode_desc.setStyleSheet("color: #666; font-size: 11px;")
            mode_desc.setWordWrap(True)
            mode_layout.addWidget(mode_desc)
        
        layout.addWidget(mode_group)
        
        # === Story Selection ===
        story_group = QtWidgets.QGroupBox("üìñ Choose Your Story")
        story_layout = QtWidgets.QVBoxLayout(story_group)
        
        if GAMIFICATION_AVAILABLE:
            from gamification import AVAILABLE_STORIES, get_selected_story
            
            story_select_bar = QtWidgets.QHBoxLayout()
            self.story_combo = NoScrollComboBox()
            self.story_combo.setMinimumWidth(300)
            
            current_story = get_selected_story(self.blocker.adhd_buster)
            unlocked_stories = self.blocker.adhd_buster.get("unlocked_stories", ["underdog"])
            current_idx = 0
            for i, (story_id, story_info) in enumerate(AVAILABLE_STORIES.items()):
                is_locked = story_id not in unlocked_stories
                lock_icon = "üîí " if is_locked else ""
                self.story_combo.addItem(f"{lock_icon}{story_info['title']}", story_id)
                tooltip = story_info['description']
                if is_locked:
                    tooltip += "\n\nüîí Costs 100 coins to unlock"
                self.story_combo.setItemData(i, tooltip, QtCore.Qt.ToolTipRole)
                if story_id == current_story:
                    current_idx = i
            
            self.story_combo.setCurrentIndex(current_idx)
            self.story_combo.currentIndexChanged.connect(self._on_story_change)
            story_select_bar.addWidget(self.story_combo)
            
            # Restart Story button
            self.restart_story_btn = QtWidgets.QPushButton("üîÑ Restart Story")
            self.restart_story_btn.setToolTip("Reset this story's hero - lose all gear, progress, and decisions")
            self.restart_story_btn.setStyleSheet("color: #c62828;")
            self.restart_story_btn.clicked.connect(self._on_restart_story)
            story_select_bar.addWidget(self.restart_story_btn)
            
            story_select_bar.addStretch()
            story_layout.addLayout(story_select_bar)
            
            # Story description
            self.story_desc_lbl = QtWidgets.QLabel()
            self.story_desc_lbl.setWordWrap(True)
            self.story_desc_lbl.setStyleSheet("color: #888; font-style: italic; padding: 10px; font-size: 12px;")
            self._update_story_description()
            story_layout.addWidget(self.story_desc_lbl)
        
        layout.addWidget(story_group)
        
        # === Story Progress ===
        progress_group = QtWidgets.QGroupBox("üìä Story Progress")
        progress_layout = QtWidgets.QVBoxLayout(progress_group)
        
        if GAMIFICATION_AVAILABLE:
            from gamification import get_story_progress
            
            self.story_progress_lbl = QtWidgets.QLabel()
            self.story_progress_lbl.setStyleSheet("font-weight: bold; font-size: 13px;")
            progress_layout.addWidget(self.story_progress_lbl)
            
            self.story_next_lbl = QtWidgets.QLabel()
            self.story_next_lbl.setStyleSheet("color: #666;")
            progress_layout.addWidget(self.story_next_lbl)
            
            # Progress bar for next chapter
            progress_bar_layout = QtWidgets.QHBoxLayout()
            progress_bar_layout.addWidget(QtWidgets.QLabel("Progress to Next Chapter:"))
            self.chapter_progress_bar = QtWidgets.QProgressBar()
            self.chapter_progress_bar.setMinimum(0)
            self.chapter_progress_bar.setMaximum(100)
            self.chapter_progress_bar.setTextVisible(True)
            self.chapter_progress_bar.setStyleSheet("""
                QProgressBar {
                    border: 1px solid #444;
                    border-radius: 5px;
                    text-align: center;
                    height: 20px;
                }
                QProgressBar::chunk {
                    background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                        stop:0 #4caf50, stop:0.5 #8bc34a, stop:1 #cddc39);
                    border-radius: 4px;
                }
            """)
            progress_bar_layout.addWidget(self.chapter_progress_bar, 1)
            progress_layout.addLayout(progress_bar_layout)
            
            self._update_story_progress_labels()
        
        layout.addWidget(progress_group)
        
        # === Chapter Selection ===
        chapter_group = QtWidgets.QGroupBox("üìö Chapters")
        chapter_layout = QtWidgets.QVBoxLayout(chapter_group)
        
        chapter_bar = QtWidgets.QHBoxLayout()
        chapter_bar.addWidget(QtWidgets.QLabel("Select Chapter:"))
        self.chapter_combo = NoScrollComboBox()
        self.chapter_combo.setMinimumWidth(300)
        
        if GAMIFICATION_AVAILABLE:
            self._refresh_story_chapter_list()
        else:
            self.chapter_combo.addItem("Story unavailable", 0)
        
        chapter_bar.addWidget(self.chapter_combo)
        read_btn = QtWidgets.QPushButton("üìñ Read Chapter")
        read_btn.clicked.connect(self._read_story_chapter)
        chapter_bar.addWidget(read_btn)
        chapter_bar.addStretch()
        chapter_layout.addLayout(chapter_bar)
        
        layout.addWidget(chapter_group)
        
        # Update mode UI state
        if GAMIFICATION_AVAILABLE:
            self._update_mode_ui_state()
        
        layout.addStretch()
    
    # === Signal Handlers ===
    
    def _on_story_changed(self, story_id: str) -> None:
        """Handle story change signal from game state."""
        self._refresh_all()
    
    def _on_power_changed(self, new_power: int) -> None:
        """Handle power change - update progress labels."""
        self._update_story_progress_labels()
        self._refresh_story_chapter_list()
    
    # === UI Update Methods ===
    
    def _refresh_all(self) -> None:
        """Refresh all story UI elements."""
        self._sync_story_combo_selection()
        self._update_story_description()
        self._update_story_progress_labels()
        self._refresh_story_chapter_list()
        self._update_mode_ui_state()
    
    def _sync_story_combo_selection(self) -> None:
        """Sync the story combo box selection with the current active story."""
        if not GAMIFICATION_AVAILABLE or not hasattr(self, 'story_combo'):
            return
        from gamification import get_selected_story
        current_story = get_selected_story(self.blocker.adhd_buster)
        self.story_combo.blockSignals(True)
        for i in range(self.story_combo.count()):
            if self.story_combo.itemData(i) == current_story:
                self.story_combo.setCurrentIndex(i)
                break
        self.story_combo.blockSignals(False)
    
    def _update_story_description(self) -> None:
        """Update the story description label."""
        if not GAMIFICATION_AVAILABLE or not hasattr(self, 'story_desc_lbl'):
            return
        from gamification import AVAILABLE_STORIES, get_selected_story
        story_id = get_selected_story(self.blocker.adhd_buster)
        story_info = AVAILABLE_STORIES.get(story_id, {})
        self.story_desc_lbl.setText(f"üìñ {story_info.get('description', '')}")
    
    def _update_story_progress_labels(self) -> None:
        """Update story progress labels and progress bar."""
        if not GAMIFICATION_AVAILABLE:
            return
        
        from gamification import get_story_progress, get_selected_story
        progress = get_story_progress(self.blocker.adhd_buster)
        
        # Check if in preview mode (story not unlocked)
        story_id = get_selected_story(self.blocker.adhd_buster)
        unlocked_stories = self.blocker.adhd_buster.get("unlocked_stories", ["underdog"])
        is_preview = story_id not in unlocked_stories
        
        if hasattr(self, 'story_progress_lbl'):
            if is_preview:
                self.story_progress_lbl.setText(
                    f"üëÅÔ∏è PREVIEW MODE  |  üìñ Chapter 1 FREE  |  üí∞ Unlock for full story"
                )
                self.story_progress_lbl.setStyleSheet("color: #ff9800; font-weight: bold;")
            else:
                self.story_progress_lbl.setText(
                    f"üìñ Chapters Unlocked: {len(progress['unlocked_chapters'])}/{progress['total_chapters']}  |  "
                    f"‚öî Power: {progress['power']}  |  "
                    f"‚ö° Decisions: {progress['decisions_made']}/3"
                )
                self.story_progress_lbl.setStyleSheet("")
        
        if hasattr(self, 'story_next_lbl'):
            if is_preview:
                self.story_next_lbl.setText(
                    "üí° Read Chapter 1 to try this story, then unlock to continue the adventure!"
                )
                self.story_next_lbl.setStyleSheet("color: #2196f3;")
            elif progress['next_threshold']:
                self.story_next_lbl.setText(
                    f"üîí Next chapter unlocks at {progress['next_threshold']} power "
                    f"({progress['power_to_next']} more needed)"
                )
                self.story_next_lbl.setStyleSheet("color: #666;")
            else:
                self.story_next_lbl.setText("‚ú® You have unlocked the entire story!")
                self.story_next_lbl.setStyleSheet("color: #4caf50; font-weight: bold;")
        
        # Update progress bar
        if hasattr(self, 'chapter_progress_bar'):
            if progress['next_threshold']:
                prev_threshold = progress.get('prev_threshold', 0)
                range_size = progress['next_threshold'] - prev_threshold
                current_in_range = progress['power'] - prev_threshold
                percentage = int((current_in_range / range_size) * 100) if range_size > 0 else 0
                percentage = max(0, min(100, percentage))
                self.chapter_progress_bar.setValue(percentage)
                self.chapter_progress_bar.setFormat(f"{percentage}%")
            else:
                self.chapter_progress_bar.setValue(100)
                self.chapter_progress_bar.setFormat("Complete!")
    
    def _refresh_story_chapter_list(self) -> None:
        """Refresh the story chapter dropdown to reflect decisions made."""
        if not GAMIFICATION_AVAILABLE or not hasattr(self, 'chapter_combo'):
            return
        
        from gamification import get_story_progress
        progress = get_story_progress(self.blocker.adhd_buster)
        
        self.chapter_combo.clear()
        for ch in progress["chapters"]:
            emoji = "‚úÖ" if ch["unlocked"] else "üîí"
            decision_marker = ""
            if ch.get("has_decision"):
                if ch.get("decision_made"):
                    decision_marker = " ‚úì"  # Decision already made
                elif ch.get("unlocked"):
                    decision_marker = " ‚ö°"  # Pending decision
                # If locked, don't show decision marker
            
            self.chapter_combo.addItem(
                f"{emoji} {ch['title']}{decision_marker}",
                ch["number"]
            )
    
    def _refresh_story_combo(self) -> None:
        """Refresh story combo to show updated lock status."""
        if not GAMIFICATION_AVAILABLE or not hasattr(self, 'story_combo'):
            return
        
        from gamification import AVAILABLE_STORIES, get_selected_story
        
        current_story = get_selected_story(self.blocker.adhd_buster)
        unlocked_stories = self.blocker.adhd_buster.get("unlocked_stories", ["underdog"])
        
        self.story_combo.blockSignals(True)
        self.story_combo.clear()
        
        current_idx = 0
        for i, (story_id, story_info) in enumerate(AVAILABLE_STORIES.items()):
            is_locked = story_id not in unlocked_stories
            lock_icon = "üìñ " if not is_locked else "üëÅÔ∏è "
            self.story_combo.addItem(f"{lock_icon}{story_info['title']}", story_id)
            tooltip = story_info['description']
            if is_locked:
                tooltip += "\n\nüëÅÔ∏è PREVIEW: Chapter 1 FREE!\nüí∞ Unlock full story: 100 coins"
            else:
                tooltip += "\n\nüìñ UNLOCKED: Full story access"
            self.story_combo.setItemData(i, tooltip, QtCore.Qt.ToolTipRole)
            if story_id == current_story:
                current_idx = i
        
        self.story_combo.setCurrentIndex(current_idx)
        self.story_combo.blockSignals(False)
    
    def _update_mode_ui_state(self) -> None:
        """Update UI elements based on current mode."""
        if not GAMIFICATION_AVAILABLE:
            return
        current_mode = get_story_mode(self.blocker.adhd_buster)
        story_mode = current_mode == STORY_MODE_ACTIVE
        
        # Sync radio button selection
        if hasattr(self, 'mode_story_radio'):
            self.mode_story_radio.blockSignals(True)
            self.mode_hero_radio.blockSignals(True)
            self.mode_disabled_radio.blockSignals(True)
            
            if current_mode == STORY_MODE_HERO_ONLY:
                self.mode_hero_radio.setChecked(True)
            elif current_mode == STORY_MODE_DISABLED:
                self.mode_disabled_radio.setChecked(True)
            else:
                self.mode_story_radio.setChecked(True)
            
            self.mode_story_radio.blockSignals(False)
            self.mode_hero_radio.blockSignals(False)
            self.mode_disabled_radio.blockSignals(False)
        
        # Enable story combo only in story mode
        if hasattr(self, 'story_combo'):
            self.story_combo.setEnabled(story_mode)
        if hasattr(self, 'chapter_combo'):
            self.chapter_combo.setEnabled(story_mode)
    
    # === Action Handlers ===
    
    def _on_story_change(self, index: int) -> None:
        """Handle story selection change."""
        if not GAMIFICATION_AVAILABLE:
            return
        
        story_id = self.story_combo.currentData()
        if not story_id:
            return
        
        from gamification import select_story, get_selected_story, AVAILABLE_STORIES
        current = get_selected_story(self.blocker.adhd_buster)
        
        if story_id != current:
            unlocked_stories = self.blocker.adhd_buster.get("unlocked_stories", ["underdog"])
            is_preview = story_id not in unlocked_stories
            
            story_info = AVAILABLE_STORIES.get(story_id, {})
            story_title = story_info.get("title", story_id)
            
            if is_preview:
                # Preview mode - can read Chapter 1 for free
                reply = show_question(
                    self, "Preview Story",
                    f"üìñ Preview '{story_title}'\n\n"
                    f"Chapter 1 is FREE to read!\n"
                    f"Unlock the full story (100 coins) to:\n"
                    f"  ‚Ä¢ Progress to chapters 2-7\n"
                    f"  ‚Ä¢ Make story decisions\n"
                    f"  ‚Ä¢ Discover all 8 endings\n\n"
                    f"Try Chapter 1 now?",
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
                )
                if reply != QtWidgets.QMessageBox.Yes:
                    self._sync_story_combo_selection()
                    return
            else:
                reply = show_question(
                    self, "Switch Story?",
                    f"Each story has its own hero with separate gear and progress.\n\n"
                    f"Switching will load your hero for this story.\n"
                    f"(Your current hero's progress will be saved.)\n\n"
                    f"Switch to the new story?",
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
                )
                if reply != QtWidgets.QMessageBox.Yes:
                    self._sync_story_combo_selection()
                    return
        
        select_story(self.blocker.adhd_buster, story_id)
        self.blocker.save_config()
        
        if self._game_state:
            self._game_state.set_story(story_id)
        
        self._refresh_all()
    
    def _on_restart_story(self) -> None:
        """Handle restart story button click."""
        if not GAMIFICATION_AVAILABLE:
            return
        
        from gamification import restart_story, get_selected_story, AVAILABLE_STORIES
        
        story_id = get_selected_story(self.blocker.adhd_buster)
        story_info = AVAILABLE_STORIES.get(story_id, {})
        story_title = story_info.get("title", story_id)
        
        reply = show_question(
            self, "‚ö†Ô∏è Restart Story?",
            f"Are you sure you want to RESTART '{story_title}'?\n\n"
            f"This will DELETE:\n"
            f"  ‚ùå All gear and inventory for this story\n"
            f"  ‚ùå All story decisions and progress\n"
            f"  ‚ùå All chapters unlocked\n\n"
            f"Your hero will start from Chapter 1 with nothing.\n\n"
            f"This CANNOT be undone!",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            QtWidgets.QMessageBox.No
        )
        
        if reply != QtWidgets.QMessageBox.Yes:
            return
        
        confirm = show_question(
            self, "Final Confirmation",
            f"Type of restart: FULL RESET\n\n"
            f"Really delete all progress for '{story_title}'?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            QtWidgets.QMessageBox.No
        )
        
        if confirm != QtWidgets.QMessageBox.Yes:
            return
        
        success = restart_story(self.blocker.adhd_buster, story_id)
        
        if success:
            self.blocker.save_config()
            
            if self._game_state:
                self._game_state.set_story(story_id)
            
            self._refresh_all()
            
            show_info(
                self, "Story Restarted",
                f"'{story_title}' has been reset!\n\n"
                f"Your hero begins anew at Chapter 1.\n"
                f"Good luck on your fresh journey! üåü"
            )
        else:
            show_error(self, "Error", "Failed to restart story. Please try again.")
    
    def _on_mode_radio_changed(self) -> None:
        """Handle mode radio button change."""
        if not GAMIFICATION_AVAILABLE:
            return

        if self.mode_disabled_radio.isChecked():
            new_mode = STORY_MODE_DISABLED
        elif self.mode_hero_radio.isChecked():
            new_mode = STORY_MODE_HERO_ONLY
        else:
            new_mode = STORY_MODE_ACTIVE

        current_mode = get_story_mode(self.blocker.adhd_buster)
        if new_mode == current_mode:
            return

        sync_hero_data(self.blocker.adhd_buster)

        if new_mode == STORY_MODE_ACTIVE:
            story_id = self.blocker.adhd_buster.get("active_story", "warrior")
            switch_story(self.blocker.adhd_buster, story_id)
        else:
            set_story_mode(self.blocker.adhd_buster, new_mode)

        self.blocker.save_config()
        self._update_mode_ui_state()
        
        if self._game_state:
            from gamification import get_selected_story
            self._game_state.set_story(get_selected_story(self.blocker.adhd_buster))
    
    def _read_story_chapter(self) -> None:
        """Open a dialog to read the selected chapter content."""
        if not GAMIFICATION_AVAILABLE:
            return
        
        chapter_num = self.chapter_combo.currentData()
        if not chapter_num:
            return
        
        from gamification import (
            get_story_progress, get_selected_story, AVAILABLE_STORIES, 
            get_story_data, get_chapter_content, COIN_COSTS
        )
        
        progress = get_story_progress(self.blocker.adhd_buster)
        story_id = get_selected_story(self.blocker.adhd_buster)
        story_info = AVAILABLE_STORIES.get(story_id, {})
        
        # Check if story is unlocked (Chapter 1 is always free)
        unlocked_stories = self.blocker.adhd_buster.get("unlocked_stories", ["underdog"])
        story_is_unlocked = story_id in unlocked_stories
        
        # For locked stories, only Chapter 1 is available as preview
        if not story_is_unlocked and chapter_num > 1:
            STORY_UNLOCK_COST = COIN_COSTS.get("story_unlock", 100)
            current_coins = self.blocker.adhd_buster.get("coins", 0)
            story_title = story_info.get("title", story_id)
            
            if current_coins < STORY_UNLOCK_COST:
                show_warning(
                    self, "üîí Story Preview Mode",
                    f"You're previewing '{story_title}'.\n\n"
                    f"Chapter 1 is FREE! To continue to Chapter {chapter_num}:\n\n"
                    f"  üí∞ Unlock cost: {STORY_UNLOCK_COST} coins\n"
                    f"  üíµ You have: {current_coins} coins\n"
                    f"  üìà Need: {STORY_UNLOCK_COST - current_coins} more coins\n\n"
                    f"Complete focus sessions to earn coins!"
                )
                return
            
            # Offer to unlock
            reply = show_question(
                self, "üîì Unlock Full Story?",
                f"Unlock '{story_title}' for {STORY_UNLOCK_COST} coins?\n\n"
                f"This unlocks:\n"
                f"  ‚úÖ All 7 chapters\n"
                f"  ‚úÖ 3 story decisions\n"
                f"  ‚úÖ 8 unique endings\n"
                f"  ‚úÖ Full hero progression\n\n"
                f"You have: {current_coins} coins\n"
                f"After unlock: {current_coins - STORY_UNLOCK_COST} coins",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
            )
            if reply != QtWidgets.QMessageBox.Yes:
                return
            
            # Unlock the story
            if self._game_state:
                if not self._game_state.spend_coins(STORY_UNLOCK_COST):
                    show_error(self, "Error", "Failed to spend coins.")
                    return
            else:
                self.blocker.adhd_buster["coins"] = current_coins - STORY_UNLOCK_COST
            
            if "unlocked_stories" not in self.blocker.adhd_buster:
                self.blocker.adhd_buster["unlocked_stories"] = ["underdog"]
            if story_id not in self.blocker.adhd_buster["unlocked_stories"]:
                self.blocker.adhd_buster["unlocked_stories"].append(story_id)
            self.blocker.save_config()
            
            show_info(self, "Story Unlocked! üéâ", f"You've unlocked '{story_title}'!\n\nEnjoy the full adventure!")
            self._refresh_story_combo()
            # Continue to show the chapter
        
        # Get the full chapter data with content (personalized with gear and decisions)
        chapter_data = get_chapter_content(chapter_num, self.blocker.adhd_buster)
        
        if not chapter_data:
            show_error(self, "Error", "Chapter not found!")
            return
        
        if not chapter_data.get("unlocked"):
            show_warning(
                self, "Chapter Locked",
                f"This chapter requires {chapter_data.get('threshold', 0)} power to unlock.\n\n"
                f"Current power: {progress['power']}\n"
                f"Power needed: {chapter_data.get('power_needed', 0)} more\n"
                f"Keep building your hero's power!"
            )
            return
        
        # Convert markdown-style formatting to HTML
        def markdown_to_html(text: str) -> str:
            import re
            # Convert **bold** to <b>bold</b>
            text = re.sub(r'\*\*(.+?)\*\*', r'<b>\1</b>', text)
            # Convert *italic* to <i>italic</i>
            text = re.sub(r'\*(.+?)\*', r'<i>\1</i>', text)
            # Convert line breaks to HTML
            text = text.replace('\n\n', '</p><p style="margin-top: 12px;">')
            text = text.replace('\n', '<br>')
            return f'<p>{text}</p>'
        
        # Use styled frameless dialog
        dialog = StyledDialog(self, f"üìñ {story_info.get('title', 'Story')} - Chapter {chapter_num}")
        dialog.setMinimumSize(650, 550)
        layout = dialog._content_layout
        
        title_lbl = QtWidgets.QLabel(f"<h2 style='color: #f1c40f; margin-bottom: 15px;'>{chapter_data['title']}</h2>")
        title_lbl.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(title_lbl)
        
        content_scroll = QtWidgets.QScrollArea()
        content_scroll.setWidgetResizable(True)
        content_scroll.setStyleSheet("""
            QScrollArea { 
                border: none; 
                background: transparent; 
            }
            QScrollBar:vertical {
                background: #2d2d2d;
                width: 10px;
                border-radius: 5px;
            }
            QScrollBar::handle:vertical {
                background: #555;
                border-radius: 5px;
                min-height: 20px;
            }
        """)
        content_widget = QtWidgets.QWidget()
        content_widget.setStyleSheet("background: transparent;")
        content_layout = QtWidgets.QVBoxLayout(content_widget)
        content_layout.setContentsMargins(10, 10, 10, 10)
        
        # Use personalized content from get_chapter_content (includes gear and decision variations)
        raw_content = chapter_data.get("content", "No content available.")
        html_content = markdown_to_html(raw_content)
        content_lbl = QtWidgets.QLabel(html_content)
        content_lbl.setWordWrap(True)
        content_lbl.setStyleSheet("""
            font-size: 14px; 
            line-height: 1.7; 
            color: #e0e0e0;
            padding: 5px;
        """)
        content_lbl.setTextFormat(QtCore.Qt.TextFormat.RichText)
        content_layout.addWidget(content_lbl)
        content_layout.addStretch()
        
        content_scroll.setWidget(content_widget)
        layout.addWidget(content_scroll)
        
        # Container for decision section (will be updated after decision)
        decision_container = QtWidgets.QWidget()
        decision_container_layout = QtWidgets.QVBoxLayout(decision_container)
        decision_container_layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(decision_container)
        
        # Store references for inline update after decision
        dialog._decision_container = decision_container
        dialog._decision_container_layout = decision_container_layout
        dialog._content_lbl = content_lbl
        dialog._content_scroll = content_scroll
        dialog._chapter_num = chapter_num
        dialog._markdown_to_html = markdown_to_html
        
        # Use chapter_data.has_decision (from get_chapter_content) - already accounts for decision_made
        if chapter_data.get("has_decision"):
            self._show_decision_ui(dialog, chapter_num, decision_container_layout)
        
        # Add teaser for next chapter
        if chapter_data.get("next_teaser"):
            teaser_lbl = QtWidgets.QLabel(f"<p style='color: #3498db; font-style: italic; margin-top: 15px;'>üîÆ {chapter_data['next_teaser']}</p>")
            teaser_lbl.setWordWrap(True)
            teaser_lbl.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
            layout.addWidget(teaser_lbl)
        
        close_btn = QtWidgets.QPushButton("Close")
        close_btn.setStyleSheet("""
            QPushButton {
                padding: 10px 30px;
                font-size: 13px;
                background: #555;
                color: white;
                border: none;
                border-radius: 6px;
                margin-top: 10px;
            }
            QPushButton:hover {
                background: #666;
            }
        """)
        close_btn.clicked.connect(dialog.accept)
        layout.addWidget(close_btn, alignment=QtCore.Qt.AlignmentFlag.AlignCenter)
        
        dialog.exec()
    
    def _show_decision_ui(self, dialog: QtWidgets.QDialog, chapter_num: int, container_layout: QtWidgets.QVBoxLayout) -> None:
        """Show the decision UI in the chapter dialog."""
        from gamification import get_story_data
        story_decisions, _ = get_story_data(self.blocker.adhd_buster)
        decision_info = story_decisions.get(chapter_num)
        
        if not decision_info:
            return
        
        decision_frame = QtWidgets.QFrame()
        decision_frame.setStyleSheet("""
            QFrame {
                background-color: rgba(241, 196, 15, 0.1);
                border: 2px solid #f1c40f;
                border-radius: 10px;
                padding: 15px;
                margin-top: 10px;
            }
        """)
        decision_layout = QtWidgets.QVBoxLayout(decision_frame)
        
        decision_title = QtWidgets.QLabel("<h3 style='color: #f1c40f;'>‚ö° A Pivotal Decision</h3>")
        decision_title.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        decision_layout.addWidget(decision_title)
        
        decision_prompt = QtWidgets.QLabel(decision_info.get("prompt", "What will you do?"))
        decision_prompt.setWordWrap(True)
        decision_prompt.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        decision_prompt.setStyleSheet("font-size: 13px; padding: 10px; color: #fff;")
        decision_layout.addWidget(decision_prompt)
        
        btn_layout = QtWidgets.QHBoxLayout()
        for option_key, option_data in decision_info.get("choices", {}).items():
            btn = QtWidgets.QPushButton(option_data.get("label", option_key))
            btn.setStyleSheet("""
                QPushButton {
                    padding: 12px 25px; 
                    font-size: 13px;
                    background: #3498db;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    font-weight: bold;
                }
                QPushButton:hover {
                    background: #2980b9;
                }
            """)
            btn.clicked.connect(lambda checked, ok=option_key, ch=chapter_num, d=dialog: self._make_story_decision(ch, ok, d))
            btn_layout.addWidget(btn)
        decision_layout.addLayout(btn_layout)
        
        warning_lbl = QtWidgets.QLabel(
            "<p style='color: #e74c3c; font-size: 11px; text-align: center;'>"
            "‚ö†Ô∏è <b>Warning:</b> This choice is permanent and will affect your story!</p>"
        )
        warning_lbl.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        decision_layout.addWidget(warning_lbl)
        
        container_layout.addWidget(decision_frame)
    
    def _clear_layout(self, layout: QtWidgets.QLayout) -> None:
        """Clear all widgets from a layout."""
        while layout.count():
            item = layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
            elif item.layout():
                self._clear_layout(item.layout())
    
    def _make_story_decision(self, chapter_num: int, option_key: str, dialog: QtWidgets.QDialog) -> None:
        """Make a story decision for a chapter and update UI inline."""
        if not GAMIFICATION_AVAILABLE:
            return
        
        # Guard against double-clicks: check if decision already being processed
        if hasattr(dialog, '_decision_in_progress') and dialog._decision_in_progress:
            return
        dialog._decision_in_progress = True
        
        from gamification import make_story_decision, AVAILABLE_STORIES, get_selected_story, COIN_COSTS, get_chapter_content
        
        # Check if story is unlocked (decisions require unlocked story)
        story_id = get_selected_story(self.blocker.adhd_buster)
        unlocked_stories = self.blocker.adhd_buster.get("unlocked_stories", ["underdog"])
        
        if story_id not in unlocked_stories:
            STORY_UNLOCK_COST = COIN_COSTS.get("story_unlock", 100)
            current_coins = self.blocker.adhd_buster.get("coins", 0)
            story_info = AVAILABLE_STORIES.get(story_id, {})
            story_title = story_info.get("title", story_id)
            
            if current_coins < STORY_UNLOCK_COST:
                show_warning(
                    self, "üîí Preview Mode",
                    f"Decisions require unlocking the full story.\n\n"
                    f"üí∞ Unlock cost: {STORY_UNLOCK_COST} coins\n"
                    f"üíµ You have: {current_coins} coins\n"
                    f"üìà Need: {STORY_UNLOCK_COST - current_coins} more coins"
                )
                dialog._decision_in_progress = False
                return
            
            reply = show_question(
                self, "üîì Unlock to Decide?",
                f"Unlock '{story_title}' for {STORY_UNLOCK_COST} coins?\n\n"
                f"This unlocks decisions and all chapters!\n\n"
                f"You have: {current_coins} coins\n"
                f"After: {current_coins - STORY_UNLOCK_COST} coins",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
            )
            if reply != QtWidgets.QMessageBox.Yes:
                dialog._decision_in_progress = False
                return
            
            if self._game_state:
                if not self._game_state.spend_coins(STORY_UNLOCK_COST):
                    show_error(self, "Error", "Failed to spend coins.")
                    dialog._decision_in_progress = False
                    return
            else:
                self.blocker.adhd_buster["coins"] = current_coins - STORY_UNLOCK_COST
            
            if "unlocked_stories" not in self.blocker.adhd_buster:
                self.blocker.adhd_buster["unlocked_stories"] = ["underdog"]
            if story_id not in self.blocker.adhd_buster["unlocked_stories"]:
                self.blocker.adhd_buster["unlocked_stories"].append(story_id)
            self.blocker.save_config()
            self._refresh_story_combo()
            # Now continue with the decision
        
        # Call with correct 3 arguments: adhd_buster, chapter_number, choice
        result = make_story_decision(self.blocker.adhd_buster, chapter_num, option_key)
        
        if result.get("success"):
            # Reset flag now that decision is complete (buttons will be removed anyway)
            dialog._decision_in_progress = False
            
            self.blocker.save_config()
            self._refresh_story_chapter_list()
            
            # Update game state with story from result
            if self._game_state:
                story_id = result.get("story_id")
                if story_id:
                    self._game_state.set_story(story_id)
            
            # Update the UI inline - clear decision container and show outcome
            if hasattr(dialog, '_decision_container_layout'):
                self._clear_layout(dialog._decision_container_layout)
                
                # Show compact decision outcome
                outcome_frame = QtWidgets.QFrame()
                outcome_frame.setStyleSheet("""
                    QFrame {
                        background-color: rgba(46, 204, 113, 0.08);
                        border: 1px solid #2ecc71;
                        border-radius: 6px;
                        padding: 8px 12px;
                        margin-top: 8px;
                    }
                """)
                outcome_layout = QtWidgets.QVBoxLayout(outcome_frame)
                outcome_layout.setSpacing(4)
                outcome_layout.setContentsMargins(5, 5, 5, 5)
                
                # Compact decision header with choice inline
                choice_text = f"<p style='font-size: 12px; color: #2ecc71; margin: 0;'><b>‚úÖ You chose:</b> {result.get('choice_label', option_key)}</p>"
                choice_lbl = QtWidgets.QLabel(choice_text)
                choice_lbl.setWordWrap(True)
                outcome_layout.addWidget(choice_lbl)
                
                # Outcome/consequence (more subtle)
                outcome_text = result.get('outcome', 'Your choice will shape the story...')
                outcome_lbl = QtWidgets.QLabel(f"<p style='font-size: 11px; color: #999; font-style: italic; margin: 2px 0 0 0;'>{outcome_text}</p>")
                outcome_lbl.setWordWrap(True)
                outcome_layout.addWidget(outcome_lbl)
                
                dialog._decision_container_layout.addWidget(outcome_frame)
                
                # Get updated chapter content with continuation
                updated_chapter = get_chapter_content(chapter_num, self.blocker.adhd_buster)
                if updated_chapter and updated_chapter.get("content"):
                    # Update the main content with the new personalized content
                    if hasattr(dialog, '_markdown_to_html') and hasattr(dialog, '_content_lbl'):
                        new_content = dialog._markdown_to_html(updated_chapter.get("content", ""))
                        dialog._content_lbl.setText(new_content)
                        
                        # Scroll to show the outcome
                        if hasattr(dialog, '_content_scroll'):
                            dialog._content_scroll.verticalScrollBar().setValue(
                                dialog._content_scroll.verticalScrollBar().maximum()
                            )
                    
                    # Show compact teaser for next chapter if available
                    if updated_chapter.get("next_teaser"):
                        teaser = QtWidgets.QLabel(
                            f"<p style='color: #3498db; font-size: 11px; font-style: italic; margin: 8px 0 0 0;'>"
                            f"üîÆ {updated_chapter['next_teaser']}</p>"
                        )
                        teaser.setWordWrap(True)
                        dialog._decision_container_layout.addWidget(teaser)
        else:
            dialog._decision_in_progress = False
            show_error(self, "Error", result.get("error", "Failed to make decision."))


class DevTab(QtWidgets.QWidget):
    """Developer tools tab for testing - generate items, add coins, add XP."""

    def __init__(self, blocker, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.blocker = blocker
        self._build_ui()

    def _build_ui(self) -> None:
        layout = QtWidgets.QVBoxLayout(self)
        
        add_tab_help_button(layout, "dev", self)

        # Header row
        header_row = QtWidgets.QHBoxLayout()
        warning = QtWidgets.QLabel("‚ö†Ô∏è Developer Tools - For Testing Only")
        warning.setStyleSheet("color: #ff9800; font-weight: bold; font-size: 14px; padding: 10px;")
        header_row.addStretch()
        header_row.addWidget(warning)
        header_row.addStretch()
        layout.addLayout(header_row)

        # Generate Item Section
        item_group = QtWidgets.QGroupBox("üéÅ Generate Item")
        item_layout = QtWidgets.QVBoxLayout(item_group)
        
        # Rarity selector
        rarity_layout = QtWidgets.QHBoxLayout()
        rarity_layout.addWidget(QtWidgets.QLabel("Rarity:"))
        self.rarity_combo = NoScrollComboBox()
        self.rarity_combo.addItems(["Common", "Uncommon", "Rare", "Epic", "Legendary"])
        self.rarity_combo.setCurrentText("Common")
        rarity_layout.addWidget(self.rarity_combo)
        rarity_layout.addStretch()
        item_layout.addLayout(rarity_layout)
        
        # Generate buttons for each rarity
        btn_layout = QtWidgets.QHBoxLayout()
        for rarity in ["Common", "Uncommon", "Rare", "Epic", "Legendary"]:
            btn = QtWidgets.QPushButton(rarity)
            color = {"Common": "#9e9e9e", "Uncommon": "#4caf50", "Rare": "#2196f3", 
                     "Epic": "#9c27b0", "Legendary": "#ff9800"}[rarity]
            btn.setStyleSheet(f"background-color: {color}; color: white; font-weight: bold; padding: 8px;")
            btn.clicked.connect(lambda checked, r=rarity: self._generate_item(r))
            btn_layout.addWidget(btn)
        item_layout.addLayout(btn_layout)
        
        layout.addWidget(item_group)

        # Add Coins Section
        coins_group = QtWidgets.QGroupBox("ü™ô Add Coins")
        coins_layout = QtWidgets.QHBoxLayout(coins_group)
        
        for amount in [100, 500, 1000, 5000]:
            btn = QtWidgets.QPushButton(f"+{amount}")
            btn.setStyleSheet("background-color: #ffd700; color: black; font-weight: bold; padding: 8px;")
            btn.clicked.connect(lambda checked, a=amount: self._add_coins(a))
            coins_layout.addWidget(btn)
        
        layout.addWidget(coins_group)

        # Add XP Section
        xp_group = QtWidgets.QGroupBox("‚≠ê Add Experience")
        xp_layout = QtWidgets.QHBoxLayout(xp_group)
        
        for amount in [50, 100, 500, 1000]:
            btn = QtWidgets.QPushButton(f"+{amount} XP")
            btn.setStyleSheet("background-color: #4caf50; color: white; font-weight: bold; padding: 8px;")
            btn.clicked.connect(lambda checked, a=amount: self._add_xp(a))
            xp_layout.addWidget(btn)
        
        layout.addWidget(xp_group)

        # Cooldown Reset Section
        cooldown_group = QtWidgets.QGroupBox("‚è±Ô∏è Reset Cooldowns")
        cooldown_layout = QtWidgets.QHBoxLayout(cooldown_group)
        
        water_reset_btn = QtWidgets.QPushButton("üíß Reset Water Cooldown")
        water_reset_btn.setStyleSheet("background-color: #2196f3; color: white; font-weight: bold; padding: 8px;")
        water_reset_btn.clicked.connect(self._reset_water_cooldown)
        cooldown_layout.addWidget(water_reset_btn)
        
        water_attempts_btn = QtWidgets.QPushButton("üé∞ Reset Lottery Attempts")
        water_attempts_btn.setStyleSheet("background-color: #9c27b0; color: white; font-weight: bold; padding: 8px;")
        water_attempts_btn.clicked.connect(self._reset_water_lottery_attempts)
        cooldown_layout.addWidget(water_attempts_btn)
        
        eye_reset_btn = QtWidgets.QPushButton("üëÅÔ∏è Reset Eye Routine Cooldown")
        eye_reset_btn.setStyleSheet("background-color: #00bcd4; color: white; font-weight: bold; padding: 8px;")
        eye_reset_btn.clicked.connect(self._reset_eye_routine_cooldown)
        cooldown_layout.addWidget(eye_reset_btn)
        
        layout.addWidget(cooldown_group)

        # Entity Encounter Section
        entity_group = QtWidgets.QGroupBox("üêæ Entity Encounter Test")
        entity_layout = QtWidgets.QVBoxLayout(entity_group)
        
        # Story selector
        story_layout = QtWidgets.QHBoxLayout()
        story_layout.addWidget(QtWidgets.QLabel("Story:"))
        self.story_combo = NoScrollComboBox()
        self.story_combo.addItems(["warrior", "scholar", "underdog", "scientist", "wanderer"])
        self.story_combo.currentTextChanged.connect(self._refresh_entity_selector)
        story_layout.addWidget(self.story_combo)
        story_layout.addStretch()
        entity_layout.addLayout(story_layout)
        
        # Entity selector
        entity_select_layout = QtWidgets.QHBoxLayout()
        entity_select_layout.addWidget(QtWidgets.QLabel("Entity:"))
        self.entity_combo = NoScrollComboBox()
        self.entity_combo.setMinimumWidth(250)
        entity_select_layout.addWidget(self.entity_combo)
        entity_select_layout.addStretch()
        entity_layout.addLayout(entity_select_layout)
        
        # Initialize entity list
        QtCore.QTimer.singleShot(50, self._refresh_entity_selector)
        
        # Encounter buttons
        encounter_btn_layout = QtWidgets.QHBoxLayout()
        
        selected_btn = QtWidgets.QPushButton("üéØ Encounter Selected")
        selected_btn.setStyleSheet("background-color: #4caf50; color: white; font-weight: bold; padding: 8px;")
        selected_btn.clicked.connect(self._encounter_selected_entity)
        encounter_btn_layout.addWidget(selected_btn)
        
        trigger_btn = QtWidgets.QPushButton("üé≤ Random Encounter")
        trigger_btn.setStyleSheet("background-color: #2196f3; color: white; font-weight: bold; padding: 8px;")
        trigger_btn.clicked.connect(self._trigger_entity_encounter)
        encounter_btn_layout.addWidget(trigger_btn)
        
        entity_layout.addLayout(encounter_btn_layout)
        
        # Rarity-specific encounter buttons
        rarity_btn_layout = QtWidgets.QHBoxLayout()
        for rarity in ["common", "uncommon", "rare", "epic", "legendary"]:
            btn = QtWidgets.QPushButton(rarity.capitalize())
            color = {"common": "#9e9e9e", "uncommon": "#4caf50", "rare": "#2196f3", 
                     "epic": "#9c27b0", "legendary": "#ff9800"}[rarity]
            btn.setStyleSheet(f"background-color: {color}; color: white; font-weight: bold; padding: 6px;")
            btn.clicked.connect(lambda checked, r=rarity: self._encounter_by_rarity(r))
            rarity_btn_layout.addWidget(btn)
        entity_layout.addLayout(rarity_btn_layout)
        
        # Entitidex viewer button
        view_btn = QtWidgets.QPushButton("üìñ View Entitidex")
        view_btn.setStyleSheet("background-color: #ff9800; color: white; font-weight: bold; padding: 8px;")
        view_btn.clicked.connect(self._view_entitidex)
        entity_layout.addWidget(view_btn)
        
        # Generate Exceptional Entity button
        exceptional_btn = QtWidgets.QPushButton("üåü Generate EXCEPTIONAL Entity (Guaranteed)")
        exceptional_btn.setStyleSheet("""
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #FF6B9D, stop:0.5 #FFD700, stop:1 #00FFFF);
                color: black;
                font-weight: bold;
                padding: 10px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #00FFFF, stop:0.5 #FF6B9D, stop:1 #FFD700);
            }
        """)
        exceptional_btn.clicked.connect(self._generate_exceptional_entity)
        entity_layout.addWidget(exceptional_btn)
        
        layout.addWidget(entity_group)

        # Entity Lock/Unlock Section
        lock_group = QtWidgets.QGroupBox("üîì Entity Lock/Unlock (Testing)")
        lock_layout = QtWidgets.QVBoxLayout(lock_group)
        
        # Story selector for lock/unlock
        lock_story_layout = QtWidgets.QHBoxLayout()
        lock_story_layout.addWidget(QtWidgets.QLabel("Story:"))
        self.lock_story_combo = NoScrollComboBox()
        self.lock_story_combo.addItems(["warrior", "scholar", "underdog", "scientist", "wanderer"])
        self.lock_story_combo.currentTextChanged.connect(self._refresh_entity_lock_list)
        lock_story_layout.addWidget(self.lock_story_combo)
        lock_story_layout.addStretch()
        lock_layout.addLayout(lock_story_layout)
        
        # Entity list with checkboxes (scrollable)
        self.entity_lock_list = QtWidgets.QListWidget()
        self.entity_lock_list.setStyleSheet("""
            QListWidget {
                background: #2D2D2D;
                border: 1px solid #444;
                border-radius: 5px;
                padding: 5px;
            }
            QListWidget::item {
                padding: 4px;
                border-radius: 3px;
            }
            QListWidget::item:selected {
                background: #3D3D3D;
            }
        """)
        self.entity_lock_list.setMaximumHeight(200)
        lock_layout.addWidget(self.entity_lock_list)
        
        # Quick action buttons
        quick_btn_layout = QtWidgets.QHBoxLayout()
        
        unlock_all_btn = QtWidgets.QPushButton("üîì Unlock All")
        unlock_all_btn.setStyleSheet("background-color: #4caf50; color: white; font-weight: bold; padding: 8px;")
        unlock_all_btn.clicked.connect(self._unlock_all_entities)
        quick_btn_layout.addWidget(unlock_all_btn)
        
        lock_all_btn = QtWidgets.QPushButton("üîí Lock All")
        lock_all_btn.setStyleSheet("background-color: #f44336; color: white; font-weight: bold; padding: 8px;")
        lock_all_btn.clicked.connect(self._lock_all_entities)
        quick_btn_layout.addWidget(lock_all_btn)
        
        apply_btn = QtWidgets.QPushButton("üíæ Apply Changes")
        apply_btn.setStyleSheet("background-color: #2196f3; color: white; font-weight: bold; padding: 8px;")
        apply_btn.clicked.connect(self._apply_entity_lock_changes)
        quick_btn_layout.addWidget(apply_btn)
        
        lock_layout.addLayout(quick_btn_layout)
        
        layout.addWidget(lock_group)
        
        # Initial population of entity list
        QtCore.QTimer.singleShot(100, self._refresh_entity_lock_list)

        # ================================================================
        # CITY SYSTEM CONTROLS
        # ================================================================
        city_group = QtWidgets.QGroupBox("üè∞ City System Controls")
        city_layout = QtWidgets.QVBoxLayout(city_group)
        
        # Resources Section
        resources_label = QtWidgets.QLabel("üì¶ Resources")
        resources_label.setStyleSheet("font-weight: bold; color: #FFD700; font-size: 12px;")
        city_layout.addWidget(resources_label)
        
        # Resource add buttons
        resource_btn_layout = QtWidgets.QHBoxLayout()
        resource_info = [
            ("üíß Water", "water", "#2196f3"),
            ("üß± Materials", "materials", "#795548"),
            ("üî© Scrap", "scrap", "#607d8b"),
            ("üèÉ Activity", "activity", "#4caf50"),
            ("üéØ Focus", "focus", "#9c27b0"),
        ]
        for label, res_type, color in resource_info:
            btn = QtWidgets.QPushButton(f"{label} +50")
            btn.setStyleSheet(f"background-color: {color}; color: white; font-weight: bold; padding: 6px;")
            btn.clicked.connect(lambda checked, r=res_type: self._add_city_resource(r, 50))
            resource_btn_layout.addWidget(btn)
        city_layout.addLayout(resource_btn_layout)
        
        # Resource +200 buttons
        resource_big_btn_layout = QtWidgets.QHBoxLayout()
        for label, res_type, color in resource_info:
            btn = QtWidgets.QPushButton(f"+200")
            btn.setStyleSheet(f"background-color: {color}; color: white; font-weight: bold; padding: 4px;")
            btn.clicked.connect(lambda checked, r=res_type: self._add_city_resource(r, 200))
            resource_big_btn_layout.addWidget(btn)
        city_layout.addLayout(resource_big_btn_layout)
        
        # Current resources display
        self.city_resources_label = QtWidgets.QLabel("Loading...")
        self.city_resources_label.setStyleSheet("color: #888; padding: 5px;")
        city_layout.addWidget(self.city_resources_label)
        
        # Building selector
        building_label = QtWidgets.QLabel("üèóÔ∏è Building Controls")
        building_label.setStyleSheet("font-weight: bold; color: #FFD700; font-size: 12px; margin-top: 10px;")
        city_layout.addWidget(building_label)
        
        building_select_layout = QtWidgets.QHBoxLayout()
        building_select_layout.addWidget(QtWidgets.QLabel("Building:"))
        self.city_building_combo = NoScrollComboBox()
        self.city_building_combo.setMinimumWidth(200)
        building_select_layout.addWidget(self.city_building_combo)
        building_select_layout.addStretch()
        city_layout.addLayout(building_select_layout)
        
        # Cell position selector
        cell_select_layout = QtWidgets.QHBoxLayout()
        cell_select_layout.addWidget(QtWidgets.QLabel("Row:"))
        self.city_row_spin = QtWidgets.QSpinBox()
        self.city_row_spin.setRange(0, 4)
        self.city_row_spin.setValue(0)
        cell_select_layout.addWidget(self.city_row_spin)
        cell_select_layout.addWidget(QtWidgets.QLabel("Col:"))
        self.city_col_spin = QtWidgets.QSpinBox()
        self.city_col_spin.setRange(0, 4)
        self.city_col_spin.setValue(0)
        cell_select_layout.addWidget(self.city_col_spin)
        cell_select_layout.addStretch()
        city_layout.addLayout(cell_select_layout)
        
        # Level selector
        level_select_layout = QtWidgets.QHBoxLayout()
        level_select_layout.addWidget(QtWidgets.QLabel("Level:"))
        self.city_level_spin = QtWidgets.QSpinBox()
        self.city_level_spin.setRange(1, 10)
        self.city_level_spin.setValue(1)
        level_select_layout.addWidget(self.city_level_spin)
        level_select_layout.addStretch()
        city_layout.addLayout(level_select_layout)
        
        # Building action buttons
        building_action_layout = QtWidgets.QHBoxLayout()
        
        place_btn = QtWidgets.QPushButton("üìç Place Building")
        place_btn.setStyleSheet("background-color: #4caf50; color: white; font-weight: bold; padding: 8px;")
        place_btn.clicked.connect(self._city_place_building)
        building_action_layout.addWidget(place_btn)
        
        complete_btn = QtWidgets.QPushButton("‚úÖ Complete Building")
        complete_btn.setStyleSheet("background-color: #2196f3; color: white; font-weight: bold; padding: 8px;")
        complete_btn.clicked.connect(self._city_complete_building)
        building_action_layout.addWidget(complete_btn)
        
        remove_btn = QtWidgets.QPushButton("üóëÔ∏è Remove Building")
        remove_btn.setStyleSheet("background-color: #f44336; color: white; font-weight: bold; padding: 8px;")
        remove_btn.clicked.connect(self._city_remove_building)
        building_action_layout.addWidget(remove_btn)
        
        city_layout.addLayout(building_action_layout)
        
        # Quick actions row
        quick_city_layout = QtWidgets.QHBoxLayout()
        
        place_all_btn = QtWidgets.QPushButton("üèòÔ∏è Place All Buildings")
        place_all_btn.setStyleSheet("background-color: #ff9800; color: white; font-weight: bold; padding: 8px;")
        place_all_btn.clicked.connect(self._city_place_all_buildings)
        quick_city_layout.addWidget(place_all_btn)
        
        complete_all_btn = QtWidgets.QPushButton("üéØ Complete All")
        complete_all_btn.setStyleSheet("background-color: #9c27b0; color: white; font-weight: bold; padding: 8px;")
        complete_all_btn.clicked.connect(self._city_complete_all_buildings)
        quick_city_layout.addWidget(complete_all_btn)
        
        max_all_btn = QtWidgets.QPushButton("‚¨ÜÔ∏è Max All Levels")
        max_all_btn.setStyleSheet("background-color: #FFD700; color: black; font-weight: bold; padding: 8px;")
        max_all_btn.clicked.connect(self._city_max_all_buildings)
        quick_city_layout.addWidget(max_all_btn)
        
        city_layout.addLayout(quick_city_layout)
        
        # Reset/Clear row
        reset_city_layout = QtWidgets.QHBoxLayout()
        
        clear_city_btn = QtWidgets.QPushButton("üí• Clear All Buildings")
        clear_city_btn.setStyleSheet("background-color: #b71c1c; color: white; font-weight: bold; padding: 8px;")
        clear_city_btn.clicked.connect(self._city_clear_all)
        reset_city_layout.addWidget(clear_city_btn)
        
        reset_resources_btn = QtWidgets.QPushButton("üîÑ Reset Resources to 0")
        reset_resources_btn.setStyleSheet("background-color: #455a64; color: white; font-weight: bold; padding: 8px;")
        reset_resources_btn.clicked.connect(self._city_reset_resources)
        reset_city_layout.addWidget(reset_resources_btn)
        
        give_resources_btn = QtWidgets.QPushButton("üí∞ +500 All Resources")
        give_resources_btn.setStyleSheet("background-color: #00bcd4; color: white; font-weight: bold; padding: 8px;")
        give_resources_btn.clicked.connect(self._city_give_all_resources)
        reset_city_layout.addWidget(give_resources_btn)
        
        city_layout.addLayout(reset_city_layout)
        
        # Current grid display
        self.city_grid_label = QtWidgets.QLabel("Loading...")
        self.city_grid_label.setStyleSheet("color: #888; padding: 5px; font-family: monospace;")
        self.city_grid_label.setWordWrap(True)
        city_layout.addWidget(self.city_grid_label)
        
        layout.addWidget(city_group)
        
        # Initialize city UI
        QtCore.QTimer.singleShot(150, self._refresh_city_display)

        # Status display
        self.status_label = QtWidgets.QLabel("")
        self.status_label.setStyleSheet("color: #4caf50; padding: 10px;")
        self.status_label.setAlignment(QtCore.Qt.AlignCenter)
        layout.addWidget(self.status_label)

        layout.addStretch()

    def _generate_item(self, rarity: str) -> None:
        """Generate an item of the specified rarity."""
        try:
            from gamification import generate_item
            game_state = get_game_state()
            if not game_state:
                self.status_label.setText("‚ùå Game state not available")
                return
            
            active_story = self.blocker.adhd_buster.get("active_story", "warrior")
            item = generate_item(rarity=rarity, story_id=active_story)
            item["source"] = "dev_tools"
            
            game_state.add_item(item)
            self.status_label.setText(f"‚úÖ Generated: {item.get('name', 'Unknown')} ({rarity})")
            self.status_label.setStyleSheet(f"color: #4caf50; padding: 10px;")
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _add_coins(self, amount: int) -> None:
        """Add coins to the player."""
        try:
            game_state = get_game_state()
            if not game_state:
                self.status_label.setText("‚ùå Game state not available")
                return
            
            new_total = game_state.add_coins(amount)
            self.status_label.setText(f"‚úÖ Added {amount} coins! New total: {new_total}")
            self.status_label.setStyleSheet("color: #ffd700; padding: 10px;")
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _add_xp(self, amount: int) -> None:
        """Add XP to the hero."""
        try:
            game_state = get_game_state()
            if not game_state:
                self.status_label.setText("‚ùå Game state not available")
                return
            
            new_xp, new_level, leveled_up = game_state.add_xp(amount)
            if leveled_up:
                self.status_label.setText(f"üéâ Level Up! Now level {new_level} with {new_xp} XP")
            else:
                self.status_label.setText(f"‚úÖ Added {amount} XP! Level {new_level}, {new_xp} XP")
            self.status_label.setStyleSheet("color: #4caf50; padding: 10px;")
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _get_coin_data(self) -> Optional[Dict[str, Any]]:
        """
        Get coin operation callbacks for special entity bonding rewards.
        
        Returns:
            Dict with get_coins_callback and add_coins_callback, or None if unavailable.
        """
        try:
            gs = get_game_state()
            if gs:
                def get_coins_callback() -> int:
                    return gs.coins
                
                def add_coins_callback(amount: int) -> None:
                    gs.add_coins(amount)
                
                return {
                    "get_coins_callback": get_coins_callback,
                    "add_coins_callback": add_coins_callback,
                }
        except Exception as e:
            logger.debug(f"Could not get coin data: {e}")
        return None

    def _reset_water_cooldown(self) -> None:
        """Reset water logging cooldown by clearing today's last entry time."""
        try:
            from datetime import datetime
            from app_utils import get_activity_date
            # Use activity date (5 AM cutoff) for daily tracking
            today = get_activity_date()
            
            # Find all entries for today and set their times to 00:00
            if hasattr(self.blocker, 'water_entries') and self.blocker.water_entries:
                today_entries = [e for e in self.blocker.water_entries if e.get("date") == today]
                if today_entries:
                    # Set ALL today's entry times to 00:00 to ensure cooldown is bypassed
                    for entry in today_entries:
                        entry["time"] = "00:00"
                    self.blocker.save_config()
                    self.status_label.setText(f"‚úÖ Water cooldown reset! ({len(today_entries)} entries set to 00:00)")
                    self.status_label.setStyleSheet("color: #2196f3; padding: 10px;")
                else:
                    self.status_label.setText("‚ÑπÔ∏è No water entries today - no cooldown to reset")
                    self.status_label.setStyleSheet("color: #888; padding: 10px;")
            else:
                self.status_label.setText("‚ÑπÔ∏è No water entries - no cooldown to reset")
                self.status_label.setStyleSheet("color: #888; padding: 10px;")
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _reset_water_lottery_attempts(self) -> None:
        """Reset water lottery attempts counter to 0."""
        try:
            if hasattr(self.blocker, 'water_lottery_attempts'):
                old_attempts = self.blocker.water_lottery_attempts
                self.blocker.water_lottery_attempts = 0
                self.blocker.save_config()
                self.status_label.setText(f"‚úÖ Lottery attempts reset! (was {old_attempts}, now 0 ‚Üí 1% win chance)")
                self.status_label.setStyleSheet("color: #9c27b0; padding: 10px;")
            else:
                self.blocker.water_lottery_attempts = 0
                self.blocker.save_config()
                self.status_label.setText("‚úÖ Lottery attempts initialized to 0")
                self.status_label.setStyleSheet("color: #9c27b0; padding: 10px;")
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _reset_eye_routine_cooldown(self) -> None:
        """Reset eye routine cooldown by clearing the last_date timestamp."""
        try:
            if "eye_protection" not in self.blocker.stats:
                self.blocker.stats["eye_protection"] = {}
            
            old_date = self.blocker.stats["eye_protection"].get("last_date", "None")
            self.blocker.stats["eye_protection"]["last_date"] = ""
            self.blocker.save_config()
            
            self.status_label.setText(f"‚úÖ Eye routine cooldown reset! (was {old_date})")
            self.status_label.setStyleSheet("color: #00bcd4; padding: 10px;")
            
            # Refresh the eye tab display if it exists
            # Navigate up to main window (parent of DevTab is MainWindow)
            main_window = self.window()
            if main_window and hasattr(main_window, 'eye_tab'):
                main_window.eye_tab._update_cooldown_display()
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _refresh_entity_selector(self) -> None:
        """Refresh the entity selector dropdown based on selected story."""
        try:
            from entitidex import get_entities_for_story
            
            story_id = self.story_combo.currentText()
            entities = get_entities_for_story(story_id)
            
            self.entity_combo.clear()
            
            # Sort entities by rarity for easier navigation
            rarity_order = {"common": 0, "uncommon": 1, "rare": 2, "epic": 3, "legendary": 4}
            sorted_entities = sorted(entities, key=lambda e: (rarity_order.get(e.rarity.lower(), 5), e.name))
            
            for entity in sorted_entities:
                rarity_icon = {"common": "‚ö™", "uncommon": "üü¢", "rare": "üîµ", 
                               "epic": "üü£", "legendary": "üü†"}.get(entity.rarity.lower(), "‚ö™")
                self.entity_combo.addItem(f"{rarity_icon} {entity.name} ({entity.id})", entity.id)
            
        except Exception as e:
            self.status_label.setText(f"‚ùå Error loading entities: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _encounter_selected_entity(self) -> None:
        """Trigger an encounter with the selected entity."""
        try:
            from entitidex import get_entities_for_story, calculate_join_probability
            from entity_drop_dialog import show_entity_encounter
            from gamification import attempt_entitidex_bond
            import random
            
            game_state = get_game_state()
            if not game_state:
                self.status_label.setText("‚ùå Game state not available")
                return
            
            story_id = self.story_combo.currentText()
            entity_id = self.entity_combo.currentData()
            
            if not entity_id:
                self.status_label.setText("‚ùå No entity selected")
                return
            
            # Find the entity
            entities = get_entities_for_story(story_id)
            entity = next((e for e in entities if e.id == entity_id), None)
            
            if not entity:
                self.status_label.setText(f"‚ùå Entity not found: {entity_id}")
                return
            
            hero_power = game_state.get_current_power()
            join_prob = calculate_join_probability(hero_power, entity.power)
            is_exceptional = random.random() < 0.20  # 20% exceptional chance
            
            def bond_callback_wrapper(eid: str, exceptional: bool = is_exceptional):
                result = attempt_entitidex_bond(
                    self.blocker.adhd_buster, 
                    eid,
                    is_exceptional=exceptional
                )
                self.status_label.setText(f"Result: {'Success' if result.get('success') else 'Failed'}")
                xp_awarded = result.get('xp_awarded', 0)
                if xp_awarded > 0:
                    gs = get_game_state()
                    if gs:
                        total_xp = self.blocker.adhd_buster.get('total_xp', 0)
                        level = self.blocker.adhd_buster.get('hero', {}).get('level', 1)
                        gs.xp_changed.emit(total_xp, level)
                main_win = self.window()
                if hasattr(main_win, 'entitidex_tab'):
                    main_win.entitidex_tab.refresh()
                return result

            # Build Chad interaction data for skip interactions
            CHAD_ENTITY_ID = "underdog_008"
            chad_interaction_data = None
            try:
                from gamification import get_entitidex_manager
                manager = get_entitidex_manager(self.blocker.adhd_buster)
                
                has_chad_normal = CHAD_ENTITY_ID in manager.progress.collected_entity_ids
                has_chad_exceptional = manager.progress.is_exceptional(CHAD_ENTITY_ID)
                
                if has_chad_normal or has_chad_exceptional:
                    # Callback to add coins (for exceptional Chad's "banking hack")
                    def add_coins_callback(amount: int):
                        gs = get_game_state()
                        if gs:
                            gs.add_coins(amount)
                    
                    # Callback to give entity as if bonded (for exceptional Chad's gift)
                    def give_entity_callback():
                        result = attempt_entitidex_bond(
                            self.blocker.adhd_buster, entity.id,
                            is_exceptional=is_exceptional,
                            force_success=True  # Chad guarantees the bond!
                        )
                        from gamification import sync_hero_data
                        sync_hero_data(self.blocker.adhd_buster)
                        gs = get_game_state()
                        if gs:
                            xp_awarded = result.get('xp_awarded', 0)
                            if xp_awarded > 0:
                                total_xp = self.blocker.adhd_buster.get('total_xp', 0)
                                level = self.blocker.adhd_buster.get('hero', {}).get('level', 1)
                                gs.xp_changed.emit(total_xp, level)
                            gs.force_save()
                        main_win = self.window()
                        if hasattr(main_win, 'entitidex_tab'):
                            main_win.entitidex_tab.refresh()
                    
                    chad_interaction_data = {
                        "has_chad_normal": has_chad_normal,
                        "has_chad_exceptional": has_chad_exceptional,
                        "add_coins_callback": add_coins_callback,
                        "give_entity_callback": give_entity_callback,
                    }
            except Exception as e:
                import logging
                logging.getLogger(__name__).debug(f"Could not check for Chad entity: {e}")

            def save_callback_wrapper(entity_id: str, coin_cost: int = 0):
                from gamification import save_encounter_for_later
                result = save_encounter_for_later(
                    self.blocker.adhd_buster,
                    entity_id,
                    is_exceptional=is_exceptional,
                    catch_probability=join_prob,
                    coin_cost=coin_cost
                )
                self.blocker.save_config()
                main_win = self.window()
                if hasattr(main_win, 'entitidex_tab'):
                    main_win.entitidex_tab._update_saved_button_count()
                return result

            # Build bookmark data for save slot limits
            bookmark_data = None
            try:
                from gamification import get_bookmark_entity_status, get_save_slot_cost
                bookmark_status = get_bookmark_entity_status(self.blocker.adhd_buster)
                slot_info = get_save_slot_cost(self.blocker.adhd_buster, bookmark_status["current_saved"])
                bookmark_data = {
                    "has_normal": bookmark_status["has_normal"],
                    "has_exceptional": bookmark_status["has_exceptional"],
                    "max_free_slots": bookmark_status["max_free_slots"],
                    "current_saved": bookmark_status["current_saved"],
                    "slot_cost": slot_info["cost"],
                    "can_save": slot_info["can_save"],
                    "slot_reason": slot_info.get("reason", ""),
                }
            except Exception as e:
                import logging
                logging.getLogger(__name__).debug(f"Could not get bookmark data: {e}")

            show_entity_encounter(
                entity=entity,
                join_probability=join_prob,
                bond_logic_callback=bond_callback_wrapper,
                parent=self.window(),
                is_exceptional=is_exceptional,
                chad_interaction_data=chad_interaction_data,
                coin_data=self._get_coin_data() if hasattr(self, '_get_coin_data') else None,
                save_callback=save_callback_wrapper,
                bookmark_data=bookmark_data,
            )
            
            self.status_label.setText(f"‚ú® Encountered: {entity.name} ({entity.rarity}){' ‚≠ê' if is_exceptional else ''}")
            self.status_label.setStyleSheet("color: #4caf50; padding: 10px;")
            
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _trigger_entity_encounter(self) -> None:
        """Trigger a full entity encounter with the encounter dialog."""
        try:
            from entitidex import (
                select_encounter_entity,
                calculate_join_probability,
                load_entitidex_progress,
                get_entities_for_story,
            )
            # from entity_encounter_dialog import EntityEncounterDialog
            
            game_state = get_game_state()
            if not game_state:
                self.status_label.setText("‚ùå Game state not available")
                return
            
            story_id = self.story_combo.currentText()
            hero_power = game_state.get_current_power()
            
            # Load real progress from file
            progress = load_entitidex_progress(story_id)
            
            # Select an entity for encounter (now returns tuple with is_exceptional)
            entity, is_exceptional = select_encounter_entity(progress, hero_power, story_id)
            
            if not entity:
                # Fallback: get a random entity from the story
                entities = get_entities_for_story(story_id)
                if entities:
                    import random
                    entity = random.choice(entities)
                    is_exceptional = random.random() < 0.20  # 20% exceptional chance
                else:
                    self.status_label.setText("‚ùå No entities available")
                    return
            
            # Calculate join probability
            join_prob = calculate_join_probability(hero_power, entity.power)
            
            # Show encounter dialog using new merge-style flow
            from entity_drop_dialog import show_entity_encounter
            from entitidex.encounter_system import get_encounter_flavor_text

            # Generate customized flavor text
            flavor_text = get_encounter_flavor_text(entity, hero_power, is_exceptional)
            
            def bond_callback_wrapper(entity_id: str, exceptional: bool = is_exceptional):
                from gamification import attempt_entitidex_bond
                result = attempt_entitidex_bond(
                    self.blocker.adhd_buster, 
                    entity_id,
                    is_exceptional=exceptional
                )
                self.status_label.setText(f"Result: {'Success' if result.get('success') else 'Failed'}")
                # Emit XP signal if XP was awarded
                xp_awarded = result.get('xp_awarded', 0)
                if xp_awarded > 0:
                    from game_state import get_game_state
                    gs = get_game_state()
                    if gs:
                        total_xp = self.blocker.adhd_buster.get('total_xp', 0)
                        level = self.blocker.adhd_buster.get('hero', {}).get('level', 1)
                        gs.xp_changed.emit(total_xp, level)
                # Refresh entitidex tab after bond attempt
                main_win = self.window()
                if hasattr(main_win, 'entitidex_tab'):
                    main_win.entitidex_tab.refresh()
                return result

            def save_callback_wrapper(entity_id: str, coin_cost: int = 0):
                from gamification import save_encounter_for_later
                result = save_encounter_for_later(
                    self.blocker.adhd_buster,
                    entity_id,
                    is_exceptional=is_exceptional,
                    catch_probability=join_prob,
                    coin_cost=coin_cost
                )
                self.blocker.save_config()
                main_win = self.window()
                if hasattr(main_win, 'entitidex_tab'):
                    main_win.entitidex_tab._update_saved_button_count()
                return result

            # Build bookmark data for save slot limits
            bookmark_data = None
            try:
                from gamification import get_bookmark_entity_status, get_save_slot_cost
                bookmark_status = get_bookmark_entity_status(self.blocker.adhd_buster)
                slot_info = get_save_slot_cost(self.blocker.adhd_buster, bookmark_status["current_saved"])
                bookmark_data = {
                    "has_normal": bookmark_status["has_normal"],
                    "has_exceptional": bookmark_status["has_exceptional"],
                    "max_free_slots": bookmark_status["max_free_slots"],
                    "current_saved": bookmark_status["current_saved"],
                    "slot_cost": slot_info["cost"],
                    "can_save": slot_info["can_save"],
                    "slot_reason": slot_info.get("reason", ""),
                }
            except Exception as e:
                import logging
                logging.getLogger(__name__).debug(f"Could not get bookmark data: {e}")

            show_entity_encounter(
                entity=entity,
                join_probability=join_prob,
                bond_logic_callback=bond_callback_wrapper,
                parent=self.window(),
                is_exceptional=is_exceptional,
                coin_data=self._get_coin_data() if hasattr(self, '_get_coin_data') else None,
                save_callback=save_callback_wrapper,
                bookmark_data=bookmark_data,
                flavor_text=flavor_text,
            )
            
        except ImportError as e:
            self.status_label.setText(f"‚ùå Import error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _show_random_entity(self) -> None:
        """Show a random entity encounter from the selected story."""
        try:
            from entitidex import get_entities_for_story, calculate_join_probability
            # from entity_encounter_dialog import EntityEncounterDialog
            import random
            
            game_state = get_game_state()
            hero_power = game_state.get_current_power() if game_state else 100
            
            story_id = self.story_combo.currentText()
            entities = get_entities_for_story(story_id)
            
            if not entities:
                self.status_label.setText(f"‚ùå No entities for story: {story_id}")
                return
            
            entity = random.choice(entities)
            join_prob = calculate_join_probability(hero_power, entity.power)
            is_exceptional = random.random() < 0.20  # 20% exceptional chance
            
            # Show encounter dialog using new merge-style flow
            from entity_drop_dialog import show_entity_encounter
            from entitidex.encounter_system import get_encounter_flavor_text

            # Generate customized flavor text
            flavor_text = get_encounter_flavor_text(entity, hero_power, is_exceptional)
            
            def bond_callback_wrapper(entity_id: str, exceptional: bool = is_exceptional):
                from gamification import attempt_entitidex_bond
                result = attempt_entitidex_bond(
                    self.blocker.adhd_buster, entity_id, is_exceptional=exceptional
                )
                self.status_label.setText(f"Result: {result['success']}")
                # Emit XP signal if XP was awarded
                xp_awarded = result.get('xp_awarded', 0)
                if xp_awarded > 0:
                    from game_state import get_game_state
                    gs = get_game_state()
                    if gs:
                        total_xp = self.blocker.adhd_buster.get('total_xp', 0)
                        level = self.blocker.adhd_buster.get('hero', {}).get('level', 1)
                        gs.xp_changed.emit(total_xp, level)
                # Refresh entitidex tab after bond attempt
                main_win = self.window()
                if hasattr(main_win, 'entitidex_tab'):
                    main_win.entitidex_tab.refresh()
                return result

            def save_callback_wrapper(entity_id: str, coin_cost: int = 0):
                from gamification import save_encounter_for_later
                result = save_encounter_for_later(
                    self.blocker.adhd_buster,
                    entity_id,
                    is_exceptional=is_exceptional,
                    catch_probability=join_prob,
                    coin_cost=coin_cost
                )
                self.blocker.save_config()
                main_win = self.window()
                if hasattr(main_win, 'entitidex_tab'):
                    main_win.entitidex_tab._update_saved_button_count()
                return result

            # Build bookmark data for save slot limits
            bookmark_data = None
            try:
                from gamification import get_bookmark_entity_status, get_save_slot_cost
                bookmark_status = get_bookmark_entity_status(self.blocker.adhd_buster)
                slot_info = get_save_slot_cost(self.blocker.adhd_buster, bookmark_status["current_saved"])
                bookmark_data = {
                    "has_normal": bookmark_status["has_normal"],
                    "has_exceptional": bookmark_status["has_exceptional"],
                    "max_free_slots": bookmark_status["max_free_slots"],
                    "current_saved": bookmark_status["current_saved"],
                    "slot_cost": slot_info["cost"],
                    "can_save": slot_info["can_save"],
                    "slot_reason": slot_info.get("reason", ""),
                }
            except Exception as e:
                import logging
                logging.getLogger(__name__).debug(f"Could not get bookmark data: {e}")

            show_entity_encounter(
                entity=entity, 
                join_probability=join_prob,
                bond_logic_callback=bond_callback_wrapper,
                parent=self.window(),
                is_exceptional=is_exceptional,
                coin_data=self._get_coin_data() if hasattr(self, '_get_coin_data') else None,
                save_callback=save_callback_wrapper,
                bookmark_data=bookmark_data,
                flavor_text=flavor_text,
            )
            
            self.status_label.setText(f"‚ú® Encountered: {entity.name} ({entity.rarity}){' ‚≠ê' if is_exceptional else ''}")
            self.status_label.setStyleSheet("color: #2196f3; padding: 10px;")
            
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _encounter_by_rarity(self, rarity: str) -> None:
        """Show an entity encounter for a specific rarity."""
        try:
            from entitidex import get_entities_for_story, calculate_join_probability
            # from entity_encounter_dialog import EntityEncounterDialog
            import random
            
            game_state = get_game_state()
            hero_power = game_state.get_current_power() if game_state else 100
            
            story_id = self.story_combo.currentText()
            entities = get_entities_for_story(story_id)
            
            # Filter by rarity
            matching = [e for e in entities if e.rarity.lower() == rarity.lower()]
            
            if not matching:
                self.status_label.setText(f"‚ùå No {rarity} entities for {story_id}")
                return
            
            entity = random.choice(matching)
            join_prob = calculate_join_probability(hero_power, entity.power)
            is_exceptional = random.random() < 0.20  # 20% exceptional chance
            
            # Show encounter dialog using new merge-style flow
            from entity_drop_dialog import show_entity_encounter
            from entitidex.encounter_system import get_encounter_flavor_text
            
            # Generate customized flavor text
            flavor_text = get_encounter_flavor_text(entity, hero_power, is_exceptional)
            
            def bond_callback_wrapper(entity_id: str, exceptional: bool = is_exceptional):
                from gamification import attempt_entitidex_bond
                result = attempt_entitidex_bond(
                    self.blocker.adhd_buster, entity_id, is_exceptional=exceptional
                )
                # Emit XP signal if XP was awarded
                xp_awarded = result.get('xp_awarded', 0)
                from game_state import get_game_state
                gs = get_game_state()
                if gs:
                    if xp_awarded > 0:
                        total_xp = self.blocker.adhd_buster.get('total_xp', 0)
                        level = self.blocker.adhd_buster.get('hero', {}).get('level', 1)
                        gs.xp_changed.emit(total_xp, level)
                    # Emit entity collected signal for timeline ring
                    if result.get('success'):
                        gs.notify_entity_collected(entity_id)
                # Refresh entitidex tab after bond attempt
                main_win = self.window()
                if hasattr(main_win, 'entitidex_tab'):
                    main_win.entitidex_tab.refresh()
                return result

            def save_callback_wrapper(entity_id: str, coin_cost: int = 0):
                from gamification import save_encounter_for_later
                result = save_encounter_for_later(
                    self.blocker.adhd_buster,
                    entity_id,
                    is_exceptional=is_exceptional,
                    catch_probability=join_prob,
                    coin_cost=coin_cost
                )
                self.blocker.save_config()
                main_win = self.window()
                if hasattr(main_win, 'entitidex_tab'):
                    main_win.entitidex_tab._update_saved_button_count()
                return result

            # Build bookmark data for save slot limits
            bookmark_data = None
            try:
                from gamification import get_bookmark_entity_status, get_save_slot_cost
                bookmark_status = get_bookmark_entity_status(self.blocker.adhd_buster)
                slot_info = get_save_slot_cost(self.blocker.adhd_buster, bookmark_status["current_saved"])
                bookmark_data = {
                    "has_normal": bookmark_status["has_normal"],
                    "has_exceptional": bookmark_status["has_exceptional"],
                    "max_free_slots": bookmark_status["max_free_slots"],
                    "current_saved": bookmark_status["current_saved"],
                    "slot_cost": slot_info["cost"],
                    "can_save": slot_info["can_save"],
                    "slot_reason": slot_info.get("reason", ""),
                }
            except Exception as e:
                import logging
                logging.getLogger(__name__).debug(f"Could not get bookmark data: {e}")

            show_entity_encounter(
                entity=entity, 
                join_probability=join_prob,
                bond_logic_callback=bond_callback_wrapper,
                parent=self.window(),
                is_exceptional=is_exceptional,
                coin_data=self._get_coin_data() if hasattr(self, '_get_coin_data') else None,
                save_callback=save_callback_wrapper,
                bookmark_data=bookmark_data,
                flavor_text=flavor_text,
            )
            
            self.status_label.setText(f"‚ú® {rarity.upper()}: {entity.name}{' ‚≠ê' if is_exceptional else ''}")
            color = {"common": "#9e9e9e", "uncommon": "#4caf50", "rare": "#2196f3", 
                     "epic": "#9c27b0", "legendary": "#ff9800"}.get(rarity, "#4caf50")
            self.status_label.setStyleSheet(f"color: {color}; padding: 10px;")
            
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _generate_exceptional_entity(self) -> None:
        """Generate a guaranteed exceptional entity (bypasses 5% roll)."""
        try:
            from entitidex import get_entities_for_story, calculate_join_probability
            from gamification import _generate_exceptional_colors, get_entitidex_manager, save_entitidex_progress
            from entity_drop_dialog import _show_exceptional_celebration
            import random
            
            story_id = self.story_combo.currentText()
            entities = get_entities_for_story(story_id)
            
            if not entities:
                self.status_label.setText(f"‚ùå No entities for story: {story_id}")
                return
            
            # Pick a random entity
            entity = random.choice(entities)
            
            # Generate exceptional colors
            exceptional_colors = _generate_exceptional_colors()
            
            # Get the entitidex manager and add the entity as collected + exceptional
            manager = get_entitidex_manager(self.blocker.adhd_buster)
            
            # Mark as collected if not already
            if entity.id not in manager.progress.collected_entity_ids:
                manager.progress.collected_entity_ids.add(entity.id)
            
            # Mark as exceptional with unique colors
            manager.progress.mark_exceptional(entity.id, exceptional_colors)
            
            # Save progress
            save_entitidex_progress(self.blocker.adhd_buster, manager)
            self.blocker.save_config()
            
            # Emit entity collected signal for timeline ring
            from game_state import get_game_state
            gs = get_game_state()
            if gs:
                gs.notify_entity_collected(entity.id)
            
            # Refresh entitidex tab
            main_win = self.window()
            if hasattr(main_win, 'entitidex_tab'):
                main_win.entitidex_tab.refresh()
            
            # Show celebration
            _show_exceptional_celebration(entity, exceptional_colors, self.window())
            
            # Use exceptional_name if available
            display_name = entity.exceptional_name if entity.exceptional_name else entity.name
            border_col = exceptional_colors.get("border", "#FFD700")
            self.status_label.setText(f"üåü EXCEPTIONAL {display_name} added!")
            self.status_label.setStyleSheet(f"color: {border_col}; padding: 10px; font-weight: bold;")
            
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _view_entitidex(self) -> None:
        """Open the Entitidex viewer dialog."""
        try:
            from entitidex import get_entities_for_story
            
            story_id = self.story_combo.currentText()
            entities = get_entities_for_story(story_id)
            
            # Create a simple viewer dialog
            dialog = QtWidgets.QDialog(self)
            dialog.setWindowTitle(f"üìñ Entitidex - {story_id.capitalize()}")
            dialog.setFixedSize(600, 500)
            dialog.setStyleSheet("background: #1E1E1E;")
            
            layout = QtWidgets.QVBoxLayout(dialog)
            
            # Title
            title = QtWidgets.QLabel(f"üêæ {story_id.capitalize()} Entities ({len(entities)} total)")
            title.setStyleSheet("font-size: 16px; font-weight: bold; color: #FFD700; padding: 10px;")
            title.setAlignment(QtCore.Qt.AlignCenter)
            layout.addWidget(title)
            
            # Scroll area for entities
            scroll = QtWidgets.QScrollArea()
            scroll.setWidgetResizable(True)
            scroll.setStyleSheet("QScrollArea { border: none; }")
            
            content = QtWidgets.QWidget()
            grid = QtWidgets.QGridLayout(content)
            grid.setSpacing(10)
            
            rarity_colors = {
                "common": "#9e9e9e", "uncommon": "#4caf50", "rare": "#2196f3",
                "epic": "#9c27b0", "legendary": "#ff9800"
            }
            
            for i, entity in enumerate(entities):
                row, col = i // 3, i % 3
                
                card = QtWidgets.QFrame()
                color = rarity_colors.get(entity.rarity.lower(), "#9e9e9e")
                card.setStyleSheet(f"""
                    QFrame {{
                        background: #2D2D2D;
                        border: 2px solid {color};
                        border-radius: 8px;
                        padding: 8px;
                    }}
                """)
                card.setFixedSize(170, 100)
                
                card_layout = QtWidgets.QVBoxLayout(card)
                card_layout.setSpacing(2)
                card_layout.setContentsMargins(5, 5, 5, 5)
                
                name = QtWidgets.QLabel(entity.name)
                name.setStyleSheet(f"color: {color}; font-weight: bold; font-size: 10px;")
                name.setWordWrap(True)
                card_layout.addWidget(name)
                
                power = QtWidgets.QLabel(f"‚ö° {entity.power}")
                power.setStyleSheet("color: #FFD700; font-size: 10px;")
                card_layout.addWidget(power)
                
                rarity_lbl = QtWidgets.QLabel(entity.rarity.upper())
                rarity_lbl.setStyleSheet(f"color: {color}; font-size: 9px;")
                card_layout.addWidget(rarity_lbl)
                
                grid.addWidget(card, row, col)
            
            scroll.setWidget(content)
            layout.addWidget(scroll)
            
            # Close button
            close_btn = QtWidgets.QPushButton("Close")
            close_btn.setStyleSheet("background: #444; color: white; padding: 8px; border-radius: 5px;")
            close_btn.clicked.connect(dialog.close)
            layout.addWidget(close_btn)
            
            dialog.exec()
            
            self.status_label.setText(f"üìñ Viewing {len(entities)} {story_id} entities")
            self.status_label.setStyleSheet("color: #ff9800; padding: 10px;")
            
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _refresh_entity_lock_list(self) -> None:
        """Refresh the entity lock/unlock list for the selected story."""
        try:
            from entitidex import get_entities_for_story
            from gamification import get_entitidex_manager
            
            self.entity_lock_list.clear()
            
            story_id = self.lock_story_combo.currentText()
            entities = get_entities_for_story(story_id)
            
            # Get current collection state
            manager = get_entitidex_manager(self.blocker.adhd_buster)
            collected = manager.progress.collected_entity_ids
            exceptional = manager.progress.exceptional_entities
            
            rarity_colors = {
                "common": "#9e9e9e", "uncommon": "#4caf50", "rare": "#2196f3",
                "epic": "#9c27b0", "legendary": "#ff9800"
            }
            
            for entity in sorted(entities, key=lambda e: (
                ["common", "uncommon", "rare", "epic", "legendary"].index(e.rarity.lower()),
                e.name
            )):
                color = rarity_colors.get(entity.rarity.lower(), "#9e9e9e")
                
                # Normal variant row
                normal_item = QtWidgets.QListWidgetItem()
                normal_item.setData(QtCore.Qt.UserRole, entity.id)
                normal_item.setData(QtCore.Qt.UserRole + 1, False)  # Normal variant
                
                is_normal_unlocked = entity.id in collected
                normal_checkbox = QtWidgets.QCheckBox(f"  {entity.name} ({entity.rarity}) ‚ö°{entity.power}")
                normal_checkbox.setChecked(is_normal_unlocked)
                normal_checkbox.setStyleSheet(f"color: {color}; font-weight: bold;")
                
                normal_item.setSizeHint(normal_checkbox.sizeHint())
                self.entity_lock_list.addItem(normal_item)
                self.entity_lock_list.setItemWidget(normal_item, normal_checkbox)
                
                # Exceptional variant row
                exceptional_item = QtWidgets.QListWidgetItem()
                exceptional_item.setData(QtCore.Qt.UserRole, entity.id)
                exceptional_item.setData(QtCore.Qt.UserRole + 1, True)  # Exceptional variant
                
                is_exceptional_unlocked = entity.id in exceptional
                exc_name = entity.exceptional_name if entity.exceptional_name else f"{entity.name} ‚≠ê"
                exceptional_checkbox = QtWidgets.QCheckBox(f"  ‚≠ê {exc_name}")
                exceptional_checkbox.setChecked(is_exceptional_unlocked)
                # Golden gradient style for exceptional
                exceptional_checkbox.setStyleSheet(
                    "color: #FFD700; font-weight: bold; font-style: italic;"
                )
                
                exceptional_item.setSizeHint(exceptional_checkbox.sizeHint())
                self.entity_lock_list.addItem(exceptional_item)
                self.entity_lock_list.setItemWidget(exceptional_item, exceptional_checkbox)
            
            collected_count = sum(1 for e in entities if e.id in collected)
            exceptional_count = sum(1 for e in entities if e.id in exceptional)
            self.status_label.setText(
                f"üìã {story_id}: {collected_count}/{len(entities)} normal, "
                f"{exceptional_count}/{len(entities)} exceptional ‚≠ê"
            )
            self.status_label.setStyleSheet("color: #2196f3; padding: 10px;")
            
        except Exception as e:
            self.status_label.setText(f"‚ùå Error loading entities: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _unlock_all_entities(self) -> None:
        """Check all entity checkboxes (unlock all)."""
        for i in range(self.entity_lock_list.count()):
            item = self.entity_lock_list.item(i)
            checkbox = self.entity_lock_list.itemWidget(item)
            if checkbox:
                checkbox.setChecked(True)
        self.status_label.setText("‚úÖ All entities marked for unlock - click 'Apply Changes' to save")
        self.status_label.setStyleSheet("color: #4caf50; padding: 10px;")

    def _lock_all_entities(self) -> None:
        """Uncheck all entity checkboxes (lock all)."""
        for i in range(self.entity_lock_list.count()):
            item = self.entity_lock_list.item(i)
            checkbox = self.entity_lock_list.itemWidget(item)
            if checkbox:
                checkbox.setChecked(False)
        self.status_label.setText("üîí All entities marked for lock - click 'Apply Changes' to save")
        self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _apply_entity_lock_changes(self) -> None:
        """Apply the current checkbox states to the entitidex progress."""
        try:
            from entitidex import get_entity_by_id
            from gamification import get_entitidex_manager, save_entitidex_progress, _generate_exceptional_colors
            
            manager = get_entitidex_manager(self.blocker.adhd_buster)
            hero_power = manager.hero_power
            
            normal_unlocked = 0
            normal_locked = 0
            exceptional_unlocked = 0
            exceptional_locked = 0
            
            for i in range(self.entity_lock_list.count()):
                item = self.entity_lock_list.item(i)
                entity_id = item.data(QtCore.Qt.UserRole)
                is_exceptional = item.data(QtCore.Qt.UserRole + 1)
                checkbox = self.entity_lock_list.itemWidget(item)
                
                if not checkbox:
                    continue
                    
                is_checked = checkbox.isChecked()
                
                if is_exceptional:
                    # Handle exceptional variant
                    was_exceptional = entity_id in manager.progress.exceptional_entities
                    
                    if is_checked and not was_exceptional:
                        # Unlock exceptional - generate colors and record catch
                        exceptional_colors = _generate_exceptional_colors()
                        manager.progress.record_successful_catch(
                            entity_id=entity_id,
                            hero_power=hero_power,
                            probability=1.0,  # Dev forced unlock
                            was_lucky=False,
                            is_exceptional=True,
                            exceptional_colors=exceptional_colors,
                        )
                        # Also record as encountered if not already
                        if not manager.progress.is_encountered(entity_id):
                            manager.progress.record_encounter(entity_id)
                        exceptional_unlocked += 1
                    elif not is_checked and was_exceptional:
                        # Lock exceptional (remove from exceptional_entities)
                        del manager.progress.exceptional_entities[entity_id]
                        exceptional_locked += 1
                else:
                    # Handle normal variant
                    was_collected = entity_id in manager.progress.collected_entity_ids
                    
                    if is_checked and not was_collected:
                        # Unlock normal entity
                        manager.progress.record_successful_catch(
                            entity_id=entity_id,
                            hero_power=hero_power,
                            probability=1.0,  # Dev forced unlock
                            was_lucky=False,
                            is_exceptional=False,
                            exceptional_colors=None,
                        )
                        # Also record as encountered if not already
                        if not manager.progress.is_encountered(entity_id):
                            manager.progress.record_encounter(entity_id)
                        normal_unlocked += 1
                    elif not is_checked and was_collected:
                        # Lock normal entity (remove from collection)
                        manager.progress.collected_entity_ids.discard(entity_id)
                        normal_locked += 1
            
            # Save changes
            save_entitidex_progress(self.blocker.adhd_buster, manager)
            self.blocker.save_config()
            
            # Emit entities changed signal for timeline ring
            from game_state import get_game_state
            gs = get_game_state()
            if gs:
                gs.notify_entities_changed()
            
            # Refresh entitidex tab if available
            main_win = self.window()
            if hasattr(main_win, 'entitidex_tab'):
                main_win.entitidex_tab.refresh()
            
            # Build status message
            parts = []
            if normal_unlocked > 0:
                parts.append(f"{normal_unlocked} normal unlocked")
            if normal_locked > 0:
                parts.append(f"{normal_locked} normal locked")
            if exceptional_unlocked > 0:
                parts.append(f"{exceptional_unlocked} exceptional ‚≠ê unlocked")
            if exceptional_locked > 0:
                parts.append(f"{exceptional_locked} exceptional ‚≠ê locked")
            
            if parts:
                self.status_label.setText(f"‚úÖ Applied: {', '.join(parts)}")
            else:
                self.status_label.setText("‚ÑπÔ∏è No changes to apply")
            self.status_label.setStyleSheet("color: #4caf50; padding: 10px;")
            
        except Exception as e:
            self.status_label.setText(f"‚ùå Error applying changes: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    # ========================================================================
    # CITY SYSTEM DEV CONTROLS
    # ========================================================================

    def _refresh_city_display(self) -> None:
        """Refresh the city display (resources and grid)."""
        try:
            from city.city_manager import get_city_data, get_resources, get_placed_buildings
            from city.city_buildings import CITY_BUILDINGS, get_all_building_ids
            
            # Populate building combo if empty
            if self.city_building_combo.count() == 0:
                for bid in get_all_building_ids():
                    bdef = CITY_BUILDINGS.get(bid, {})
                    name = bdef.get("name", bid)
                    tier = bdef.get("tier", 1)
                    self.city_building_combo.addItem(f"T{tier}: {name}", bid)
            
            # Update resources display
            resources = get_resources(self.blocker.adhd_buster)
            res_text = "  |  ".join([
                f"üíß {resources.get('water', 0)}",
                f"üß± {resources.get('materials', 0)}",
                f"üèÉ {resources.get('activity', 0)}",
                f"üéØ {resources.get('focus', 0)}",
            ])
            self.city_resources_label.setText(f"Current: {res_text}")
            self.city_resources_label.setStyleSheet("color: #4caf50; padding: 5px;")
            
            # Update grid display
            city = get_city_data(self.blocker.adhd_buster)
            grid = city.get("grid", [])
            
            grid_lines = []
            for row_idx, row in enumerate(grid):
                row_parts = []
                for col_idx, cell in enumerate(row):
                    if cell is None:
                        row_parts.append("[ ]")
                    else:
                        bid = cell.get("building_id", "?")[:3].upper()
                        status = cell.get("status", "?")
                        level = cell.get("level", 1)
                        s_icon = {"placed": "üìç", "building": "üî®", "complete": "‚úÖ"}.get(status, "?")
                        row_parts.append(f"[{bid}{level}{s_icon}]")
                grid_lines.append(" ".join(row_parts))
            
            self.city_grid_label.setText("Grid (5√ó5):\n" + "\n".join(grid_lines))
            
        except Exception as e:
            self.city_resources_label.setText(f"‚ùå Error: {e}")

    def _add_city_resource(self, resource_type: str, amount: int) -> None:
        """Add city resources."""
        try:
            from city.city_manager import add_city_resource
            
            new_total = add_city_resource(self.blocker.adhd_buster, resource_type, amount)
            self.blocker.save_config()
            self._refresh_city_display()
            
            emoji = {"water": "üíß", "materials": "üß±", "scrap": "üî©", "activity": "üèÉ", "focus": "üéØ"}.get(resource_type, "üì¶")
            self.status_label.setText(f"‚úÖ Added {amount} {emoji} {resource_type}! New total: {new_total}")
            self.status_label.setStyleSheet("color: #4caf50; padding: 10px;")
            
            # Refresh city tab if available
            main_win = self.window()
            if hasattr(main_win, 'city_tab'):
                main_win.city_tab._refresh_city()
            
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _city_place_building(self) -> None:
        """Place a building at the selected cell."""
        try:
            from city.city_manager import place_building, get_city_data
            from city.city_state import CellStatus
            
            building_id = self.city_building_combo.currentData()
            row = self.city_row_spin.value()
            col = self.city_col_spin.value()
            
            if not building_id:
                self.status_label.setText("‚ùå No building selected")
                return
            
            success = place_building(self.blocker.adhd_buster, row, col, building_id)
            
            if success:
                self.blocker.save_config()
                self._refresh_city_display()
                self.status_label.setText(f"‚úÖ Placed {building_id} at ({row}, {col})")
                self.status_label.setStyleSheet("color: #4caf50; padding: 10px;")
                
                # Refresh city tab
                main_win = self.window()
                if hasattr(main_win, 'city_tab'):
                    main_win.city_tab._refresh_city()
            else:
                self.status_label.setText(f"‚ùå Could not place {building_id} at ({row}, {col})")
                self.status_label.setStyleSheet("color: #f44336; padding: 10px;")
                
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _city_complete_building(self) -> None:
        """Complete the building at the selected cell (mark as complete, set level)."""
        try:
            from city.city_manager import get_city_data
            from city.city_state import CellStatus
            from city.city_buildings import CITY_BUILDINGS
            from datetime import datetime
            
            row = self.city_row_spin.value()
            col = self.city_col_spin.value()
            level = self.city_level_spin.value()
            
            city = get_city_data(self.blocker.adhd_buster)
            grid = city.get("grid", [])
            
            if grid[row][col] is None:
                self.status_label.setText(f"‚ùå No building at ({row}, {col})")
                self.status_label.setStyleSheet("color: #f44336; padding: 10px;")
                return
            
            cell = grid[row][col]
            building_id = cell.get("building_id")
            building_def = CITY_BUILDINGS.get(building_id, {})
            max_level = building_def.get("max_level", 1)
            
            # Clamp level to max
            actual_level = min(level, max_level)
            
            # Set complete status
            cell["status"] = CellStatus.COMPLETE.value
            cell["level"] = actual_level
            cell["completed_at"] = datetime.now().isoformat()
            
            # Fill construction progress to match requirements
            from city.city_manager import get_level_requirements
            reqs = get_level_requirements(building_def, actual_level)
            cell["construction_progress"] = reqs.copy()
            
            self.blocker.save_config()
            self._refresh_city_display()
            
            self.status_label.setText(f"‚úÖ Completed {building_id} L{actual_level} at ({row}, {col})")
            self.status_label.setStyleSheet("color: #4caf50; padding: 10px;")
            
            # Refresh city tab
            main_win = self.window()
            if hasattr(main_win, 'city_tab'):
                main_win.city_tab._refresh_city()
                
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _city_remove_building(self) -> None:
        """Remove the building at the selected cell."""
        try:
            from city.city_manager import remove_building
            
            row = self.city_row_spin.value()
            col = self.city_col_spin.value()
            
            removed = remove_building(self.blocker.adhd_buster, row, col, refund=False)
            
            if removed:
                self.blocker.save_config()
                self._refresh_city_display()
                self.status_label.setText(f"‚úÖ Removed {removed} from ({row}, {col})")
                self.status_label.setStyleSheet("color: #ff9800; padding: 10px;")
                
                # Refresh city tab
                main_win = self.window()
                if hasattr(main_win, 'city_tab'):
                    main_win.city_tab._refresh_city()
            else:
                self.status_label.setText(f"‚ùå No building at ({row}, {col})")
                self.status_label.setStyleSheet("color: #f44336; padding: 10px;")
                
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _city_place_all_buildings(self) -> None:
        """Place all 10 buildings in the grid."""
        try:
            from city.city_manager import get_city_data, place_building
            from city.city_buildings import get_all_building_ids
            
            building_ids = get_all_building_ids()
            city = get_city_data(self.blocker.adhd_buster)
            grid = city.get("grid", [])
            
            placed = 0
            positions = [(r, c) for r in range(5) for c in range(5)]
            pos_idx = 0
            
            for bid in building_ids:
                # Find an empty cell
                while pos_idx < len(positions):
                    r, c = positions[pos_idx]
                    pos_idx += 1
                    if grid[r][c] is None:
                        if place_building(self.blocker.adhd_buster, r, c, bid):
                            placed += 1
                        break
            
            self.blocker.save_config()
            self._refresh_city_display()
            self.status_label.setText(f"‚úÖ Placed {placed} buildings!")
            self.status_label.setStyleSheet("color: #4caf50; padding: 10px;")
            
            # Refresh city tab
            main_win = self.window()
            if hasattr(main_win, 'city_tab'):
                main_win.city_tab._refresh_city()
                
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _city_complete_all_buildings(self) -> None:
        """Complete all placed buildings at level 1."""
        try:
            from city.city_manager import get_city_data
            from city.city_state import CellStatus
            from city.city_buildings import CITY_BUILDINGS
            from datetime import datetime
            
            city = get_city_data(self.blocker.adhd_buster)
            grid = city.get("grid", [])
            
            completed = 0
            for row in grid:
                for cell in row:
                    if cell is not None and cell.get("status") != CellStatus.COMPLETE.value:
                        cell["status"] = CellStatus.COMPLETE.value
                        cell["completed_at"] = datetime.now().isoformat()
                        completed += 1
            
            self.blocker.save_config()
            self._refresh_city_display()
            self.status_label.setText(f"‚úÖ Completed {completed} buildings!")
            self.status_label.setStyleSheet("color: #9c27b0; padding: 10px;")
            
            # Refresh city tab
            main_win = self.window()
            if hasattr(main_win, 'city_tab'):
                main_win.city_tab._refresh_city()
                
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _city_max_all_buildings(self) -> None:
        """Set all placed buildings to their max level."""
        try:
            from city.city_manager import get_city_data, get_level_requirements
            from city.city_state import CellStatus
            from city.city_buildings import CITY_BUILDINGS
            from datetime import datetime
            
            city = get_city_data(self.blocker.adhd_buster)
            grid = city.get("grid", [])
            
            maxed = 0
            for row in grid:
                for cell in row:
                    if cell is not None:
                        bid = cell.get("building_id")
                        bdef = CITY_BUILDINGS.get(bid, {})
                        max_level = bdef.get("max_level", 1)
                        
                        cell["status"] = CellStatus.COMPLETE.value
                        cell["level"] = max_level
                        cell["completed_at"] = datetime.now().isoformat()
                        
                        # Fill construction progress
                        reqs = get_level_requirements(bdef, max_level)
                        cell["construction_progress"] = reqs.copy()
                        maxed += 1
            
            self.blocker.save_config()
            self._refresh_city_display()
            self.status_label.setText(f"‚úÖ Maxed {maxed} buildings to max level!")
            self.status_label.setStyleSheet("color: #FFD700; padding: 10px;")
            
            # Refresh city tab
            main_win = self.window()
            if hasattr(main_win, 'city_tab'):
                main_win.city_tab._refresh_city()
                
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _city_clear_all(self) -> None:
        """Remove all buildings from the city grid."""
        try:
            from city.city_manager import get_city_data
            from city.city_state import create_empty_grid
            
            city = get_city_data(self.blocker.adhd_buster)
            city["grid"] = create_empty_grid()
            
            self.blocker.save_config()
            self._refresh_city_display()
            self.status_label.setText("üí• Cleared all buildings from city!")
            self.status_label.setStyleSheet("color: #b71c1c; padding: 10px;")
            
            # Refresh city tab
            main_win = self.window()
            if hasattr(main_win, 'city_tab'):
                main_win.city_tab._refresh_city()
                
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _city_reset_resources(self) -> None:
        """Reset all city resources to 0."""
        try:
            from city.city_manager import get_city_data
            
            city = get_city_data(self.blocker.adhd_buster)
            city["resources"] = {
                "water": 0,
                "materials": 0,
                "activity": 0,
                "focus": 0,
            }
            
            self.blocker.save_config()
            self._refresh_city_display()
            self.status_label.setText("üîÑ Reset all city resources to 0!")
            self.status_label.setStyleSheet("color: #455a64; padding: 10px;")
            
            # Refresh city tab
            main_win = self.window()
            if hasattr(main_win, 'city_tab'):
                main_win.city_tab._refresh_city()
                
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")

    def _city_give_all_resources(self) -> None:
        """Give 500 of each resource."""
        try:
            from city.city_manager import get_city_data
            
            city = get_city_data(self.blocker.adhd_buster)
            resources = city.get("resources", {})
            
            for r in ["water", "materials", "activity", "focus"]:
                resources[r] = resources.get(r, 0) + 500
            
            self.blocker.save_config()
            self._refresh_city_display()
            self.status_label.setText("üí∞ Added +500 to all resources!")
            self.status_label.setStyleSheet("color: #00bcd4; padding: 10px;")
            
            # Refresh city tab
            main_win = self.window()
            if hasattr(main_win, 'city_tab'):
                main_win.city_tab._refresh_city()
                
        except Exception as e:
            self.status_label.setText(f"‚ùå Error: {e}")
            self.status_label.setStyleSheet("color: #f44336; padding: 10px;")


# ============================================================================
# Global Hotkey Listener using pynput (reliable even when window hidden)
# ============================================================================

class HotkeyListener:
    """
    Global hotkey listener using pynput.
    Unlike Windows RegisterHotKey, this works reliably even when the window is hidden.
    """
    
    def __init__(self, callback: Callable[[], None]):
        """
        Initialize the hotkey listener.
        
        Args:
            callback: Function to call when hotkey is pressed (must be thread-safe!)
        """
        self._callback = callback
        self._listener: Optional[Any] = None
        self._running = False
        
        # Target key and modifiers
        self._target_key: Optional[Any] = None
        self._require_ctrl = False
        self._require_shift = False
        self._require_alt = False
        
        # Current modifier states
        self._ctrl_pressed = False
        self._shift_pressed = False
        self._alt_pressed = False
        
        self._lock = threading.Lock()
    
    def set_hotkey(self, key_sequence: str) -> bool:
        """
        Set the hotkey to listen for (e.g., "Ctrl+F11", "Ctrl+Shift+H").
        
        Args:
            key_sequence: Qt-style key sequence string
            
        Returns:
            True if hotkey was parsed successfully
        """
        if not PYNPUT_AVAILABLE or not pynput_keyboard:
            logger.warning("pynput not available, hotkey disabled")
            return False
        
        # Parse the key sequence
        parts = key_sequence.replace("+", " ").split()
        
        self._require_ctrl = False
        self._require_shift = False
        self._require_alt = False
        self._target_key = None
        
        for part in parts:
            part_lower = part.lower()
            if part_lower in ("ctrl", "control"):
                self._require_ctrl = True
            elif part_lower == "shift":
                self._require_shift = True
            elif part_lower in ("alt", "meta"):
                self._require_alt = True
            else:
                # This is the main key
                self._target_key = self._parse_key(part)
        
        if self._target_key is None:
            logger.warning(f"Could not parse hotkey: {key_sequence}")
            return False
        
        logger.info(f"Hotkey set: {key_sequence} -> ctrl={self._require_ctrl}, "
                   f"shift={self._require_shift}, alt={self._require_alt}, key={self._target_key}")
        return True
    
    def _parse_key(self, key_str: str) -> Optional[Any]:
        """Parse a key string to pynput key."""
        if not pynput_keyboard:
            return None
            
        key_str = key_str.upper()
        
        # Function keys F1-F12
        if key_str.startswith("F") and key_str[1:].isdigit():
            fnum = int(key_str[1:])
            if 1 <= fnum <= 12:
                return getattr(pynput_keyboard.Key, f"f{fnum}", None)
        
        # Special keys
        special_keys = {
            "ESCAPE": pynput_keyboard.Key.esc,
            "ESC": pynput_keyboard.Key.esc,
            "SPACE": pynput_keyboard.Key.space,
            "TAB": pynput_keyboard.Key.tab,
            "ENTER": pynput_keyboard.Key.enter,
            "RETURN": pynput_keyboard.Key.enter,
            "BACKSPACE": pynput_keyboard.Key.backspace,
            "DELETE": pynput_keyboard.Key.delete,
            "HOME": pynput_keyboard.Key.home,
            "END": pynput_keyboard.Key.end,
            "PAGEUP": pynput_keyboard.Key.page_up,
            "PAGEDOWN": pynput_keyboard.Key.page_down,
            "UP": pynput_keyboard.Key.up,
            "DOWN": pynput_keyboard.Key.down,
            "LEFT": pynput_keyboard.Key.left,
            "RIGHT": pynput_keyboard.Key.right,
            "INSERT": pynput_keyboard.Key.insert,
        }
        
        if key_str in special_keys:
            return special_keys[key_str]
        
        # Single character (letter or number)
        if len(key_str) == 1:
            return pynput_keyboard.KeyCode.from_char(key_str.lower())
        
        return None
    
    def _on_press(self, key) -> None:
        """Handle key press event."""
        if not pynput_keyboard:
            return
            
        with self._lock:
            # Track modifier states
            if key in (pynput_keyboard.Key.ctrl_l, pynput_keyboard.Key.ctrl_r, pynput_keyboard.Key.ctrl):
                self._ctrl_pressed = True
            elif key in (pynput_keyboard.Key.shift_l, pynput_keyboard.Key.shift_r, pynput_keyboard.Key.shift):
                self._shift_pressed = True
            elif key in (pynput_keyboard.Key.alt_l, pynput_keyboard.Key.alt_r, pynput_keyboard.Key.alt,
                        pynput_keyboard.Key.alt_gr):
                self._alt_pressed = True
            
            # Check if this is our target key with correct modifiers
            if self._target_key is not None:
                key_matches = False
                
                # Compare keys
                if isinstance(self._target_key, pynput_keyboard.Key):
                    key_matches = (key == self._target_key)
                elif isinstance(self._target_key, pynput_keyboard.KeyCode):
                    if hasattr(key, 'char') and key.char:
                        key_matches = (key.char.lower() == self._target_key.char.lower())
                    elif hasattr(key, 'vk') and hasattr(self._target_key, 'vk'):
                        key_matches = (key.vk == self._target_key.vk)
                
                if key_matches:
                    # Check modifiers
                    ctrl_ok = (self._ctrl_pressed == self._require_ctrl)
                    shift_ok = (self._shift_pressed == self._require_shift)
                    alt_ok = (self._alt_pressed == self._require_alt)
                    
                    if ctrl_ok and shift_ok and alt_ok:
                        logger.debug("Hotkey triggered!")
                        # Call callback (should emit a Qt signal for thread safety)
                        if self._callback:
                            self._callback()
    
    def _on_release(self, key) -> None:
        """Handle key release event."""
        if not pynput_keyboard:
            return
            
        with self._lock:
            # Track modifier states
            if key in (pynput_keyboard.Key.ctrl_l, pynput_keyboard.Key.ctrl_r, pynput_keyboard.Key.ctrl):
                self._ctrl_pressed = False
            elif key in (pynput_keyboard.Key.shift_l, pynput_keyboard.Key.shift_r, pynput_keyboard.Key.shift):
                self._shift_pressed = False
            elif key in (pynput_keyboard.Key.alt_l, pynput_keyboard.Key.alt_r, pynput_keyboard.Key.alt,
                        pynput_keyboard.Key.alt_gr):
                self._alt_pressed = False
    
    def start(self) -> bool:
        """Start listening for hotkeys in a background thread."""
        if not PYNPUT_AVAILABLE or not pynput_keyboard:
            logger.warning("pynput not available, cannot start hotkey listener")
            return False
        
        if self._running:
            return True
        
        try:
            self._listener = pynput_keyboard.Listener(
                on_press=self._on_press,
                on_release=self._on_release
            )
            self._listener.start()
            self._running = True
            logger.info("Hotkey listener started")
            return True
        except Exception as e:
            logger.error(f"Failed to start hotkey listener: {e}")
            return False
    
    def stop(self) -> None:
        """Stop listening for hotkeys."""
        if self._listener:
            try:
                self._listener.stop()
            except Exception as e:
                logger.debug(f"Error stopping listener: {e}")
            self._listener = None
        self._running = False
        logger.info("Hotkey listener stopped")
    
    def is_running(self) -> bool:
        """Check if listener is running."""
        return self._running


class FocusBlockerWindow(QtWidgets.QMainWindow):
    # Signal for cross-thread hotkey toggle (like MouseBrain)
    toggle_requested = QtCore.Signal()
    
    def __init__(self, username: Optional[str] = None) -> None:
        super().__init__()
        self.username = username  # Store for user switching
        self.setWindowTitle(f"Personal Liberty v{APP_VERSION}")
        if username and username != "Default":
            self.setWindowTitle(f"Personal Liberty v{APP_VERSION} - {username}")
        self.resize(900, 700)
        
        # Connect toggle signal to handler (for cross-thread communication from pynput)
        self.toggle_requested.connect(self._toggle_window_visibility)
        
        # Set application icon
        self._set_app_icon()

        self.blocker = BlockerCore(username=username)
        
        # Record app startup time for tracking
        self.blocker.record_startup_time()
        
        # Flag to prevent duplicate shutdown recording
        self._shutdown_recorded = False
        
        # Browser monitor for Light Mode (notifications instead of blocking)
        self.browser_monitor = None
        
        # Track last city construction contribution for reward dialog display
        self._last_city_contribution = None
        
        # Initialize centralized game state manager for reactive UI updates (required)
        self.game_state = None
        if GAMIFICATION_AVAILABLE:
            self.game_state = init_game_state(self.blocker)
            # Connect to global UI update signals
            self.game_state.power_changed.connect(self._on_power_changed)
            self.game_state.coins_changed.connect(self._on_coins_changed)
            self.game_state.xp_changed.connect(self._on_xp_changed)
            self.game_state.inventory_changed.connect(self._on_inventory_changed)
            self.game_state.full_refresh_required.connect(self._on_full_refresh_required)

        # Make window scrollable with scroll area
        scroll_area = QtWidgets.QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        scroll_area.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)
        self.setCentralWidget(scroll_area)
        
        central = QtWidgets.QWidget()
        scroll_area.setWidget(central)
        main_layout = QtWidgets.QVBoxLayout(central)

        # Quick access bar
        quick_bar = QtWidgets.QHBoxLayout()

        # Priorities button
        priorities_btn = QtWidgets.QPushButton("üéØ Priorities")
        priorities_btn.setStyleSheet("font-weight: bold; padding: 6px 12px;")
        priorities_btn.clicked.connect(self._open_priorities)
        quick_bar.addWidget(priorities_btn)

        # ADHD Buster button (only when gamification is available and not disabled)
        if GAMIFICATION_AVAILABLE:
            power = calculate_character_power(self.blocker.adhd_buster)
            self.buster_btn = QtWidgets.QPushButton(f"ü¶∏ HERO  ‚öî {power}")
            self.buster_btn.setStyleSheet("font-weight: bold; padding: 6px 12px;")
            self.buster_btn.clicked.connect(self._open_adhd_buster)
            # Hide if gamification is disabled
            if not is_gamification_enabled(self.blocker.adhd_buster):
                self.buster_btn.setVisible(False)
            quick_bar.addWidget(self.buster_btn)
            
            # Coin counter
            coins = self.blocker.adhd_buster.get("coins", 0)
            self.coin_label = QtWidgets.QPushButton(f"üí∞ {coins:,} Coins")
            
            # Build tooltip with lucky bonus info if available
            tooltip = "Your currency for unlocking features and boosters"
            if calculate_total_lucky_bonuses:
                equipped = self.blocker.adhd_buster.get("equipped", {})
                lucky_bonuses = calculate_total_lucky_bonuses(equipped)
                coin_discount = lucky_bonuses.get("coin_discount", 0)
                if coin_discount > 0:
                    effective_discount = min(coin_discount, 90)
                    tooltip += f"\n‚ú® Gear Bonus: {effective_discount}% off merge costs!"
            
            self.coin_label.setStyleSheet("font-weight: bold; padding: 6px 12px;")
            self.coin_label.setToolTip(tooltip)
            self.coin_label.clicked.connect(self._show_coin_info)
            if not is_gamification_enabled(self.blocker.adhd_buster):
                self.coin_label.setVisible(False)
            quick_bar.addWidget(self.coin_label)

        quick_bar.addStretch()
        
        # Username button - click to switch users
        current_user = self.blocker.user_dir.name if hasattr(self.blocker, 'user_dir') else "Default"
        self.user_btn = QtWidgets.QPushButton(f"üë§ {current_user}")
        self.user_btn.setStyleSheet("font-weight: bold; padding: 6px 12px;")
        self.user_btn.setToolTip("Click to switch user profiles")
        self.user_btn.clicked.connect(self._switch_user)
        quick_bar.addWidget(self.user_btn)
        
        self.admin_label = QtWidgets.QLabel()
        quick_bar.addWidget(self.admin_label)
        main_layout.addLayout(quick_bar)

        self._update_admin_label()

        # Daily Timeline (Hybrid View)
        self.timeline_widget = DailyTimelineWidget(self.blocker, self)
        main_layout.addWidget(self.timeline_widget)
        
        # Connect timeline ring clicks to tab navigation (connected after tabs created)
        self._connect_timeline_signals()

        self.tabs = QtWidgets.QTabWidget()
        self.tabs.setMovable(True)  # Allow drag-and-drop tab reordering
        self.tabs.currentChanged.connect(self._on_tab_changed)
        main_layout.addWidget(self.tabs)

        # === TAB ORDER: Timer | Hero | Story | Eye_Breath | Water | Activity | Weight | Sleep | Entitidex | Productivity | Schedule | Categories | Sites | AI Insights | Settings | Dev ===
        
        # 1. Timer tab
        self.timer_tab = TimerTab(self.blocker, self)
        self.tabs.addTab(self.timer_tab, "üéØ Focus")
        # Connect session signals to refresh stats and manage ADHD tab state
        self.timer_tab.session_complete.connect(self._on_session_complete)
        self.timer_tab.session_started.connect(self._on_session_started)

        # 2. Hero tab (gamification)
        if GAMIFICATION_AVAILABLE:
            self.adhd_tab = ADHDBusterTab(self.blocker, self)
            self.tabs.addTab(self.adhd_tab, "ü¶∏ Hero")

        # 3. Story tab (story mode, chapters, progress)
        if GAMIFICATION_AVAILABLE:
            self.story_tab = StoryTab(self.blocker, self)
            self.tabs.addTab(self.story_tab, "üìú Story")

        # 4. Eye Protection tab
        self.eye_tab = EyeProtectionTab(self.blocker)
        self.tabs.addTab(self.eye_tab, "üëÅÔ∏è Eyes")
        # Connect signal to show item drop dialog if item won
        self.eye_tab.routine_completed.connect(self._on_eye_routine_completed)

        # 4. Hydration tracking tab
        self.hydration_tab = HydrationTab(self.blocker, self)
        self.tabs.addTab(self.hydration_tab, "üíß Water")

        # 5. Activity tracking tab
        self.activity_tab = ActivityTab(self.blocker, self)
        self.tabs.addTab(self.activity_tab, "üèÉ Activity")

        # 6. Weight tracking tab
        self.weight_tab = WeightTab(self.blocker, self)
        self.tabs.addTab(self.weight_tab, "‚öñ Weight")

        # 7. Sleep tracking tab
        self.sleep_tab = SleepTab(self.blocker, self)
        self.tabs.addTab(self.sleep_tab, "üò¥ Sleep")

        # 8. Entitidex tab (entity collection)
        if GAMIFICATION_AVAILABLE:
            self.entitidex_tab = EntitidexTab(self.blocker, self)
            self.tabs.addTab(self.entitidex_tab, "üìñ Entitidex")

        # 8.5 City Building tab (gamified city builder)
        if CITY_AVAILABLE:
            self.city_tab = CityTab(self.blocker.adhd_buster, self)
            self.city_tab.request_save.connect(self.blocker.save_config)
            self.tabs.addTab(self.city_tab, "üè∞ City")

        # 9. Productivity/Stats tab
        self.stats_tab = StatsTab(self.blocker, self)
        self.tabs.addTab(self.stats_tab, "üìä Productivity")

        # 10. Schedule tab
        self.schedule_tab = ScheduleTab(self.blocker, self)
        self.tabs.addTab(self.schedule_tab, "üìÖ Schedule")

        # 11. Categories tab
        self.categories_tab = CategoriesTab(self.blocker, self)
        self.tabs.addTab(self.categories_tab, "üìÅ Categories")

        # 12. Sites tab
        self.sites_tab = SitesTab(self.blocker, self)
        self.tabs.addTab(self.sites_tab, "üåê Sites")

        # 13. AI Insights tab
        if AI_AVAILABLE:
            self.ai_tab = AITab(self.blocker, self)
            self.tabs.addTab(self.ai_tab, "üß† AI Insights")

        # 14. Settings tab
        self.settings_tab = SettingsTab(self.blocker, self)
        self.tabs.addTab(self.settings_tab, "‚öô Settings")
        # Connect dev mode enabled signal to dynamically add Dev tab
        self.settings_tab.dev_mode_enabled.connect(self._on_dev_mode_enabled)

        # 15. Developer tools tab (hidden by default, enabled by tapping version 7 times)
        self.dev_tab = None
        if GAMIFICATION_AVAILABLE and self.blocker.dev_mode_enabled:
            self._add_dev_tab()

        self.statusBar().showMessage(f"Personal Liberty v{APP_VERSION}")

        # System Tray setup
        self.tray_icon = None
        self._last_tray_minutes: Optional[int] = None  # Track displayed minutes to avoid unnecessary updates
        self._last_taskbar_minutes: Optional[int] = None  # Track taskbar icon minutes
        self._base_tray_pixmap: Optional[QtGui.QPixmap] = None  # Cache base icon for overlay
        self._base_window_icon: Optional[QtGui.QIcon] = None  # Cache base window icon
        self.minimize_to_tray = self.blocker.minimize_to_tray  # Load from config
        self._hotkey_id = 1
        self._hotkey_registered = False
        self._registered_hotkey = ""
        
        # pynput-based hotkey listener (more reliable than Windows RegisterHotKey)
        self._hotkey_listener: Optional[HotkeyListener] = None
        if PYNPUT_AVAILABLE:
            self._hotkey_listener = HotkeyListener(
                callback=lambda: self.toggle_requested.emit()
            )
        
        self._setup_system_tray()
        self._setup_window_icon()
        self._update_hotkey_registration()
        
        # Health reminder notification timer (checks every minute)
        self._health_reminder_timer = QtCore.QTimer(self)
        self._health_reminder_timer.timeout.connect(self._check_health_reminders)
        self._health_reminder_timer.start(60000)  # Check every 60 seconds

        # Check for crash recovery on startup
        QtCore.QTimer.singleShot(500, self._check_crash_recovery)

        # Check for first-run enforcement mode selection (before other prompts)
        QtCore.QTimer.singleShot(550, self._check_enforcement_mode_first_run)

        # Check for scheduled blocking
        QtCore.QTimer.singleShot(700, self._check_scheduled_blocking)

        # Show priorities on startup if enabled
        if self.blocker.show_priorities_on_startup:
            QtCore.QTimer.singleShot(600, self._check_priorities_on_startup)

        # Check for daily gear reward (delayed until after onboarding so story is selected)
        if GAMIFICATION_AVAILABLE:
            QtCore.QTimer.singleShot(900, self._show_onboarding_prompt)
            # Pre-load Entitidex tab in background for instant display when user clicks it
            QtCore.QTimer.singleShot(2000, self._preload_entitidex_tab)

    def _preload_entitidex_tab(self) -> None:
        """Pre-load the Entitidex tab UI in background for instant display."""
        if hasattr(self, 'entitidex_tab') and self.entitidex_tab:
            try:
                self.entitidex_tab.preload()
            except Exception as e:
                logger.warning(f"Failed to preload Entitidex tab: {e}")

    def _check_enforcement_mode_first_run(self) -> None:
        """
        Check if this is the first run and enforcement mode wasn't set by installer.
        
        If the user hasn't made a choice yet (neither installer nor previous run),
        show the EnforcementModeDialog to let them choose.
        """
        # Check if enforcement mode was already set (by installer or previous run)
        # The installer sets 'enforcement_mode_set_by_installer' flag
        # After user manually changes mode, we set 'enforcement_mode_user_selected'
        adhd_buster = self.blocker.adhd_buster
        
        # Skip if already configured
        if adhd_buster.get("enforcement_mode_configured", False):
            return
        
        # Check if installer set the mode (flag in config)
        # This is read from the config file that installer creates
        try:
            import json
            if self.blocker.config_path.exists():
                with open(self.blocker.config_path, 'r', encoding='utf-8') as f:
                    config_data = json.load(f)
                    if config_data.get("enforcement_mode_set_by_installer", False):
                        # Installer already set the mode - mark as configured
                        adhd_buster["enforcement_mode_configured"] = True
                        self.blocker.save_config()
                        return
        except Exception:
            pass  # Config read failed, continue to show dialog
        
        # First run without installer setting - show mode selection dialog
        dialog = EnforcementModeDialog(self.blocker, self, is_first_run=True)
        dialog.exec()
        
        # Mark as configured so we don't ask again
        adhd_buster["enforcement_mode_configured"] = True
        self.blocker.save_config()
        
        # Show user profile dialog for age/sex-specific health norms
        self._show_user_profile_first_run()
        
        # Update Settings tab if it exists
        if hasattr(self, 'settings_tab'):
            if hasattr(self.settings_tab, 'enforce_full_radio'):
                if self.blocker.enforcement_mode == EnforcementMode.LIGHT:
                    self.settings_tab.enforce_light_radio.setChecked(True)
                else:
                    self.settings_tab.enforce_full_radio.setChecked(True)
    
    def _show_user_profile_first_run(self) -> None:
        """Show the user profile dialog on first run to collect age and sex."""
        # Skip if profile already set
        if self.blocker.user_birth_year and self.blocker.user_gender:
            return
        
        dialog = UserProfileDialog(self.blocker, self, is_first_run=True)
        dialog.exec()
        # User can skip, which is fine - tabs will use default adult norms

    def _show_onboarding_prompt(self) -> None:
        """Ask the user how they want to play this session."""
        if not GAMIFICATION_AVAILABLE:
            return

        ensure_hero_structure(self.blocker.adhd_buster)

        # Skip if user already set 'skip_onboarding' flag
        if self.blocker.adhd_buster.get("skip_onboarding", False):
            # Still check for daily reward even if skipping onboarding
            self._check_daily_gear_reward()
            return

        dialog = OnboardingModeDialog(self.blocker, self)
        if dialog.exec() != QtWidgets.QDialog.Accepted:
            # Still check for daily reward even if dialog cancelled
            self._check_daily_gear_reward()
            return

        mode, story_id = dialog.get_selection()

        # Save 'Don't ask again' preference
        if dialog.should_skip_next_time():
            self.blocker.adhd_buster["skip_onboarding"] = True

        # Persist any pending flat changes before switching modes
        sync_hero_data(self.blocker.adhd_buster)

        if mode == STORY_MODE_ACTIVE:
            target_story = story_id or self.blocker.adhd_buster.get("active_story", "warrior")
            switch_story(self.blocker.adhd_buster, target_story)
        else:
            set_story_mode(self.blocker.adhd_buster, mode)

        if GAMIFICATION_AVAILABLE and hasattr(self, "buster_btn"):
            # Update button visibility and text based on mode
            enabled = is_gamification_enabled(self.blocker.adhd_buster)
            self.buster_btn.setVisible(enabled)
            if enabled:
                power = calculate_character_power(self.blocker.adhd_buster)
                self.buster_btn.setText(f"ü¶∏ HERO  ‚öî {power}")

        self.blocker.save_config()
        
        # Now check for daily gear reward AFTER story is selected
        self._check_daily_gear_reward()

    def _check_priorities_on_startup(self) -> None:
        """Check if priorities dialog should be shown on startup."""
        if not self.blocker.show_priorities_on_startup:
            return
        
        # Check if today is a day with any priorities
        today = datetime.now().strftime("%A")
        has_priority_today = False
        
        for priority in self.blocker.priorities:
            title = priority.get("title", "").strip()
            days = priority.get("days", [])
            if title and (not days or today in days):
                has_priority_today = True
                break
        
        # Show dialog if there are priorities for today, or if no priorities set yet
        if has_priority_today or not any(p.get("title", "").strip() for p in self.blocker.priorities):
            self._open_priorities()

    def _check_crash_recovery(self) -> None:
        """Check for orphaned sessions from a previous crash and offer recovery."""
        orphaned = self.blocker.check_orphaned_session()

        if orphaned is None:
            return

        # Format crash info
        if orphaned.get("unknown"):
            crash_info = "An unknown previous session"
        else:
            start_time = orphaned.get("start_time", "unknown")
            mode = orphaned.get("mode", "unknown")
            try:
                from datetime import datetime
                dt = datetime.fromisoformat(start_time)
                time_str = dt.strftime("%Y-%m-%d %H:%M")
            except (ValueError, TypeError):
                time_str = start_time
            crash_info = f"A session started at {time_str} (mode: {mode})"

        # Ask user what to do - custom buttons
        result = styled_question(
            self,
            "Crash Recovery Detected",
            f"‚ö†Ô∏è {crash_info} did not shut down properly.\n\nSome websites may still be blocked.\n\n"
            "Would you like to remove all blocks and clean up?",
            ["Remove Blocks", "Keep Blocks", "Decide Later"]
        )

        if result == "Remove Blocks":
            success, message = self.blocker.recover_from_crash()
            if success:
                show_info(self, "Recovery Complete", "‚úÖ All blocks have been removed.\n\nYour browser should now be able to access all websites.")
            else:
                show_error(self, "Recovery Failed", f"Could not clean up: {message}\n\nTry using 'Emergency Cleanup' in Settings tab.")
        elif result == "Keep Blocks":
            self.blocker.clear_session_state()
            show_info(self, "Blocks Retained", "The blocks have been kept.\n\nUse 'Emergency Cleanup' in Settings tab when you want to remove them.")

    def _switch_user(self) -> None:
        """Open user selection dialog to switch profiles without restarting."""
        # Check if a session is running - require stop first
        if hasattr(self, 'timer_tab') and self.timer_tab.timer_running:
            show_warning(
                self, 
                "Session Active",
                "A focus session is currently running.\n\n"
                "Please stop the session before switching profiles."
            )
            return
        
        # Check if GameState has pending batch operations
        if hasattr(self, 'game_state') and self.game_state:
            if getattr(self.game_state, '_batch_depth', 0) > 0:
                show_warning(
                    self,
                    "Operation in Progress",
                    "A game operation is currently in progress.\n\n"
                    "Please wait for it to complete before switching profiles."
                )
                return
        
        if show_question(self, "Switch User", 
                        "Are you sure you want to switch profiles?") == QtWidgets.QMessageBox.Yes:
            try:
                from core_logic import APP_DIR
                from user_manager import UserManager
                from user_selection_dialog import UserSelectionDialog
                
                # Save current user's config first
                self.blocker.save_config()
                # Ensure stats are saved to prevent data loss during switch
                self.blocker.save_stats()
                
                # Show user selection dialog
                um = UserManager(APP_DIR)
                selection_dialog = UserSelectionDialog(um, parent=self)
                
                if selection_dialog.exec() == QtWidgets.QDialog.Accepted:
                    new_user = selection_dialog.selected_user
                    if new_user and new_user != self.username:
                        # Save new user as last user
                        um.save_last_user(new_user)
                        
                        # Reload the main window with new user
                        self._reload_user(new_user)
                        
                        show_info(self, "Profile Switched", f"Switched to profile: {new_user}")
                    elif new_user == self.username:
                        show_info(self, "Same Profile", "You selected the same profile.")
                        
            except Exception as e:
                show_error(self, "Error", f"Could not switch user: {e}")
    
    def _reload_user(self, new_username: str) -> None:
        """Reload the application state with a new user profile without restarting.
        
        DEVELOPER NOTE:
        If you add a new tab/component to the app, you MUST update this method
        to ensure the new component receives the new 'blocker' and 'game_state'
        instances. Otherwise, it will continue using the old user's data!
        """
        try:
            # Update username
            self.username = new_username
            
            # Update window title
            if new_username and new_username != "Default":
                self.setWindowTitle(f"Personal Liberty v{APP_VERSION} - {new_username}")
            else:
                self.setWindowTitle(f"Personal Liberty v{APP_VERSION}")
            
            # Update user button
            if hasattr(self, 'user_btn'):
                self.user_btn.setText(f"üë§ {new_username}")
            
            # Create new blocker with new user's data
            old_blocker = self.blocker
            self.blocker = BlockerCore(username=new_username)
            
            # Reset session-specific flags for new user
            self._shutdown_recorded = False
            self._last_city_contribution = None
            
            # Record startup time for new user
            self.blocker.record_startup_time()
            
            # Re-initialize game state manager with new user's data
            if GAMIFICATION_AVAILABLE and hasattr(self, 'game_state') and self.game_state:
                # Disconnect old signals
                try:
                    self.game_state.power_changed.disconnect()
                    self.game_state.coins_changed.disconnect()
                    self.game_state.xp_changed.disconnect()
                    self.game_state.inventory_changed.disconnect()
                    self.game_state.full_refresh_required.disconnect()
                except Exception:
                    pass
                
                # Reset global singleton to prevent stale references in other components
                if reset_game_state:
                    reset_game_state()
                
                # Create new game state
                self.game_state = init_game_state(self.blocker)
                # Reconnect signals
                self.game_state.power_changed.connect(self._on_power_changed)
                self.game_state.coins_changed.connect(self._on_coins_changed)
                self.game_state.xp_changed.connect(self._on_xp_changed)
                self.game_state.inventory_changed.connect(self._on_inventory_changed)
                self.game_state.full_refresh_required.connect(self._on_full_refresh_required)
            
            # Update all tabs with new blocker reference
            if hasattr(self, 'timer_tab'):
                self.timer_tab.blocker = self.blocker
                self.timer_tab._refresh_quick_stats()
            
            if hasattr(self, 'stats_tab'):
                self.stats_tab.blocker = self.blocker
                self.stats_tab.refresh()
            
            if hasattr(self, 'sites_tab'):
                self.sites_tab.blocker = self.blocker
                self.sites_tab._refresh_lists()
            
            if hasattr(self, 'settings_tab'):
                self.settings_tab.blocker = self.blocker
                # SettingsTab doesn't have a load method, update relevant UI
                if hasattr(self.settings_tab, '_update_pwd_status'):
                    self.settings_tab._update_pwd_status()
                if hasattr(self.settings_tab, '_update_enforcement_status'):
                    self.settings_tab._update_enforcement_status()
            
            if hasattr(self, 'categories_tab'):
                self.categories_tab.blocker = self.blocker
                if hasattr(self.categories_tab, 'refresh'):
                    self.categories_tab.refresh()
            
            if hasattr(self, 'adhd_tab'):
                self.adhd_tab.blocker = self.blocker
                # CRITICAL: Update game state reference - the old one is stale
                if hasattr(self.adhd_tab, '_game_state') and self.game_state:
                    # Disconnect old signals
                    try:
                        old_gs = self.adhd_tab._game_state
                        if old_gs:
                            old_gs.power_changed.disconnect(self.adhd_tab._on_power_changed)
                            old_gs.equipment_changed.disconnect(self.adhd_tab._on_equipment_changed)
                            old_gs.set_bonus_changed.disconnect(self.adhd_tab._on_set_bonus_changed)
                            old_gs.story_changed.disconnect(self.adhd_tab._on_story_changed)
                    except Exception:
                        pass
                    # Update reference to new game state
                    self.adhd_tab._game_state = self.game_state
                    # Reconnect signals
                    self.game_state.power_changed.connect(self.adhd_tab._on_power_changed)
                    self.game_state.equipment_changed.connect(self.adhd_tab._on_equipment_changed)
                    self.game_state.set_bonus_changed.connect(self.adhd_tab._on_set_bonus_changed)
                    self.game_state.story_changed.connect(self.adhd_tab._on_story_changed)
                if hasattr(self.adhd_tab, 'refresh_all'):
                    self.adhd_tab.refresh_all()
            
            if hasattr(self, 'story_tab'):
                self.story_tab.blocker = self.blocker
                # CRITICAL: Update game state reference - the old one is stale
                if hasattr(self.story_tab, '_game_state') and self.game_state:
                    # Disconnect old signals
                    try:
                        old_gs = self.story_tab._game_state
                        if old_gs:
                            old_gs.story_changed.disconnect(self.story_tab._on_story_changed)
                            old_gs.power_changed.disconnect(self.story_tab._on_power_changed)
                    except Exception:
                        pass
                    # Update reference to new game state
                    self.story_tab._game_state = self.game_state
                    # Reconnect signals
                    self.game_state.story_changed.connect(self.story_tab._on_story_changed)
                    self.game_state.power_changed.connect(self.story_tab._on_power_changed)
                if hasattr(self.story_tab, '_refresh_all'):
                    self.story_tab._refresh_all()
            
            if hasattr(self, 'hydration_tab'):
                self.hydration_tab.blocker = self.blocker
                if hasattr(self.hydration_tab, '_refresh_display'):
                    self.hydration_tab._refresh_display()
            
            if hasattr(self, 'activity_tab'):
                self.activity_tab.blocker = self.blocker
                if hasattr(self.activity_tab, '_refresh_display'):
                    self.activity_tab._refresh_display()
            
            if hasattr(self, 'eye_tab'):
                self.eye_tab.blocker = self.blocker
                if hasattr(self.eye_tab, '_refresh_display'):
                    self.eye_tab._refresh_display()
            
            if hasattr(self, 'weight_tab'):
                self.weight_tab.blocker = self.blocker
                if hasattr(self.weight_tab, '_refresh_display'):
                    self.weight_tab._refresh_display()
            
            if hasattr(self, 'sleep_tab'):
                self.sleep_tab.blocker = self.blocker
                if hasattr(self.sleep_tab, '_refresh_display'):
                    self.sleep_tab._refresh_display()
            
            if hasattr(self, 'entitidex_tab'):
                self.entitidex_tab.blocker = self.blocker
                # Reload progress from new blocker's adhd_buster
                if hasattr(self.entitidex_tab, 'reload_data'):
                    self.entitidex_tab.reload_data()
                elif hasattr(self.entitidex_tab, 'refresh'):
                    self.entitidex_tab.refresh()
            
            if hasattr(self, 'city_tab'):
                self.city_tab.blocker = self.blocker
                # CRITICAL: CityTab caches adhd_buster - must update it!
                self.city_tab.adhd_buster = self.blocker.adhd_buster
                if hasattr(self.city_tab, '_refresh_city'):
                    self.city_tab._refresh_city()
            
            if hasattr(self, 'schedule_tab'):
                self.schedule_tab.blocker = self.blocker
                if hasattr(self.schedule_tab, '_refresh_table'):
                    self.schedule_tab._refresh_table()
            
            if hasattr(self, 'ai_tab'):
                self.ai_tab.blocker = self.blocker
                # Reload AI components with new paths
                if hasattr(self.ai_tab, 'reload_components'):
                    self.ai_tab.reload_components(self.blocker)
            
            # Update timeline widget - CRITICAL: reconnect game state signals
            if hasattr(self, 'timeline_widget'):
                self.timeline_widget.blocker = self.blocker
                # Disconnect from old game state and reconnect to new
                if hasattr(self.timeline_widget, 'reconnect_game_state'):
                    self.timeline_widget.reconnect_game_state()
                elif hasattr(self.timeline_widget, 'update_data'):
                    self.timeline_widget.update_data()
            
            # Update DevTab if it exists (hidden developer tools)
            if hasattr(self, 'dev_tab') and self.dev_tab:
                self.dev_tab.blocker = self.blocker
            
            # Update quick bar elements
            if GAMIFICATION_AVAILABLE:
                if hasattr(self, 'buster_btn'):
                    power = calculate_character_power(self.blocker.adhd_buster)
                    self.buster_btn.setText(f"ü¶∏ HERO  ‚öî {power}")
                    self.buster_btn.setVisible(is_gamification_enabled(self.blocker.adhd_buster))
                
                if hasattr(self, 'coin_label'):
                    coins = self.blocker.adhd_buster.get("coins", 0)
                    self.coin_label.setText(f"üí∞ {coins:,} Coins")
                    self.coin_label.setVisible(is_gamification_enabled(self.blocker.adhd_buster))
            
            # Update admin label
            self._update_admin_label()
            
            # Update tray icon tooltip
            if hasattr(self, 'tray_icon'):
                self.tray_icon.setToolTip(f"Personal Liberty - {new_username}")
            
            # Restart browser monitor with new user's blacklist
            # BrowserMonitor holds a list of blocked sites passed at creation.
            # We must restart it to pick up the new user's settings.
            self._stop_browser_monitor()
            self._start_browser_monitor()
            
            logger.info(f"Successfully switched to user profile: {new_username}")
            
        except Exception as e:
            logger.error(f"Error reloading user: {e}")
            import traceback
            traceback.print_exc()
            show_error(self, "Error", f"Failed to reload user profile: {e}\n\nPlease restart the application.")

    def _update_admin_label(self) -> None:
        if hasattr(self, "admin_label"):
            if self.blocker.is_admin():
                self.admin_label.setText("‚úÖ Admin")
                self.admin_label.setStyleSheet("color: green; font-weight: bold;")
                self.admin_label.setToolTip("Running with administrator privileges - website blocking will work.")
            else:
                self.admin_label.setText("‚ö† Not Admin")
                self.admin_label.setStyleSheet("color: #d32f2f; font-weight: bold;")
                self.admin_label.setToolTip(
                    "Not running as administrator - website blocking won't work!\n\n"
                    "Right-click the app and select 'Run as administrator',\n"
                    "or use the 'run_as_admin.bat' script."
                )
    
    def _check_health_reminders(self) -> None:
        """Check if any health reminder notifications should be shown."""
        from datetime import datetime
        now = datetime.now()
        
        # Check Eye & Breath reminder
        if getattr(self.blocker, 'eye_reminder_enabled', False):
            interval = getattr(self.blocker, 'eye_reminder_interval', 60)
            last_time_str = getattr(self.blocker, 'eye_last_reminder_time', None)
            
            should_remind = False
            if not last_time_str:
                should_remind = True
            else:
                try:
                    last_time = datetime.fromisoformat(last_time_str)
                    elapsed = (now - last_time).total_seconds() / 60
                    if elapsed >= interval:
                        should_remind = True
                except (ValueError, TypeError):
                    should_remind = True
            
            if should_remind:
                self.blocker.eye_last_reminder_time = now.isoformat()
                self.blocker.save_config()
                self._show_health_reminder(
                    "eye",
                    "üëÅÔ∏è Eyes Reminder",
                    "Time for an eye routine! Rest your eyes with blinks and far gazing."
                )
        
        # Check Water/Hydration reminder
        if getattr(self.blocker, 'water_reminder_enabled', False):
            interval = getattr(self.blocker, 'water_reminder_interval', 60)
            last_time_str = getattr(self.blocker, 'water_last_reminder_time', None)
            
            should_remind = False
            if not last_time_str:
                should_remind = True
            else:
                try:
                    last_time = datetime.fromisoformat(last_time_str)
                    elapsed = (now - last_time).total_seconds() / 60
                    if elapsed >= interval:
                        should_remind = True
                except (ValueError, TypeError):
                    should_remind = True
            
            if should_remind:
                self.blocker.water_last_reminder_time = now.isoformat()
                self.blocker.save_config()
                self._show_health_reminder(
                    "water",
                    "üíß Hydration Reminder",
                    "Time to drink some water! Stay hydrated for better focus."
                )
    
    def _show_health_reminder(self, reminder_type: str, title: str, message: str) -> None:
        """Show a health reminder using the user's preferred notification method.
        
        Args:
            reminder_type: 'eye' or 'water' to look up the right setting
            title: The notification title
            message: The notification message
        """
        # 50 eye reminder variants (always start with Eyes/Look/Vision)
        EYE_MESSAGES = [
            "Eyes need rest. Blink like a champion.",
            "Look away now. Your screen isn't going anywhere.",
            "Eyes! Stop staring. Do the 20-20-20 thing.",
            "Vision break time. Blink like you mean it.",
            "Eyes are requesting a break. Give them one.",
            "Look at something far away. Like your dreams.",
            "Eyes demand justice. Justice is blinking.",
            "Vision checkpoint. Blink and gaze far.",
            "Eyes tired? Obviously. Look away.",
            "Look outside. Remember the real world?",
            "Eyes: the original notification system. Listen to them.",
            "Vision maintenance required. Blink rapidly.",
            "Eyes are not invincible. Treat them better.",
            "Look at the ceiling. It misses you.",
            "Eyes need attention. That's what this is.",
            "Vision break. Pretend you're meditating.",
            "Eyes! Far gazing. Now. Not negotiable.",
            "Look away. Your future self will appreciate it.",
            "Eyes are delicate. Unlike your deadlines.",
            "Vision timeout. Your corneas will thank you.",
            "Eyes need moisture. Blink generously.",
            "Look at nature. Or a plant. Something green.",
            "Eyes need TLC. The L stands for Look Away.",
            "Vision rest. Because clear sight is convenient.",
            "Eyes deserve better. Apologize with blinking.",
            "Look far. Your retinas are asking nicely.",
            "Eyes: closing them counts as a break too.",
            "Vision protection time. Future you says thanks.",
            "Eyes need variety. Give them something new to see.",
            "Look away before they unionize.",
            "Eyes have limits. You've found them. Blink.",
            "Vision break. Your eyes will love you for it.",
            "Eyes need care. Just like everything else.",
            "Look elsewhere. The pixels will survive.",
            "Eyes need refresh. Moisten them with blinking.",
            "Vision break. It's self-care but lazier.",
            "Eyes are requesting downtime. Listen to them.",
            "Look out the window. Touch grass with your eyes.",
            "Eyes need downtime. Give it to them.",
            "Vision maintenance. Like oil changes but for eyeballs.",
            "Eyes! Blink! Now! This is urgent!",
            "Look at something 20 feet away. Doctor's orders.",
            "Eyes are not designed for this. Help them out.",
            "Vision break time. Because LASIK is expensive.",
            "Eyes: the unsung heroes. Give them a rest.",
            "Look away. Your boss can wait 20 seconds.",
            "Eyes need recovery mode. Activate it.",
            "Vision timeout. Future sight depends on it.",
            "Eyes have feelings too. Nice feelings. Blink.",
            "Look far away. Pretend it's a mini vacation."
        ]
        
        # 50 water reminder variants (always start with Water/Drink/Hydrate)
        WATER_MESSAGES = [
            "Water time. Hydrate like a boss.",
            "Drink something. Your cells are waiting.",
            "Hydrate now. Your kidneys will appreciate it.",
            "Water break. Because hydration is essential.",
            "Drink up. Your body deserves it.",
            "Hydration checkpoint. Sip and prosper.",
            "Water! Drink it. Science recommends it.",
            "Drink water. Coffee doesn't count. Nice try.",
            "Hydrate for peak performance.",
            "Water time. Your brain will thank you.",
            "Drink something wet. Preferably water.",
            "Hydration alert. Time to refresh.",
            "Water break. Because hydration matters.",
            "Drink water. Your skin will love you.",
            "Hydrate immediately. This is important.",
            "Water time. Your organs need refreshment.",
            "Drink up. Hydration improves everything.",
            "Hydration required. Time to refuel.",
            "Water! Your body chemistry needs balance.",
            "Drink something. Your concentration needs it.",
            "Hydrate now. Future you will feel great.",
            "Water time. Because hydration is smart.",
            "Drink water. Your metabolism will speed up.",
            "Hydration break. Your cells need moisture.",
            "Water! Drinking it keeps you sharp.",
            "Drink up. Your blood flows better hydrated.",
            "Hydrate for optimal function.",
            "Water time. Refresh your internal systems.",
            "Drink something. Water is ideal.",
            "Hydration checkpoint. Your body is asking.",
            "Water break. Because humans need water. Fact.",
            "Drink now. Your energy will improve.",
            "Hydrate immediately. Your clarity needs it.",
            "Water time. Your body needs maintenance.",
            "Drink up. Hydration improves mood.",
            "Hydration required. Your body is ready.",
            "Water! Because biological systems need care.",
            "Drink something. Your body will celebrate.",
            "Hydrate now. Your focus will sharpen.",
            "Water time. Your cognitive function needs it.",
            "Drink water. Your organs work better hydrated.",
            "Hydration break. Because it feels refreshing.",
            "Water! Eight glasses a day is smart.",
            "Drink up. Your body is mostly water. Top it off.",
            "Hydrate for better health. Simple as that.",
            "Water time. Your electrolytes need balance.",
            "Drink something. Your system needs support.",
            "Hydration alert. Time to refresh and recharge.",
            "Water! Because your body loves being hydrated.",
            "Drink now. Your health depends on it."
        ]
        
        # Get user's notification preference
        if reminder_type == "eye":
            pref = getattr(self.blocker, 'eye_reminder_notification_type', 'Toast')
            emoji = "üëÅÔ∏è"
            msg_index = getattr(self.blocker, 'eye_reminder_message_index', 0)
            voice_msg = EYE_MESSAGES[msg_index % 50]
            # Increment and save for next time
            self.blocker.eye_reminder_message_index = (msg_index + 1) % 50
            self.blocker.save_config()
        else:  # water
            pref = getattr(self.blocker, 'water_reminder_notification_type', 'Toast')
            emoji = "üíß"
            msg_index = getattr(self.blocker, 'water_reminder_message_index', 0)
            voice_msg = WATER_MESSAGES[msg_index % 50]
            # Increment and save for next time
            self.blocker.water_reminder_message_index = (msg_index + 1) % 50
            self.blocker.save_config()
        
        # Normalize pref (in case of old data or corruption)
        pref = pref if pref in ("Toast", "Voice", "Sound", "Sound + Voice") else "Toast"
        
        # Show toast if selected
        if pref == "Toast":
            show_perk_toast(message, emoji, self)
        
        # Play sound if selected
        if pref in ("Sound", "Sound + Voice"):
            try:
                from entitidex.celebration_audio import CelebrationAudioManager
                audio = CelebrationAudioManager.get_instance()
                # Use the default celebration sound as notification chime
                audio.play("default")
            except Exception:
                pass  # Sound playback optional
        
        # Speak with TTS if selected
        if pref in ("Voice", "Sound + Voice"):
            try:
                from eye_protection_tab import GuidanceManager, PIPER_WORKING
                if PIPER_WORKING:
                    guidance = GuidanceManager.get_instance()
                    guidance.say(voice_msg)
            except Exception:
                pass  # Voice playback optional, fallback to toast
                if pref == "Voice":
                    # Voice was the only selected method but failed, show toast as fallback
                    show_perk_toast(message, emoji, self)
    
    def _update_coin_display(self) -> None:
        """Update the coin counter in the toolbar."""
        if GAMIFICATION_AVAILABLE and hasattr(self, 'coin_label'):
            coins = self.blocker.adhd_buster.get("coins", 0)
            self.coin_label.setText(f"üí∞ {coins:,} Coins")
    
    # === GameState Signal Handlers (Reactive UI Updates) ===
    
    def _on_power_changed(self, new_power: int) -> None:
        """Handle power change signal - update power display in toolbar."""
        if hasattr(self, 'buster_btn'):
            self.buster_btn.setText(f"ü¶∏ HERO  ‚öî {new_power}")
    
    def _on_coins_changed(self, new_coins: int) -> None:
        """Handle coins change signal - update coin display in toolbar."""
        if hasattr(self, 'coin_label'):
            self.coin_label.setText(f"üí∞ {new_coins:,} Coins")

    def _on_xp_changed(self, new_xp: int, new_level: int) -> None:
        """Handle XP change signal - update timeline XP ring."""
        if hasattr(self, 'timeline_widget'):
            self.timeline_widget.update_data()
    
    def _on_inventory_changed(self) -> None:
        """Handle inventory change signal - refresh ADHD tab if visible."""
        if GAMIFICATION_AVAILABLE and hasattr(self, 'adhd_tab'):
            # Only refresh inventory-specific parts, not full refresh
            if hasattr(self.adhd_tab, '_refresh_inventory'):
                self.adhd_tab._refresh_inventory()
            if hasattr(self.adhd_tab, '_refresh_all_slot_combos'):
                self.adhd_tab._refresh_all_slot_combos()
    
    def _on_full_refresh_required(self) -> None:
        """Handle full refresh signal - comprehensive UI update."""
        if GAMIFICATION_AVAILABLE and hasattr(self, 'adhd_tab'):
            self.adhd_tab.refresh_all()
        self._update_coin_display()
        if hasattr(self, 'buster_btn') and calculate_character_power:
            power = calculate_character_power(self.blocker.adhd_buster)
            self.buster_btn.setText(f"ü¶∏ HERO  ‚öî {power}")
    
    def _show_coin_info(self) -> None:
        """Show information about the coin economy."""
        coins = self.blocker.adhd_buster.get("coins", 0)
        
        # Build bonus info if lucky gear is equipped
        bonus_info = ""
        if calculate_total_lucky_bonuses:
            equipped = self.blocker.adhd_buster.get("equipped", {})
            lucky_bonuses = calculate_total_lucky_bonuses(equipped)
            coin_discount = lucky_bonuses.get("coin_discount", 0)
            if coin_discount > 0:
                effective_discount = min(coin_discount, 90)
                bonus_info = f"<p style='color: #8b5cf6;'><b>‚ú® Active Gear Bonus: {effective_discount}% off merge costs!</b></p>"
        
        message = (
            f"<h2>Your Balance: {coins:,} Coins</h2>"
            f"{bonus_info}"
            "<p><b>How to Earn Coins:</b></p>"
            "<ul>"
            "<li><b>Focus Sessions:</b> 10 Coins per hour</li>"
            "<li><b>Strategic Priority:</b> 25 Coins per hour (2.5x multiplier!)</li>"
            "<li><b>Streak Bonuses:</b> 10 coins @ 3 days, 25 @ 7 days, 50 @ 14 days, 100 @ 30+ days</li>"
            "<li><b>Entity Perks:</b> Collected entities can grant flat coin bonuses or % boosts</li>"
            "<li><b>Perfect Session:</b> Some entities reward extra coins for no distraction attempts</li>"
            "</ul>"
            "<p><b>What You Can Buy:</b></p>"
            "<ul>"
            "<li><b>Lucky Merge (Base):</b> 50 Coins - Merge 3 items into 1 better item</li>"
            "<li><b>Merge Boost:</b> 50 Coins - +25% success rate for merge</li>"
            "<li><b>Tier Upgrade:</b> 50 Coins - Upgrade result tier by one on success</li>"
            "<li><b>Retry Bump:</b> 50 Coins - On failure, bump success % by 5% and retry</li>"
            "<li><b>Claim Near-Miss:</b> 100 Coins - Claim item on near-miss failure (‚â§5%)</li>"
            "<li><b>Salvage:</b> 50 Coins - On failure, save one random item from merge</li>"
            "<li><b>Optimize Gear:</b> 10 Coins - Auto-equip best gear for power/lucky options</li>"
            "<li><b>Unlock Story:</b> 100 Coins - Unlock new character themes (Underdog is free)</li>"
            "</ul>"
            "<p><i>üí° Tip: Mark one priority as 'Strategic' to get 2.5x coins per hour!</i></p>"
            "<p><i>‚ú® Lucky Gear with coin_discount reduces merge costs by up to 90%!</i></p>"
        )
        show_info(self, "üí∞ Coin Economy", message)

    def _check_scheduled_blocking(self) -> None:
        """Check if we should be blocking based on schedule."""
        if self.blocker.is_scheduled_block_time() and not self.blocker.is_blocking:
            result = show_question(
                self, "Scheduled Block",
                "You have a blocking schedule active now.\nStart blocking?"
            )
            if result == QtWidgets.QMessageBox.Yes:
                self.blocker.mode = BlockMode.SCHEDULED
                self.blocker.block_sites(duration_seconds=8 * 60 * 60)
                self.timer_tab._update_timer_display()

        # Check again in 60 seconds
        QtCore.QTimer.singleShot(60000, self._check_scheduled_blocking)

    def _check_daily_gear_reward(self) -> None:
        """Check if user should receive a daily gear reward.
        
        On first app start: Always award gear.
        On subsequent starts: 10% chance per day.
        Gear is one tier higher than current equipped tier.
        
        Work day starts at 5:00 AM - anything before 5 AM counts as the previous day.
        This prevents rewards from resetting at midnight for night owls.
        """
        if not GAMIFICATION_AVAILABLE:
            return
        # Skip if gamification mode is disabled
        if not is_gamification_enabled(self.blocker.adhd_buster):
            return
        
        # Use work day logic - day starts at 5 AM, not midnight
        today = get_work_day_date()
        last_reward_date = self.blocker.adhd_buster.get("last_daily_reward_date", "")
        first_launch = self.blocker.adhd_buster.get("first_launch_complete", False)
        
        # Already received reward today (using work day)
        if last_reward_date == today:
            return
        
        # Determine if we should give reward
        should_reward = False
        reward_reason = ""
        
        if not first_launch:
            # First time ever - always reward
            should_reward = True
            reward_reason = "üéÅ Welcome Gift!"
            self.blocker.adhd_buster["first_launch_complete"] = True
        else:
            # Subsequent launches - 10% daily chance
            import random
            if random.random() < 0.10:
                should_reward = True
                reward_reason = "üé≤ Lucky Daily Drop!"
        
        if should_reward:
            # Set reward date FIRST to prevent race conditions (rapid open/close)
            self.blocker.adhd_buster["last_daily_reward_date"] = today
            
            # CRITICAL: Save immediately to prevent duplicate rewards on crash/restart
            # This must happen BEFORE any dialog is shown or item is generated
            if GAMIFICATION_AVAILABLE:
                sync_hero_data(self.blocker.adhd_buster)
            self.blocker.save_config()
            
            # Get active story for themed item generation
            active_story = self.blocker.adhd_buster.get("active_story", "warrior")
            
            # Generate boosted item with correct story theme
            item = generate_daily_reward_item(self.blocker.adhd_buster, story_id=active_story)
            
            # Ensure item has all required fields
            if "obtained_at" not in item:
                item["obtained_at"] = datetime.now().isoformat()
            
            # Use GameState manager for reactive updates
            game_state = getattr(self, 'game_state', None)
            if not game_state:
                logger.error("GameStateManager not available - cannot award daily reward")
                return
            
            # Use batch award - handles inventory, auto-equip, save, and signals
            game_state.award_items_batch([item], coins=0, auto_equip=False, source="daily_reward")
            
            # Sync changes to active hero
            if GAMIFICATION_AVAILABLE:
                sync_hero_data(self.blocker.adhd_buster)
                self.blocker.save_config()
            
            # Show reward dialog with ItemRewardDialog for comparison
            current_tier = get_current_tier(self.blocker.adhd_buster)
            boosted_tier = get_boosted_rarity(current_tier)
            equipped = self.blocker.adhd_buster.get("equipped", {})
            
            from styled_dialog import ItemRewardDialog
            dialog = ItemRewardDialog(
                parent=self,
                title=f"üéÅ {reward_reason}",
                header_emoji="üéÅ",
                source_label="Daily Login Reward",
                items_earned=[item],
                equipped=equipped,
                extra_messages=[f"Tier boost: {current_tier} ‚Üí {boosted_tier}"],
                game_state=getattr(self, 'game_state', None)  # For themed slot names
            )
            dialog.exec()

    def _setup_system_tray(self) -> None:
        """Setup system tray icon if available."""
        if not QtWidgets.QSystemTrayIcon.isSystemTrayAvailable():
            return

        self.tray_icon = QtWidgets.QSystemTrayIcon(self)
        self.tray_icon.setToolTip("Personal Liberty - Focus Blocker")

        # Create tray icon (green circle with check)
        self._update_tray_icon(blocking=False)

        # Create tray menu
        tray_menu = QtWidgets.QMenu()
        
        self.tray_status_action = tray_menu.addAction("Ready")
        self.tray_status_action.setEnabled(False)
        tray_menu.addSeparator()
        
        show_action = tray_menu.addAction("Show Window")
        show_action.triggered.connect(self._restore_from_tray)
        
        exit_action = tray_menu.addAction("Exit")
        exit_action.triggered.connect(self._quit_application)
        
        self.tray_icon.setContextMenu(tray_menu)
        self.tray_icon.activated.connect(self._on_tray_activated)

        # Timer to update tray status
        self.tray_update_timer = QtCore.QTimer(self)
        self.tray_update_timer.setInterval(1000)
        self.tray_update_timer.timeout.connect(self._update_tray_status)

        # Show tray icon immediately and start update timer
        self.tray_icon.show()
        self.tray_update_timer.start()

    def _get_base_tray_pixmap(self, blocking: bool = False) -> QtGui.QPixmap:
        """Get the base tray icon pixmap (loaded from file or generated)."""
        # Try to load icon from file first
        icon_name = "tray_blocking.png" if blocking else "tray_ready.png"
        
        # Use get_resource_path which handles both dev and frozen (PyInstaller) modes
        from app_utils import get_resource_path
        resource_icon = get_resource_path("icons", icon_name)
        if resource_icon.exists():
            return QtGui.QIcon(str(resource_icon)).pixmap(64, 64)
        
        # Fallback: check script directory locations
        script_dir = Path(__file__).parent
        icon_paths = [
            script_dir / "icons" / icon_name,
            script_dir / icon_name,
            script_dir.parent / "icons" / icon_name,
        ]
        
        for icon_path in icon_paths:
            if icon_path.exists():
                return QtGui.QIcon(str(icon_path)).pixmap(64, 64)
        
        # Fallback: generate icon dynamically if files not found
        size = 64
        pixmap = QtGui.QPixmap(size, size)
        pixmap.fill(QtCore.Qt.transparent)

        painter = QtGui.QPainter(pixmap)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)

        if blocking:
            # Blue circle when blocking
            painter.setBrush(QtGui.QColor("#0EA5E9"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#0369A1"), 2))
            painter.drawEllipse(4, 4, size - 8, size - 8)
            # Sword symbol
            painter.setBrush(QtGui.QColor("white"))
            painter.setPen(QtCore.Qt.NoPen)
            # Blade
            points = [QtCore.QPoint(32, 8), QtCore.QPoint(38, 40), QtCore.QPoint(26, 40)]
            painter.drawPolygon(points)
            # Guard
            painter.drawRect(22, 40, 20, 4)
            # Grip
            painter.drawRect(29, 44, 6, 10)
        else:
            # Green circle when ready
            painter.setBrush(QtGui.QColor("#10B981"))
            painter.setPen(QtGui.QPen(QtGui.QColor("#047857"), 2))
            painter.drawEllipse(4, 4, size - 8, size - 8)
            # Sword symbol
            painter.setBrush(QtGui.QColor("white"))
            painter.setPen(QtCore.Qt.NoPen)
            # Blade
            points = [QtCore.QPoint(32, 8), QtCore.QPoint(38, 40), QtCore.QPoint(26, 40)]
            painter.drawPolygon(points)
            # Guard
            painter.drawRect(22, 40, 20, 4)
            # Grip
            painter.drawRect(29, 44, 6, 10)

        painter.end()
        return pixmap

    def _update_tray_icon(self, blocking: bool = False) -> None:
        """Update the tray icon image."""
        if not self.tray_icon:
            return
            
        pixmap = self._get_base_tray_pixmap(blocking)
        self.tray_icon.setIcon(QtGui.QIcon(pixmap))

    def _create_tray_icon_with_minutes(self, minutes: int, blocking: bool = True) -> QtGui.QIcon:
        """Create a tray icon with remaining minutes (Legendary style with Rare blue gradient).
        
        Args:
            minutes: Minutes remaining to display (0-999)
            blocking: Whether blocking is active (determines icon color)
            
        Returns:
            QIcon with minutes overlay
        """
        # Create a blank transparent pixmap
        size = 64
        pixmap = QtGui.QPixmap(size, size)
        pixmap.fill(QtCore.Qt.transparent)

        painter = QtGui.QPainter(pixmap)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        painter.setRenderHint(QtGui.QPainter.TextAntialiasing)

        border_width = 4
        outer_margin = 2
        inner_margin = outer_margin + border_width
        
        # Draw Legendary Orange Gradient Border (bottom to top) - STRONG CONTRAST
        orange_gradient = QtGui.QLinearGradient(0, size, 0, 0)  # bottom to top
        orange_gradient.setColorAt(0, QtGui.QColor("#E65100"))  # Dark orange at bottom
        orange_gradient.setColorAt(1, QtGui.QColor("#FFE0B2"))  # Very light orange at top
        
        painter.setBrush(orange_gradient)
        painter.setPen(QtCore.Qt.NoPen)
        painter.drawEllipse(outer_margin, outer_margin, size - 2*outer_margin, size - 2*outer_margin)
        
        # Draw Rare Blue Gradient Background (top to bottom) - STRONG CONTRAST
        blue_gradient = QtGui.QLinearGradient(0, 0, 0, size)  # top to bottom
        blue_gradient.setColorAt(0, QtGui.QColor("#90CAF9"))  # Very light blue at top
        blue_gradient.setColorAt(1, QtGui.QColor("#0D47A1"))  # Very dark blue at bottom
        
        painter.setBrush(blue_gradient)
        painter.setPen(QtCore.Qt.NoPen)
        painter.drawEllipse(inner_margin, inner_margin, size - 2*inner_margin, size - 2*inner_margin)

        # Draw Number
        painter.setPen(QtGui.QColor("white"))
        
        # Scaling logic for font size
        text = str(minutes)
        if len(text) >= 3:
            font_size = 20
        elif len(text) == 2:
            font_size = 26
        else:
            font_size = 32
        
        font = QtGui.QFont("Arial", font_size, QtGui.QFont.Bold)
        painter.setFont(font)
        
        rect = QtCore.QRect(0, 0, size, size)
        painter.drawText(rect, QtCore.Qt.AlignCenter, text)

        painter.end()

        return QtGui.QIcon(pixmap)
        painter.setFont(font)
        
        rect = QtCore.QRect(badge_x, badge_y, badge_size, badge_size)
        painter.drawText(rect, QtCore.Qt.AlignCenter, text)

        painter.end()

        return QtGui.QIcon(pixmap)
        if minutes >= 100:
            font_size = 18
        elif minutes >= 10:
            font_size = 24
        else:
            font_size = 28
        
        font = QtGui.QFont("Arial", font_size, QtGui.QFont.Bold)
        painter.setFont(font)
        
        # Draw the number centered
        text = str(minutes)
        rect = QtCore.QRect(0, 0, size, size)
        painter.drawText(rect, QtCore.Qt.AlignCenter, text)

        painter.end()

        return QtGui.QIcon(pixmap)

    def _update_tray_icon_with_time(self, minutes: int) -> None:
        """Update tray icon with minutes remaining, only if changed.
        
        Args:
            minutes: Minutes remaining to display
        """
        if not self.tray_icon:
            return
            
        # Only update if minutes changed (minimize system impact)
        if self._last_tray_minutes == minutes:
            return
            
        self._last_tray_minutes = minutes
        icon = self._create_tray_icon_with_minutes(minutes, blocking=True)
        self.tray_icon.setIcon(icon)

    def _setup_window_icon(self) -> None:
        """Setup window/taskbar icon with base icon."""
        from app_utils import get_resource_path
        
        # Load base window icon
        icon_path = get_resource_path("icons", "app.ico")
        if icon_path.exists():
            self._base_window_icon = QtGui.QIcon(str(icon_path))
            self.setWindowIcon(self._base_window_icon)
        else:
            # Fallback to PNG
            png_path = get_resource_path("icons", "tray_ready.png")
            if png_path.exists():
                self._base_window_icon = QtGui.QIcon(str(png_path))
                self.setWindowIcon(self._base_window_icon)

    def _create_taskbar_icon_with_minutes(self, minutes: int) -> QtGui.QIcon:
        """Create taskbar icon with countdown overlay badge.
        
        Args:
            minutes: Minutes remaining to display
            
        Returns:
            QIcon with countdown badge overlay
        """
        # Create icon with multiple sizes for Windows taskbar compatibility
        icon = QtGui.QIcon()
        
        for size in [16, 24, 32, 48, 64, 128, 256]:
            pixmap = self._create_countdown_pixmap(size, minutes)
            icon.addPixmap(pixmap)
        
        return icon

    def _create_countdown_pixmap(self, size: int, minutes: int) -> QtGui.QPixmap:
        """Create a pixmap with countdown badge at specified size.
        
        Args:
            size: Pixmap size in pixels
            minutes: Minutes remaining to display
            
        Returns:
            QPixmap with countdown badge overlay
        """
        # Start with base icon
        pixmap = QtGui.QPixmap(size, size)
        pixmap.fill(QtCore.Qt.transparent)
        
        # Draw base icon (scaled to fit)
        painter = QtGui.QPainter(pixmap)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        painter.setRenderHint(QtGui.QPainter.SmoothPixmapTransform)
        
        if self._base_window_icon:
            # Request the icon at this size
            base_pixmap = self._base_window_icon.pixmap(size, size)
            painter.drawPixmap(0, 0, base_pixmap)
        
        # Draw countdown badge in bottom-right corner
        # Scale badge relative to icon size (approx 50% of size for visibility)
        badge_size = max(12, int(size * 0.50))
        badge_x = size - badge_size - max(1, size // 32)
        badge_y = size - badge_size - max(1, size // 32)
        border_width = max(2, size // 32)
        
        # Orange gradient border (legendary)
        border_gradient = QtGui.QLinearGradient(
            badge_x, badge_y + badge_size,  # Start at bottom
            badge_x, badge_y  # End at top
        )
        border_gradient.setColorAt(0, QtGui.QColor("#E65100"))  # Dark orange at bottom
        border_gradient.setColorAt(1, QtGui.QColor("#FFE0B2"))  # Light orange at top
        
        painter.setBrush(border_gradient)
        painter.setPen(QtCore.Qt.NoPen)
        painter.drawEllipse(badge_x - border_width, badge_y - border_width, 
                           badge_size + border_width * 2, badge_size + border_width * 2)
        
        # Blue gradient background (rare)
        bg_gradient = QtGui.QLinearGradient(
            badge_x, badge_y,  # Start at top
            badge_x, badge_y + badge_size  # End at bottom
        )
        bg_gradient.setColorAt(0, QtGui.QColor("#90CAF9"))  # Light blue at top
        bg_gradient.setColorAt(1, QtGui.QColor("#0D47A1"))  # Dark blue at bottom
        
        painter.setBrush(bg_gradient)
        painter.drawEllipse(badge_x, badge_y, badge_size, badge_size)
        
        # Draw white text
        painter.setPen(QtGui.QColor("#FFFFFF"))
        
        # Adaptive font size based on badge size and digit count
        if minutes >= 100:
            font_size = max(6, int(badge_size * 0.42))  # 3 digits
        elif minutes >= 10:
            font_size = max(7, int(badge_size * 0.50))  # 2 digits
        else:
            font_size = max(8, int(badge_size * 0.58))  # 1 digit
        
        font = QtGui.QFont("Arial", font_size, QtGui.QFont.Bold)
        painter.setFont(font)
        
        text = str(minutes)
        rect = QtCore.QRect(badge_x, badge_y, badge_size, badge_size)
        painter.drawText(rect, QtCore.Qt.AlignCenter, text)
        
        painter.end()
        
        return pixmap

    def _update_taskbar_icon_with_time(self, minutes: int) -> None:
        """Update taskbar/window icon with countdown badge.
        
        Args:
            minutes: Minutes remaining to display
        """
        # Only update if minutes changed
        if self._last_taskbar_minutes == minutes:
            return
            
        self._last_taskbar_minutes = minutes
        icon = self._create_taskbar_icon_with_minutes(minutes)
        self.setWindowIcon(icon)

    def _restore_taskbar_icon(self) -> None:
        """Restore original taskbar icon (without countdown)."""
        self._last_taskbar_minutes = None
        if self._base_window_icon:
            self.setWindowIcon(self._base_window_icon)

    def _update_tray_status(self) -> None:
        """Update tray icon status text and minutes display."""
        if not self.tray_icon:
            return

        if self.timer_tab.timer_running:
            remaining = self.timer_tab.remaining_seconds
            h = remaining // 3600
            m = (remaining % 3600) // 60
            s = remaining % 60
            self.tray_status_action.setText(f"üîí Blocking - {h:02d}:{m:02d}:{s:02d}")
            self.tray_icon.setToolTip(f"Personal Liberty - Blocking ({h:02d}:{m:02d}:{s:02d})")
            
            # Update icon with remaining minutes (total minutes, not just the m component)
            total_minutes = (remaining + 59) // 60  # Round up to nearest minute
            self._update_tray_icon_with_time(total_minutes)
            self._update_taskbar_icon_with_time(total_minutes)
        else:
            self.tray_status_action.setText("Ready")
            self.tray_icon.setToolTip("Personal Liberty - Ready")
            
            # Reset to normal icon when not blocking
            if self._last_tray_minutes is not None:
                self._last_tray_minutes = None
                self._update_tray_icon(blocking=False)
            
            # Restore taskbar icon
            self._restore_taskbar_icon()

    def _on_tray_activated(self, reason: QtWidgets.QSystemTrayIcon.ActivationReason) -> None:
        """Handle tray icon activation (double-click to restore)."""
        if reason == QtWidgets.QSystemTrayIcon.DoubleClick:
            self._restore_from_tray()

    def _restore_from_tray(self) -> None:
        """Restore window from system tray."""
        self.showNormal()  # Ensures window is not minimized
        self.raise_()
        self.activateWindow()
        # Notify Entitidex tab to resume animations if it's currently visible
        if hasattr(self, 'entitidex_tab') and self.entitidex_tab:
            self.entitidex_tab.on_window_restored()
        # Tray icon stays visible and timer keeps running

    def _quit_application(self) -> None:
        """Force quit the application (bypasses minimize to tray)."""
        self._force_quit = True
        self._unregister_hotkey()
        # Stop tray icon and update timer
        if self.tray_icon:
            self.tray_icon.hide()
        if hasattr(self, 'tray_update_timer') and self.tray_update_timer:
            self.tray_update_timer.stop()
        # Force close the window and quit the app
        self.close()
        QtWidgets.QApplication.instance().quit()

    def changeEvent(self, event: QtCore.QEvent) -> None:
        """Handle window state changes - notify tabs about minimize/restore."""
        if event.type() == QtCore.QEvent.WindowStateChange:
            if self.windowState() & QtCore.Qt.WindowMinimized:
                # Window was minimized - notify Entitidex tab to pause animations
                if hasattr(self, 'entitidex_tab') and self.entitidex_tab:
                    self.entitidex_tab.on_window_minimized()
            else:
                # Window was restored (any non-minimized state)
                # Check if the old state was minimized
                try:
                    # QWindowStateChangeEvent has oldState() method
                    old_state = event.oldState()
                    if old_state & QtCore.Qt.WindowMinimized:
                        # Window was restored from minimized - notify Entitidex tab to resume
                        if hasattr(self, 'entitidex_tab') and self.entitidex_tab:
                            self.entitidex_tab.on_window_restored()
                except AttributeError:
                    pass  # Not a QWindowStateChangeEvent, ignore
        super().changeEvent(event)

    def _hide_to_tray(self) -> None:
        """Hide window to system tray."""
        if self.tray_icon:
            # Pause Entitidex animations before hiding (saves CPU in background)
            if hasattr(self, 'entitidex_tab') and self.entitidex_tab:
                self.entitidex_tab.on_window_minimized()
            self.hide()
            self.tray_icon.showMessage(
                "Personal Liberty",
                "Still running in system tray. Double-click to restore, or right-click ‚Üí Exit to quit.",
                QtWidgets.QSystemTrayIcon.Information,
                2000
            )

    def _toggle_window_visibility(self) -> None:
        """Toggle window visibility via global hotkey."""
        if self.isVisible() and not self.isMinimized():
            if self.tray_icon and self.minimize_to_tray:
                self._hide_to_tray()
            else:
                self.showMinimized()
        else:
            self._restore_from_tray()

    def _apply_hotkey_setting(self, seq_str: str) -> bool:
        """Apply and persist a hotkey setting."""
        if not seq_str:
            self.blocker.toggle_hotkey = ""
            self.blocker.save_config()
            self._unregister_hotkey()
            return True

        ok = self._update_hotkey_registration(seq_str)
        if ok:
            self.blocker.toggle_hotkey = seq_str
            self.blocker.save_config()
        return ok

    def _update_hotkey_registration(self, seq_override: Optional[str] = None) -> bool:
        """Register or update the global hotkey using pynput (cross-platform, reliable)."""
        seq_str = seq_override if seq_override is not None else self.blocker.toggle_hotkey
        
        # First, stop any existing listener
        self._unregister_hotkey()
        
        if not seq_str:
            return True
        
        # Use pynput-based listener (preferred - works even when window hidden)
        if self._hotkey_listener:
            if self._hotkey_listener.set_hotkey(seq_str):
                if self._hotkey_listener.start():
                    self._hotkey_registered = True
                    self._registered_hotkey = seq_str
                    logger.info(f"Hotkey registered via pynput: {seq_str}")
                    return True
                else:
                    logger.warning(f"Failed to start pynput hotkey listener for: {seq_str}")
            else:
                logger.warning(f"Failed to parse hotkey for pynput: {seq_str}")
        
        # Fallback to Windows RegisterHotKey if pynput failed
        if platform.system() == "Windows":
            parsed = self._parse_hotkey_sequence(seq_str)
            if parsed:
                modifiers, vk = parsed
                user32 = ctypes.windll.user32
                hwnd = int(self.winId())
                if user32.RegisterHotKey(hwnd, self._hotkey_id, modifiers, vk):
                    self._hotkey_registered = True
                    self._registered_hotkey = seq_str
                    logger.info(f"Hotkey registered via Windows API (fallback): {seq_str}")
                    return True
                else:
                    logger.warning(f"Windows RegisterHotKey failed for: {seq_str}")
        
        return False

    def _unregister_hotkey(self) -> None:
        """Stop the hotkey listener."""
        # Stop pynput listener
        if self._hotkey_listener:
            self._hotkey_listener.stop()
        
        # Also unregister Windows hotkey if it was registered as fallback
        if platform.system() == "Windows" and self._hotkey_registered:
            try:
                ctypes.windll.user32.UnregisterHotKey(int(self.winId()), self._hotkey_id)
            except Exception:
                pass
        
        self._hotkey_registered = False
        self._registered_hotkey = ""

    def _parse_hotkey_sequence(self, seq_str: str) -> Optional[tuple[int, int]]:
        seq = QtGui.QKeySequence(seq_str)
        if seq.count() == 0:
            return None
        
        # Handle QKeyCombination in PySide6
        key_combo = seq[0]
        if hasattr(key_combo, 'toCombined'):
            # PySide6 6.5+
            key = int(key_combo.toCombined())
        else:
            # Older PySide6 or direct int
            key = int(key_combo)
        
        # Get modifier values - use .value for PySide6 enum compatibility
        def get_mod_value(mod):
            return mod.value if hasattr(mod, 'value') else int(mod)
        
        shift_mod = get_mod_value(QtCore.Qt.KeyboardModifier.ShiftModifier)
        ctrl_mod = get_mod_value(QtCore.Qt.KeyboardModifier.ControlModifier)
        alt_mod = get_mod_value(QtCore.Qt.KeyboardModifier.AltModifier)
        meta_mod = get_mod_value(QtCore.Qt.KeyboardModifier.MetaModifier)
        
        mod_mask = shift_mod | ctrl_mod | alt_mod | meta_mod
        mods = key & mod_mask
        if mods == 0:
            return None
        key_code = key & ~mod_mask
        vk = self._qt_key_to_vk(key_code)
        if vk is None:
            return None

        mod_flags = 0
        if mods & alt_mod:
            mod_flags |= 0x0001  # MOD_ALT
        if mods & ctrl_mod:
            mod_flags |= 0x0002  # MOD_CONTROL
        if mods & shift_mod:
            mod_flags |= 0x0004  # MOD_SHIFT
        if mods & meta_mod:
            mod_flags |= 0x0008  # MOD_WIN

        return mod_flags, vk

    def _qt_key_to_vk(self, key_code: int) -> Optional[int]:
        if QtCore.Qt.Key_A <= key_code <= QtCore.Qt.Key_Z:
            return ord('A') + (key_code - QtCore.Qt.Key_A)
        if QtCore.Qt.Key_0 <= key_code <= QtCore.Qt.Key_9:
            return ord('0') + (key_code - QtCore.Qt.Key_0)
        if QtCore.Qt.Key_F1 <= key_code <= QtCore.Qt.Key_F12:
            return 0x70 + (key_code - QtCore.Qt.Key_F1)
        if key_code == QtCore.Qt.Key_Space:
            return 0x20
        if key_code == QtCore.Qt.Key_Tab:
            return 0x09
        if key_code == QtCore.Qt.Key_Escape:
            return 0x1B
        if key_code in (QtCore.Qt.Key_Return, QtCore.Qt.Key_Enter):
            return 0x0D
        return None

    def nativeEvent(self, eventType, message):
        if platform.system() == "Windows":
            msg = wintypes.MSG.from_address(int(message))
            # Handle global hotkey
            if msg.message == 0x0312 and msg.wParam == self._hotkey_id:
                self._toggle_window_visibility()
                return True, 0
            # WM_QUERYENDSESSION (0x0011) - Windows is shutting down or user is logging off
            if msg.message == 0x0011:
                self._on_system_shutdown()
                return True, 1  # Return True to allow shutdown to proceed
            # WM_ENDSESSION (0x0016) - Session is definitely ending
            if msg.message == 0x0016 and msg.wParam:
                self._on_system_shutdown()
                return True, 0
        return super().nativeEvent(eventType, message)

    def _on_system_shutdown(self) -> None:
        """Handle system shutdown/logoff - save shutdown time."""
        if hasattr(self, '_shutdown_recorded') and self._shutdown_recorded:
            return  # Already recorded
        self._shutdown_recorded = True
        try:
            self.blocker.record_shutdown_time("shutdown")
        except Exception:
            pass  # Don't block shutdown on error

    def _set_app_icon(self) -> None:
        """Set the application window icon from the icons folder."""
        # Use get_resource_path which handles both dev and frozen (PyInstaller) modes
        from app_utils import get_resource_path
        
        # Try ICO first (best for Windows)
        resource_ico = get_resource_path("icons", "app.ico")
        if resource_ico.exists():
            self.setWindowIcon(QtGui.QIcon(str(resource_ico)))
            return
        
        # Try PNG fallback
        resource_png = get_resource_path("icons", "app.png")
        if resource_png.exists():
            self.setWindowIcon(QtGui.QIcon(str(resource_png)))
            return
        
        # Fallback: check script directory locations
        script_dir = Path(__file__).parent
        icon_paths = [
            script_dir / "icons" / "app.ico",
            script_dir / "app.ico",
            script_dir.parent / "icons" / "app.ico",
        ]
        
        for icon_path in icon_paths:
            if icon_path.exists():
                self.setWindowIcon(QtGui.QIcon(str(icon_path)))
                return
        
        # Fallback: try PNG version
        for icon_path in icon_paths:
            png_path = icon_path.with_suffix('.png')
            if png_path.exists():
                self.setWindowIcon(QtGui.QIcon(str(png_path)))
                return

    def _create_menu_bar(self) -> None:
        menu_bar = self.menuBar()

        # File menu
        file_menu = menu_bar.addMenu("&File")
        priorities_action = file_menu.addAction("üéØ Priorities")
        priorities_action.triggered.connect(self._open_priorities)
        file_menu.addSeparator()
        exit_action = file_menu.addAction("Exit")
        exit_action.triggered.connect(self._quit_application)

        # Tools menu
        tools_menu = menu_bar.addMenu("&Tools")
        if GAMIFICATION_AVAILABLE:
            buster_action = tools_menu.addAction("ü¶∏ ADHD Buster")
            buster_action.triggered.connect(self._open_adhd_buster)
            diary_action = tools_menu.addAction("üìñ Adventure Diary")
            diary_action.triggered.connect(self._open_diary)
        cleanup_action = tools_menu.addAction("üßπ Emergency Cleanup")
        cleanup_action.triggered.connect(self._emergency_cleanup)

        # Help menu
        help_menu = menu_bar.addMenu("&Help")
        about_action = help_menu.addAction("About")
        about_action.triggered.connect(self._show_about)

    def _open_priorities(self) -> None:
        dialog = PrioritiesDialog(self.blocker, on_start_callback=self._start_priority_session, parent=self)
        dialog.exec()

    def _start_priority_session(self, priority_title: str) -> None:
        # Find if this priority is strategic
        is_strategic = False
        for priority in self.blocker.priorities:
            if priority.get("title", "").strip() == priority_title:
                is_strategic = priority.get("strategic", False)
                break
        
        # Store priority context in timer tab
        self.timer_tab.session_priority_title = priority_title
        self.timer_tab.session_is_strategic = is_strategic
        self.timer_tab._preserve_strategic_flag = True  # Prevent reset in _start_session
        self.timer_tab._is_starting_with_priority = True  # Skip priority selection dialog
        
        strategic_msg = "\n\nüí∞ This is a STRATEGIC priority!\nYou'll earn 2.5x Coins (25/hour instead of 10/hour)" if is_strategic else ""
        
        self.tabs.setCurrentWidget(self.timer_tab)
        show_info(self, "Priority Session", 
                                   f"Starting focus session for:\n\n\"{priority_title}\"{strategic_msg}\n\n"
                                   "Set your desired duration and click Start Focus!")

    def _open_adhd_buster(self) -> None:
        """Switch to the ADHD Buster tab."""
        if not GAMIFICATION_AVAILABLE or not hasattr(self, 'adhd_tab'):
            show_warning(
                self, "Unavailable",
                "ADHD Buster features are not available."
            )
            return
        
        # Find the index of the ADHD tab and switch to it
        tab_index = self.tabs.indexOf(self.adhd_tab)
        if tab_index >= 0:
            self.tabs.setCurrentIndex(tab_index)
            # Refresh the tab and set session state
            self.adhd_tab.set_session_active(self.timer_tab.timer_running)
            self.adhd_tab.refresh_all()
        
        # Update button text
        if hasattr(self, "buster_btn"):
            enabled = is_gamification_enabled(self.blocker.adhd_buster)
            self.buster_btn.setVisible(enabled)
            if enabled:
                power = calculate_character_power(self.blocker.adhd_buster)
                self.buster_btn.setText(f"ü¶∏ HERO  ‚öî {power}")

    def refresh_adhd_tab(self) -> None:
        """Refresh ADHD Buster tab if it exists."""
        if GAMIFICATION_AVAILABLE and hasattr(self, 'adhd_tab'):
            self.adhd_tab.refresh_all()

    def _open_diary(self) -> None:
        dialog = DiaryDialog(self.blocker, self)
        dialog.exec()

    def _emergency_cleanup(self) -> None:
        """Emergency cleanup with enhanced confirmation dialog."""
        # Extra warning for strict/hardcore modes
        mode = getattr(self.blocker, 'mode', None)
        if mode in (BlockMode.STRICT, BlockMode.HARDCORE) and self.blocker.is_blocking:
            reply = show_question(
                self, "‚ö†Ô∏è Active Session Detected",
                f"You have an active {mode.upper()} session!\n\n"
                "Emergency cleanup will bypass the protection you set.\n"
                "This defeats the purpose of using a strict mode.\n\n"
                "Are you SURE you want to proceed?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                QtWidgets.QMessageBox.No
            )
            if reply != QtWidgets.QMessageBox.Yes:
                return
        
        # Gather impact data
        impact_data = {
            "items_count": 0,
            "power_lost": 0,
            "progress_percent": 0,
            "coins_refund": 0,
            "items_affected": []
        }
        
        # Calculate impact from inventory
        if GAMIFICATION_AVAILABLE:
            inventory = self.blocker.adhd_buster.get("inventory", [])
            impact_data["items_count"] = len(inventory)
            impact_data["power_lost"] = self.blocker.adhd_buster.get("total_power", 0)
            impact_data["items_affected"] = inventory[:20]  # Show first 20
            
            # Calculate progress percentage
            total_xp = self.blocker.adhd_buster.get("total_xp", 0)
            if total_xp > 0:
                impact_data["progress_percent"] = min(100, int((total_xp / 10000) * 100))
        
        # Show enhanced confirmation dialog
        confirmed = show_emergency_cleanup_dialog("emergency_cleanup", impact_data, self)
        
        if confirmed:
            success, message = self.blocker.emergency_cleanup()
            if success:
                show_info(self, "Cleanup Complete", message)
            else:
                show_error(self, "Cleanup Failed", message)

    def _show_about(self) -> None:
        QtWidgets.QMessageBox.about(self, "About Personal Liberty",
            f"<b>Personal Liberty v{APP_VERSION}</b><br><br>"
            "A focus and productivity tool for Windows.<br><br>"
            "Developed by <b>Lukasz Kaczmarek</b><br><br>"
            "üìß Feedback / Bug reports: "
            "<a href='mailto:lkacz1@gmail.com?subject=Personal Liberty Feedback'>lkacz1@gmail.com</a><br><br>"
            "Built with PySide6 (Qt for Python).")

    def closeEvent(self, event: QtGui.QCloseEvent) -> None:
        """Handle window close - minimize to tray if enabled, else prompt/close."""
        force_quit = getattr(self, '_force_quit', False)
        
        # If minimize_to_tray is enabled and tray is available, hide to tray instead of closing
        if self.minimize_to_tray and self.tray_icon and not force_quit:
            event.ignore()
            self._hide_to_tray()
            return

        # Record app close time (if not already recorded by system shutdown)
        if not getattr(self, '_shutdown_recorded', False):
            self._shutdown_recorded = True
            try:
                self.blocker.record_shutdown_time("app_close")
            except Exception:
                pass  # Don't block close on error

        self._unregister_hotkey()

        # Stop tray icon and update timer
        if self.tray_icon:
            self.tray_icon.hide()
        if hasattr(self, 'tray_update_timer') and self.tray_update_timer:
            self.tray_update_timer.stop()
        if hasattr(self, '_health_reminder_timer') and self._health_reminder_timer:
            self._health_reminder_timer.stop()

        # Skip session checks if force_quit is set (e.g., user switch already confirmed)
        if force_quit:
            # Force stop any running session without prompts
            if self.timer_tab.timer_running:
                self.timer_tab._force_stop_session()
            event.accept()
            QtWidgets.QApplication.instance().quit()
            return

        if self.timer_tab.timer_running:
            # For Hardcore mode, require solving the challenge to exit
            if self.timer_tab.blocker.mode == BlockMode.HARDCORE:
                reply = show_question(
                    self,
                    "üî• Hardcore Mode Active",
                    "A Hardcore session is running!\n\n"
                    "You must solve the math challenge to exit.\n\nContinue?",
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                    QtWidgets.QMessageBox.No
                )
                if reply == QtWidgets.QMessageBox.Yes:
                    dialog = HardcoreChallengeDialog(self)
                    if dialog.exec() == QtWidgets.QDialog.Accepted:
                        self.timer_tab._force_stop_session()
                        event.accept()
                        QtWidgets.QApplication.instance().quit()
                    else:
                        event.ignore()
                else:
                    event.ignore()
                return
            
            reply = show_question(
                self,
                "Confirm Exit",
                "A focus session is still running!\n\nStop the session and exit?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                QtWidgets.QMessageBox.No
            )
            if reply == QtWidgets.QMessageBox.Yes:
                self.timer_tab._force_stop_session()
                event.accept()
                QtWidgets.QApplication.instance().quit()
            else:
                event.ignore()
        else:
            event.accept()
            QtWidgets.QApplication.instance().quit()

    def show_ai_session_complete(self, session_duration: int) -> None:
        """Show session complete dialog with break suggestions."""
        dialog = AISessionCompleteDialog(self.blocker, session_duration, self)
        dialog.exec()

    def _on_eye_routine_completed(self, item: dict) -> None:
        """Handle completion of eye protection routine."""
        # If an item was won (dict is not empty), show the unified reward dialog
        if item:
            # Get equipped item for comparison
            equipped_before = {}
            if GAMIFICATION_AVAILABLE:
                try:
                    from gamification import get_equipped_item
                    slot = item.get("slot", "Unknown")
                    equipped_item = get_equipped_item(self.blocker.adhd_buster, slot)
                    if equipped_item:
                        equipped_before[slot] = equipped_item
                except ImportError:
                    pass
            
            from styled_dialog import ItemRewardDialog
            dialog = ItemRewardDialog(
                parent=self,
                source_label="Eye Protection Routine Complete! üëÅÔ∏è",
                items_earned=[item],
                equipped=equipped_before,
                game_state=get_game_state(),
            )
            dialog.exec()
            
            # Refresh inventory UI if it exists
            if hasattr(self, 'adhd_tab'):
                self.adhd_tab.refresh_inventory()
                self._update_coin_display()

    def _on_session_complete(self, elapsed_seconds: int) -> None:
        """Handle session completion - refresh stats and related UI."""
        # Stop browser monitor if running (Light Mode)
        self._stop_browser_monitor()
        
        # Reload stats from file to ensure we have latest data
        self.blocker.load_stats()
        
        # Emit focus time changed signal for timeline ring
        if hasattr(self, 'game_state') and self.game_state:
            self.game_state.notify_focus_time_changed()
        
        # Update coin display if gamification is available
        if GAMIFICATION_AVAILABLE:
            self._update_coin_display()
        
        # Award city resources for focus session
        if CITY_AVAILABLE and hasattr(self.blocker, 'adhd_buster'):
            self._award_city_resources_for_session(elapsed_seconds)
        
        # Refresh the stats tab to show updated focus time
        if hasattr(self, 'stats_tab'):
            self.stats_tab.refresh()
        
        # Refresh AI tab if available
        if AI_AVAILABLE and hasattr(self, 'ai_tab'):
            self.ai_tab._refresh_data()
        
        # Refresh Timeline
        if hasattr(self, 'timeline_widget'):
            self.timeline_widget.update_data()
        
        # Re-enable all tabs after session ends
        self._set_tabs_enabled(True)
        
        # Refresh ADHD Buster tab after session ends
        if GAMIFICATION_AVAILABLE and hasattr(self, 'adhd_tab'):
            self.adhd_tab.set_session_active(False)
            self.adhd_tab.refresh_all()
        
        # Refresh City tab after session
        if CITY_AVAILABLE and hasattr(self, 'city_tab'):
            self.city_tab._refresh_city()

    def _on_session_started(self) -> None:
        """Handle session start - disable non-essential tabs to minimize distraction."""
        self._set_tabs_enabled(False)
        if GAMIFICATION_AVAILABLE and hasattr(self, 'adhd_tab'):
            self.adhd_tab.set_session_active(True)
        
        # Start browser monitor in Light Mode
        if self.blocker.enforcement_mode == EnforcementMode.LIGHT:
            self._start_browser_monitor()

    def _award_city_resources_for_session(self, elapsed_seconds: int) -> None:
        """
        Award city resources based on completed focus session.
        
        Resource earning formula (per design doc):
        - üéØ Focus: 1 per 30 minutes of focus time
        
        Also awards Royal Mint income (coins for focus sessions).
        
        Note: Materials come from weight management only, not focus sessions.
        
        Sets self._last_city_contribution with info for display in reward dialog.
        """
        self._last_city_contribution = None  # Reset for this session
        
        if not CITY_AVAILABLE:
            return
        
        try:
            from city import add_city_resource, award_focus_session_income, get_active_construction_info
            
            minutes = elapsed_seconds // 60
            
            # Focus: 1 per 30 minutes (as per design doc)
            focus_earned = minutes // 30
            active_before = get_active_construction_info(self.blocker.adhd_buster)
            
            if focus_earned > 0:
                # Check for active construction before adding
                invested = add_city_resource(self.blocker.adhd_buster, "focus", focus_earned)
                
                # Store contribution info for reward dialog display
                if invested > 0 and active_before:
                    building_name = active_before.get("building_name", "Building")
                    building_id = active_before.get("building_id", "")
                    level = active_before.get("level", 1)
                    progress_after = get_active_construction_info(self.blocker.adhd_buster)
                    
                    # Check if construction completed (no more active construction)
                    if progress_after is None:
                        # Construction completed!
                        self._last_city_contribution = {
                            "resource": "focus",
                            "amount": invested,
                            "building_name": building_name,
                            "building_id": building_id,
                            "level": level,
                            "progress_percent": 100.0,
                            "completed": True
                        }
                        logger.info(f"Focus session completed construction of {building_name}!")
                    else:
                        new_progress = progress_after.get("effort_progress_percent", 0)
                        self._last_city_contribution = {
                            "resource": "focus",
                            "amount": invested,
                            "building_name": building_name,
                            "building_id": building_id,
                            "level": level,
                            "progress_percent": new_progress,
                            "completed": False
                        }
                        logger.info(f"Focus session contributed {invested} focus to {building_name} ({new_progress:.0f}% complete)")
                elif focus_earned > 0:
                    if not active_before:
                        # No active construction
                        self._last_city_contribution = {
                            "resource": "focus",
                            "amount": focus_earned,
                            "building_name": None,
                            "progress_percent": 0,
                            "completed": False,
                            "wasted": True
                        }
                        logger.debug(f"Focus earned ({focus_earned}) but no active construction to apply it to")
            else:
                # Session too short to earn Focus - show informative message
                if active_before and minutes > 0:
                    mins_needed = 30 - (minutes % 30)
                    building_name = active_before.get("building_name", "Building")
                    self._last_city_contribution = {
                        "resource": "focus",
                        "amount": 0,
                        "building_name": building_name,
                        "progress_percent": active_before.get("effort_progress_percent", 0),
                        "completed": False,
                        "short_session": True,
                        "mins_needed": mins_needed
                    }
                    logger.debug(f"Session too short for focus ({minutes} min, need {mins_needed} more)")
            
            # Award Royal Mint income for focus session
            game_state = getattr(self, 'game_state', None)
            income_result = award_focus_session_income(
                self.blocker.adhd_buster,
                minutes,
                game_state
            )
            
            # Show notification if coins were earned
            if income_result.get("coins", 0) > 0:
                coins = income_result["coins"]
                # Build breakdown message
                breakdown_parts = []
                for item in income_result.get("breakdown", []):
                    breakdown_parts.append(f"{item['building']}: +{item['total_coins']} coins")
                breakdown_msg = ", ".join(breakdown_parts) if breakdown_parts else ""
                
                logger.info(f"Focus session awarded {coins} city coins: {breakdown_msg}")
                
                # Update coin display
                self._update_coin_display()
            
            # Save data
            self.blocker.save_config()
            
        except Exception as e:
            logger.warning(f"Failed to award city resources: {e}")

    def _add_dev_tab(self) -> None:
        """Add the Developer tools tab (hidden by default)."""
        if not GAMIFICATION_AVAILABLE:
            return
        if self.dev_tab is not None:
            return  # Already added
        
        self.dev_tab = DevTab(self.blocker, self)
        self.tabs.addTab(self.dev_tab, "üõ†Ô∏è Dev")

    def _on_dev_mode_enabled(self) -> None:
        """Handle dev mode being enabled via version tap."""
        self._add_dev_tab()
        # Switch to the newly added Dev tab
        if self.dev_tab:
            self.tabs.setCurrentWidget(self.dev_tab)
    
    def _start_browser_monitor(self) -> None:
        """Start the browser monitor for Light Mode notifications."""
        try:
            from browser_monitor import create_browser_monitor
            
            blocked_sites = self.blocker.get_effective_blacklist()
            self.browser_monitor = create_browser_monitor(
                blocked_sites,
                self._on_browser_violation
            )
            self.browser_monitor.start()
        except Exception as e:
            print(f"Warning: Could not start browser monitor: {e}")
    
    def _stop_browser_monitor(self) -> None:
        """Stop the browser monitor."""
        if self.browser_monitor:
            try:
                self.browser_monitor.stop()
            except Exception:
                pass
            self.browser_monitor = None
    
    def _on_browser_violation(self, domain: str) -> None:
        """Handle when user visits a blocked site in Light Mode."""
        # Show toast notification
        if self.tray_icon:
            self.tray_icon.showMessage(
                "üîî Focus Reminder",
                f"You're visiting {domain} during a focus session.\nStay focused! üí™",
                QtWidgets.QSystemTrayIcon.Information,
                5000  # 5 seconds
            )
    
    def _set_tabs_enabled(self, enabled: bool) -> None:
        """Enable or disable non-essential tabs during focus sessions.
        
        The following tabs remain enabled during sessions:
        - Timer tab: needed to stop the session or view remaining time
        - Weight tab: for logging weight during longer sessions
        - Activity tab: for logging activities during sessions
        - Sleep tab: for sleep-related tracking
        - Water tab: for hydration tracking during sessions
        - Eye & Breath tab: for eye breaks and breathing exercises
        
        These health/wellness tabs are allowed because longer focus sessions
        benefit from users being able to track water intake, take eye breaks,
        and log activities without breaking their flow.
        """
        # Tabs that should remain enabled during focus sessions
        always_enabled_tabs = []
        
        # Collect references to always-enabled tabs
        if hasattr(self, 'timer_tab'):
            always_enabled_tabs.append(self.timer_tab)
        if hasattr(self, 'weight_tab'):
            always_enabled_tabs.append(self.weight_tab)
        if hasattr(self, 'activity_tab'):
            always_enabled_tabs.append(self.activity_tab)
        if hasattr(self, 'sleep_tab'):
            always_enabled_tabs.append(self.sleep_tab)
        if hasattr(self, 'hydration_tab'):
            always_enabled_tabs.append(self.hydration_tab)
        if hasattr(self, 'eye_tab'):
            always_enabled_tabs.append(self.eye_tab)
        
        for i in range(self.tabs.count()):
            widget = self.tabs.widget(i)
            # Keep always-enabled tabs accessible during focus sessions
            if widget in always_enabled_tabs:
                continue
            self.tabs.setTabEnabled(i, enabled)

    def _connect_timeline_signals(self) -> None:
        """Connect timeline ring widget clicks to tab navigation.
        
        Called after tabs are created to enable navigation:
        - Water ring ‚Üí Water tab
        - Chapter ring ‚Üí Story tab
        - Focus ring ‚Üí Timer tab
        - XP ring ‚Üí Hero tab
        - Hero mini widget ‚Üí Hero tab
        - Entities ring ‚Üí Entitidex tab
        """
        # Use a deferred connection since tabs aren't created yet when this is called
        QtCore.QTimer.singleShot(0, self._do_connect_timeline_signals)
    
    def _do_connect_timeline_signals(self) -> None:
        """Actually connect the timeline signals after tabs exist."""
        if not hasattr(self, 'timeline_widget'):
            return
            
        self.timeline_widget.water_clicked.connect(self._go_to_water_tab)
        self.timeline_widget.chapter_clicked.connect(self._go_to_story_tab)
        self.timeline_widget.focus_clicked.connect(self._go_to_timer_tab)
        self.timeline_widget.xp_clicked.connect(self._go_to_hero_tab)
        self.timeline_widget.entities_clicked.connect(self._go_to_entitidex_tab)
        self.timeline_widget.hero_clicked.connect(self._go_to_hero_tab)
        self.timeline_widget.eye_clicked.connect(self._go_to_eye_tab)
    
    def _go_to_water_tab(self) -> None:
        """Navigate to the Water tab."""
        if hasattr(self, 'hydration_tab'):
            index = self.tabs.indexOf(self.hydration_tab)
            if index >= 0:
                self.tabs.setCurrentIndex(index)
    
    def _go_to_timer_tab(self) -> None:
        """Navigate to the Timer tab."""
        if hasattr(self, 'timer_tab'):
            index = self.tabs.indexOf(self.timer_tab)
            if index >= 0:
                self.tabs.setCurrentIndex(index)
    
    def _go_to_hero_tab(self) -> None:
        """Navigate to the Hero tab."""
        if GAMIFICATION_AVAILABLE and hasattr(self, 'adhd_tab'):
            index = self.tabs.indexOf(self.adhd_tab)
            if index >= 0:
                self.tabs.setCurrentIndex(index)

    def _go_to_story_tab(self) -> None:
        """Navigate to the Story tab."""
        if GAMIFICATION_AVAILABLE and hasattr(self, 'story_tab'):
            index = self.tabs.indexOf(self.story_tab)
            if index >= 0:
                self.tabs.setCurrentIndex(index)

    def _go_to_entitidex_tab(self) -> None:
        """Navigate to the Entitidex tab."""
        if GAMIFICATION_AVAILABLE and hasattr(self, 'entitidex_tab'):
            index = self.tabs.indexOf(self.entitidex_tab)
            if index >= 0:
                self.tabs.setCurrentIndex(index)

    def _go_to_eye_tab(self) -> None:
        """Navigate to the Eye & Breath tab."""
        if hasattr(self, 'eye_tab'):
            index = self.tabs.indexOf(self.eye_tab)
            if index >= 0:
                self.tabs.setCurrentIndex(index)

    def _on_tab_changed(self, index: int) -> None:
        """Handle tab changes - refresh data for the newly selected tab."""
        widget = self.tabs.widget(index)
        
        # === Critical Performance Fix: Pause Entitidex animations when not visible ===
        # Entitidex cards have shimmer timers (50ms interval) and glow animations
        # running continuously. When switching away, we MUST pause these to avoid
        # CPU drain even when the tab is hidden.
        if GAMIFICATION_AVAILABLE and hasattr(self, 'entitidex_tab'):
            if widget == self.entitidex_tab:
                # Switching TO Entitidex - resume animations
                self.entitidex_tab._resume_all_animations()
            else:
                # Switching AWAY from Entitidex - pause animations
                self.entitidex_tab._pause_all_animations()
        
        # Refresh stats tab when switched to
        if hasattr(self, 'stats_tab') and widget == self.stats_tab:
            self.blocker.load_stats()
            self.stats_tab.refresh()
        
        # Refresh AI tab when switched to
        elif AI_AVAILABLE and hasattr(self, 'ai_tab') and widget == self.ai_tab:
            self.ai_tab._refresh_data()
        
        # Refresh ADHD Buster tab when switched to
        elif GAMIFICATION_AVAILABLE and hasattr(self, 'adhd_tab') and widget == self.adhd_tab:
            self.adhd_tab.set_session_active(self.timer_tab.timer_running)
            self.adhd_tab.refresh_all()
        
        # Refresh Story tab when switched to
        elif GAMIFICATION_AVAILABLE and hasattr(self, 'story_tab') and widget == self.story_tab:
            self.story_tab._refresh_all()


def check_single_instance(retry_count: int = 3, retry_delay_ms: int = 500):
    """Check if another instance is already running using a Windows mutex.
    
    Uses retry logic to handle race conditions during Windows startup where
    another instance may be starting simultaneously.
    
    Args:
        retry_count: Number of times to retry acquiring the mutex
        retry_delay_ms: Delay between retries in milliseconds
    
    Returns:
        The mutex handle if this is the first instance, None otherwise.
    """
    if platform.system() != "Windows":
        return True  # No mutex on non-Windows
    
    import ctypes
    import time
    
    for attempt in range(retry_count):
        try:
            # Try to create a named mutex
            mutex = ctypes.windll.kernel32.CreateMutexW(None, True, MUTEX_NAME)
            last_error = ctypes.windll.kernel32.GetLastError()
            
            # ERROR_ALREADY_EXISTS = 183
            if last_error == 183:
                # Another instance is running
                ctypes.windll.kernel32.CloseHandle(mutex)
                
                # On first attempts, wait and retry (handles startup race condition)
                if attempt < retry_count - 1:
                    time.sleep(retry_delay_ms / 1000.0)
                    continue
                    
                return None
            
            # This is the first instance, return the mutex handle
            return mutex
        except Exception:
            # If we can't create a mutex, allow running anyway
            return True
    
    return None


def find_and_activate_existing_window():
    """Try to find and activate an existing Personal Liberty window."""
    if platform.system() != "Windows":
        return False
    
    try:
        import ctypes
        from ctypes import wintypes
        
        user32 = ctypes.windll.user32
        
        # Find window by title
        hwnd = user32.FindWindowW(None, "Personal Liberty")
        if hwnd:
            # Constants
            SW_RESTORE = 9
            SW_SHOW = 5
            
            # Restore if minimized
            user32.ShowWindow(hwnd, SW_RESTORE)
            # Bring to foreground
            user32.SetForegroundWindow(hwnd)
            return True
        
        # Try partial match with version
        EnumWindows = user32.EnumWindows
        EnumWindowsProc = ctypes.WINFUNCTYPE(wintypes.BOOL, wintypes.HWND, wintypes.LPARAM)
        GetWindowTextW = user32.GetWindowTextW
        GetWindowTextLengthW = user32.GetWindowTextLengthW
        
        found_hwnd = [None]
        
        def enum_callback(hwnd, lParam):
            length = GetWindowTextLengthW(hwnd)
            if length > 0:
                buff = ctypes.create_unicode_buffer(length + 1)
                GetWindowTextW(hwnd, buff, length + 1)
                title = buff.value
                if "Personal Liberty" in title:
                    found_hwnd[0] = hwnd
                    return False  # Stop enumeration
            return True
        
        EnumWindows(EnumWindowsProc(enum_callback), 0)
        
        if found_hwnd[0]:
            user32.ShowWindow(found_hwnd[0], 9)  # SW_RESTORE
            user32.SetForegroundWindow(found_hwnd[0])
            return True
        
        return False
    except Exception:
        return False


def kill_existing_instances():
    """Kill all existing PersonalLiberty processes except the current one."""
    if platform.system() != "Windows":
        return False
    
    try:
        import subprocess
        current_pid = os.getpid()
        
        # Use taskkill to terminate PersonalLiberty.exe processes
        result = subprocess.run(
            ["taskkill", "/F", "/IM", "PersonalLiberty.exe"],
            capture_output=True,
            text=True
        )
        
        # Give processes time to terminate
        import time
        time.sleep(1)
        
        return True
    except Exception:
        return False


def _check_and_create_lock_file() -> bool:
    """
    Check and create a lock file for additional single-instance protection.
    
    This provides a secondary mechanism alongside the mutex, especially useful
    during Windows startup when the mutex may not be immediately visible.
    
    Returns:
        True if we acquired the lock (first instance), False if another instance holds it.
    """
    import time
    
    lock_path = _get_lock_file_path()
    
    try:
        # Check if lock file exists and is recent (within last 30 seconds indicates active app)
        if lock_path.exists():
            try:
                # Read the PID from lock file
                content = lock_path.read_text().strip()
                if content:
                    parts = content.split(":")
                    if len(parts) >= 2:
                        locked_pid = int(parts[0])
                        lock_time = float(parts[1])
                        
                        # Check if the process is still running
                        if platform.system() == "Windows":
                            import ctypes
                            kernel32 = ctypes.windll.kernel32
                            SYNCHRONIZE = 0x00100000
                            handle = kernel32.OpenProcess(SYNCHRONIZE, False, locked_pid)
                            if handle:
                                kernel32.CloseHandle(handle)
                                # Process exists - check if lock is recent (within 60 seconds)
                                if time.time() - lock_time < 60:
                                    return False  # Another instance is running
                                # Lock is stale, take over
            except (ValueError, OSError):
                pass  # Invalid lock file, take over
        
        # Create/update lock file with our PID
        lock_path.write_text(f"{os.getpid()}:{time.time()}")
        return True
        
    except Exception:
        # On any error, allow running
        return True


def _update_lock_file():
    """Update the lock file timestamp to indicate we're still running."""
    import time
    try:
        lock_path = _get_lock_file_path()
        lock_path.write_text(f"{os.getpid()}:{time.time()}")
    except Exception:
        pass


def _remove_lock_file():
    """Remove the lock file on exit."""
    try:
        lock_path = _get_lock_file_path()
        if lock_path.exists():
            content = lock_path.read_text().strip()
            # Only remove if it's our lock
            if content.startswith(f"{os.getpid()}:"):
                lock_path.unlink()
    except Exception:
        pass


def main() -> None:
    # Handle startup delay for system boot (prevents race conditions)
    # Check for --startup-delay argument
    startup_delay = 0
    for arg in sys.argv:
        if arg.startswith("--startup-delay="):
            try:
                startup_delay = int(arg.split("=")[1])
            except ValueError:
                pass
    
    if startup_delay > 0:
        import time
        time.sleep(startup_delay)
    
    # Set application attributes before creating QApplication
    QtWidgets.QApplication.setHighDpiScaleFactorRoundingPolicy(
        QtCore.Qt.HighDpiScaleFactorRoundingPolicy.PassThrough
    )
    
    # Create application instance
    app = QtWidgets.QApplication(sys.argv)
    app.setApplicationName("Personal Liberty")
    app.setOrganizationName("PersonalLiberty")
    app.setApplicationVersion(APP_VERSION)
    
    # Check lock file first (faster, works better during startup)
    if not _check_and_create_lock_file():
        # Lock file indicates another instance - verify with mutex
        pass  # Continue to mutex check
    
    # Check for single instance using mutex (with retry for race conditions)
    mutex_handle = check_single_instance()
    if mutex_handle is None:
        # Another instance is running - ask user what to do
        result = styled_question(
            None,
            "Already Running",
            "Personal Liberty is already running.\n\nWhat would you like to do?",
            ["Switch to Running App", "Kill & Restart", "Cancel"]
        )
        
        if result == "Switch to Running App":
            # Try to activate existing window
            if find_and_activate_existing_window():
                sys.exit(0)
            else:
                show_warning(
                    None, "Not Found",
                    "Could not find the running window.\n\n"
                    "The app may be minimized to system tray.\n"
                    "Check your system tray icons."
                )
                sys.exit(0)
        elif result == "Kill & Restart":
            # Kill existing instances and continue
            kill_existing_instances()
            _remove_lock_file()  # Remove stale lock file
            # Try to acquire mutex again
            mutex_handle = check_single_instance()
            if mutex_handle is None:
                show_error(
                    None, "Failed",
                    "Could not terminate the existing instance.\n\n"
                    "Please close it manually from Task Manager."
                )
                sys.exit(1)
        else:
            sys.exit(0)
    
    # Parse command-line arguments
    # --show flag will show the main window instead of starting in tray
    show_window = "--show" in sys.argv
    
    # Load heavy modules
    try:
        load_heavy_modules()
    except Exception as e:
        import traceback
        logger.error(f"Failed to load modules: {e}")
        show_error(None, "Startup Error", f"Failed to load application modules:\n{e}")
        traceback.print_exc()
        sys.exit(1)
    
    # User Selection Logic
    try:
        from core_logic import APP_DIR
        from user_manager import UserManager
        from user_selection_dialog import UserSelectionDialog
        
        user_manager = UserManager(APP_DIR)
        user_manager.migrate_if_needed()
        
        # Check for auto-login
        last_user = user_manager.get_last_user()
        selected_user = None

        if last_user:
            # Validate that auto-login user still exists with proper directory
            if user_manager.user_exists(last_user):
                try:
                    user_dir = user_manager.get_user_dir(last_user)
                    if user_dir.exists() and user_dir.is_dir():
                        selected_user = last_user
                    else:
                        # Directory was deleted - clear invalid last_user
                        user_manager.clear_last_user()
                        last_user = None
                except (ValueError, OSError):
                    # Invalid user - clear and prompt
                    user_manager.clear_last_user()
                    last_user = None
            else:
                # User no longer exists - clear invalid last_user
                user_manager.clear_last_user()
                last_user = None
        
        if not selected_user:
            selection_dialog = UserSelectionDialog(user_manager)
            if selection_dialog.exec() == QtWidgets.QDialog.Accepted:
                selected_user = selection_dialog.selected_user
                if selected_user:  # Validate selection is not None
                    user_manager.save_last_user(selected_user)
                else:
                    show_error(None, "Selection Error", "No user profile was selected.")
                    sys.exit(1)
            else:
                sys.exit(0)
    except ImportError as e:
        show_error(None, "Startup Error", f"Failed to import required modules:\n{e}")
        sys.exit(1)
    except KeyboardInterrupt:
        sys.exit(0)
    except Exception as e:
        import traceback
        with open("crash_log.txt", "w") as f:
            traceback.print_exc(file=f)
        show_error(
            None, 
            "Unexpected Error", 
            f"An unexpected error occurred during user selection:\n{e}\n\nPlease report this issue."
        )
        traceback.print_exc()
        sys.exit(1)
    
    # Create main window
    try:
        window = FocusBlockerWindow(username=selected_user)
    except Exception as e:
        import traceback
        logger.error(f"Failed to create main window: {e}")
        with open("crash_log.txt", "w") as f:
            traceback.print_exc(file=f)
        show_error(
            None, 
            "Startup Error", 
            f"Failed to create main window:\n{e}\n\nSee crash_log.txt for details."
        )
        traceback.print_exc()
        sys.exit(1)
    
    # Start silently in system tray by default, unless --show flag is passed
    if show_window or not window.tray_icon:
        # Show the main window
        window.show()
        window.raise_()
        window.activateWindow()
    else:
        # Start minimized to system tray (silent startup)
        window.hide()
        
        # Play startup sound if enabled (after short delay for stability)
        if window.blocker.startup_sound_enabled:
            try:
                from startup_sounds import play_startup_sound, is_sound_available
                if is_sound_available():
                    # Small delay to let the app fully initialize
                    QtCore.QTimer.singleShot(500, play_startup_sound)
            except ImportError:
                pass  # Startup sounds module not available
    
    # Set up periodic lock file update (every 30 seconds) to indicate we're running
    lock_update_timer = QtCore.QTimer()
    lock_update_timer.timeout.connect(_update_lock_file)
    lock_update_timer.start(30000)  # 30 seconds
    
    exit_code = app.exec()
    
    # Clean up lock file on exit
    _remove_lock_file()
    
    # Release the mutex on exit
    if mutex_handle and mutex_handle is not True:
        try:
            import ctypes
            ctypes.windll.kernel32.ReleaseMutex(mutex_handle)
            ctypes.windll.kernel32.CloseHandle(mutex_handle)
        except Exception:
            pass
    
    sys.exit(exit_code)


if __name__ == "__main__":
    main()
